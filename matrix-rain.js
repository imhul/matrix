var t = Object.defineProperty, s = (s, i, e) => ((s, i, e) => i in s ? t(s, i, { enumerable: !0, configurable: !0, writable: !0, value: e }) : s[i] = e)(s, "symbol" != typeof i ? i + "" : i, e); const i = function () { const t = "undefined" != typeof document && document.createElement("link").relList; return t && t.supports && t.supports("modulepreload") ? "modulepreload" : "preload" }(), e = {}, n = function (t, s, n) { let r = Promise.resolve(); if (s && s.length > 0) { let t = function (t) { return Promise.all(t.map(t => Promise.resolve(t).then(t => ({ status: "fulfilled", value: t }), t => ({ status: "rejected", reason: t })))) }; const o = document.getElementsByTagName("link"), h = document.querySelector("meta[property=csp-nonce]"), a = h?.nonce || h?.getAttribute("nonce"); r = t(s.map(t => { if (t = function (t, s) { return new URL(t, s).href }(t, n), t in e) return; e[t] = !0; const s = t.endsWith(".css"), r = s ? '[rel="stylesheet"]' : ""; if (n) for (let i = o.length - 1; i >= 0; i--) { const e = o[i]; if (e.href === t && (!s || "stylesheet" === e.rel)) return } else if (document.querySelector(`link[href="${t}"]${r}`)) return; const h = document.createElement("link"); return h.rel = s ? "stylesheet" : i, s || (h.as = "script"), h.crossOrigin = "", h.href = t, a && h.setAttribute("nonce", a), document.head.appendChild(h), s ? new Promise((s, i) => { h.addEventListener("load", s), h.addEventListener("error", () => i(new Error(`Unable to preload CSS for ${t}`))) }) : void 0 })) } function o(t) { const s = new Event("vite:preloadError", { cancelable: !0 }); if (s.payload = t, window.dispatchEvent(s), !s.defaultPrevented) throw t } return r.then(s => { for (const t of s || []) "rejected" === t.status && o(t.reason); return t().catch(o) }) }; var r = (t => (t.Application = "application", t.WebGLPipes = "webgl-pipes", t.WebGLPipesAdaptor = "webgl-pipes-adaptor", t.WebGLSystem = "webgl-system", t.WebGPUPipes = "webgpu-pipes", t.WebGPUPipesAdaptor = "webgpu-pipes-adaptor", t.WebGPUSystem = "webgpu-system", t.CanvasSystem = "canvas-system", t.CanvasPipesAdaptor = "canvas-pipes-adaptor", t.CanvasPipes = "canvas-pipes", t.Asset = "asset", t.LoadParser = "load-parser", t.ResolveParser = "resolve-parser", t.CacheParser = "cache-parser", t.DetectionParser = "detection-parser", t.MaskEffect = "mask-effect", t.BlendMode = "blend-mode", t.TextureSource = "texture-source", t.Environment = "environment", t.ShapeBuilder = "shape-builder", t.Batcher = "batcher", t))(r || {}); const o = t => { if ("function" == typeof t || "object" == typeof t && t.extension) { if (!t.extension) throw new Error("Extension class must have an extension object"); t = { ..."object" != typeof t.extension ? { type: t.extension } : t.extension, ref: t } } if ("object" != typeof t) throw new Error("Invalid extension type"); return "string" == typeof (t = { ...t }).type && (t.type = [t.type]), t }, h = (t, s) => o(t).priority ?? s, a = { o: {}, u: {}, p: {}, remove(...t) { return t.map(o).forEach(t => { t.type.forEach(s => this.u[s]?.(t)) }), this }, add(...t) { return t.map(o).forEach(t => { t.type.forEach(s => { const i = this.o, e = this.p; i[s] ? i[s]?.(t) : (e[s] = e[s] || [], e[s]?.push(t)) }) }), this }, handle(t, s, i) { const e = this.o, n = this.u; if (e[t] || n[t]) throw new Error(`Extension type ${t} already has a handler`); e[t] = s, n[t] = i; const r = this.p; return r[t] && (r[t]?.forEach(t => s(t)), delete r[t]), this }, handleByMap(t, s) { return this.handle(t, t => { t.name && (s[t.name] = t.ref) }, t => { t.name && delete s[t.name] }) }, handleByNamedList(t, s, i = -1) { return this.handle(t, t => { s.findIndex(s => s.name === t.name) >= 0 || (s.push({ name: t.name, value: t.ref }), s.sort((t, s) => h(s.value, i) - h(t.value, i))) }, t => { const i = s.findIndex(s => s.name === t.name); -1 !== i && s.splice(i, 1) }) }, handleByList(t, s, i = -1) { return this.handle(t, t => { s.includes(t.ref) || (s.push(t.ref), s.sort((t, s) => h(s, i) - h(t, i))) }, t => { const i = s.indexOf(t.ref); -1 !== i && s.splice(i, 1) }) }, mixin(t, ...s) { for (const i of s) Object.defineProperties(t.prototype, Object.getOwnPropertyDescriptors(i)) } }, u = { extension: { type: r.Environment, name: "browser", priority: -1 }, test: () => !0, load: async () => { await n(() => Promise.resolve().then(() => Kc), void 0, import.meta.url) } }, l = { extension: { type: r.Environment, name: "webworker", priority: 0 }, test: () => "undefined" != typeof self && void 0 !== self.WorkerGlobalScope, load: async () => { await n(() => Promise.resolve().then(() => Zc), void 0, import.meta.url) } }; class c { constructor(t, s, i) { this.M = s || 0, this.T = i || 0, this.A = t } clone(t) { return new c(t ?? this.A, this.M, this.T) } set(t = 0, s = t) { return this.M === t && this.T === s || (this.M = t, this.T = s, this.A.C(this)), this } copyFrom(t) { return this.M === t.x && this.T === t.y || (this.M = t.x, this.T = t.y, this.A.C(this)), this } copyTo(t) { return t.set(this.M, this.T), t } equals(t) { return t.x === this.M && t.y === this.T } toString() { return `[pixi.js/math:ObservablePoint x=${this.M} y=${this.T} scope=${this.A}]` } get x() { return this.M } set x(t) { this.M !== t && (this.M = t, this.A.C(this)) } get y() { return this.T } set y(t) { this.T !== t && (this.T = t, this.A.C(this)) } } function f(t) { return t && t._ && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t } var d, p = { exports: {} }; const m = f((d || (d = 1, function (t) { var s = Object.prototype.hasOwnProperty, i = "~"; function e() { } function n(t, s, i) { this.fn = t, this.context = s, this.once = i || !1 } function r(t, s, e, r, o) { if ("function" != typeof e) throw new TypeError("The listener must be a function"); var h = new n(e, r || t, o), a = i ? i + s : s; return t.P[a] ? t.P[a].fn ? t.P[a] = [t.P[a], h] : t.P[a].push(h) : (t.P[a] = h, t.k++), t } function o(t, s) { 0 === --t.k ? t.P = new e : delete t.P[s] } function h() { this.P = new e, this.k = 0 } Object.create && (e.prototype = Object.create(null), (new e).__proto__ || (i = !1)), h.prototype.eventNames = function () { var t, e, n = []; if (0 === this.k) return n; for (e in t = this.P) s.call(t, e) && n.push(i ? e.slice(1) : e); return Object.getOwnPropertySymbols ? n.concat(Object.getOwnPropertySymbols(t)) : n }, h.prototype.listeners = function (t) { var s = i ? i + t : t, e = this.P[s]; if (!e) return []; if (e.fn) return [e.fn]; for (var n = 0, r = e.length, o = new Array(r); n < r; n++)o[n] = e[n].fn; return o }, h.prototype.listenerCount = function (t) { var s = i ? i + t : t, e = this.P[s]; return e ? e.fn ? 1 : e.length : 0 }, h.prototype.emit = function (t, s, e, n, r, o) { var h = i ? i + t : t; if (!this.P[h]) return !1; var a, u, l = this.P[h], c = arguments.length; if (l.fn) { switch (l.once && this.removeListener(t, l.fn, void 0, !0), c) { case 1: return l.fn.call(l.context), !0; case 2: return l.fn.call(l.context, s), !0; case 3: return l.fn.call(l.context, s, e), !0; case 4: return l.fn.call(l.context, s, e, n), !0; case 5: return l.fn.call(l.context, s, e, n, r), !0; case 6: return l.fn.call(l.context, s, e, n, r, o), !0 }for (u = 1, a = new Array(c - 1); u < c; u++)a[u - 1] = arguments[u]; l.fn.apply(l.context, a) } else { var f, d = l.length; for (u = 0; u < d; u++)switch (l[u].once && this.removeListener(t, l[u].fn, void 0, !0), c) { case 1: l[u].fn.call(l[u].context); break; case 2: l[u].fn.call(l[u].context, s); break; case 3: l[u].fn.call(l[u].context, s, e); break; case 4: l[u].fn.call(l[u].context, s, e, n); break; default: if (!a) for (f = 1, a = new Array(c - 1); f < c; f++)a[f - 1] = arguments[f]; l[u].fn.apply(l[u].context, a) } } return !0 }, h.prototype.on = function (t, s, i) { return r(this, t, s, i, !1) }, h.prototype.once = function (t, s, i) { return r(this, t, s, i, !0) }, h.prototype.removeListener = function (t, s, e, n) { var r = i ? i + t : t; if (!this.P[r]) return this; if (!s) return o(this, r), this; var h = this.P[r]; if (h.fn) h.fn !== s || n && !h.once || e && h.context !== e || o(this, r); else { for (var a = 0, u = [], l = h.length; a < l; a++)(h[a].fn !== s || n && !h[a].once || e && h[a].context !== e) && u.push(h[a]); u.length ? this.P[r] = 1 === u.length ? u[0] : u : o(this, r) } return this }, h.prototype.removeAllListeners = function (t) { var s; return t ? (s = i ? i + t : t, this.P[s] && o(this, s)) : (this.P = new e, this.k = 0), this }, h.prototype.off = h.prototype.removeListener, h.prototype.addListener = h.prototype.on, h.prefixed = i, h.EventEmitter = h, t.exports = h }(p)), p.exports)), g = 2 * Math.PI, v = 180 / Math.PI, b = Math.PI / 180; class x { constructor(t = 0, s = 0) { this.x = 0, this.y = 0, this.x = t, this.y = s } clone() { return new x(this.x, this.y) } copyFrom(t) { return this.set(t.x, t.y), this } copyTo(t) { return t.set(this.x, this.y), t } equals(t) { return t.x === this.x && t.y === this.y } set(t = 0, s = t) { return this.x = t, this.y = s, this } toString() { return `[pixi.js/math:Point x=${this.x} y=${this.y}]` } static get shared() { return y.x = 0, y.y = 0, y } } const y = new x; let w = class t { constructor(t = 1, s = 0, i = 0, e = 1, n = 0, r = 0) { this.array = null, this.a = t, this.b = s, this.c = i, this.d = e, this.tx = n, this.ty = r } fromArray(t) { this.a = t[0], this.b = t[1], this.c = t[3], this.d = t[4], this.tx = t[2], this.ty = t[5] } set(t, s, i, e, n, r) { return this.a = t, this.b = s, this.c = i, this.d = e, this.tx = n, this.ty = r, this } toArray(t, s) { this.array || (this.array = new Float32Array(9)); const i = s || this.array; return t ? (i[0] = this.a, i[1] = this.b, i[2] = 0, i[3] = this.c, i[4] = this.d, i[5] = 0, i[6] = this.tx, i[7] = this.ty, i[8] = 1) : (i[0] = this.a, i[1] = this.c, i[2] = this.tx, i[3] = this.b, i[4] = this.d, i[5] = this.ty, i[6] = 0, i[7] = 0, i[8] = 1), i } apply(t, s) { s = s || new x; const i = t.x, e = t.y; return s.x = this.a * i + this.c * e + this.tx, s.y = this.b * i + this.d * e + this.ty, s } applyInverse(t, s) { s = s || new x; const i = this.a, e = this.b, n = this.c, r = this.d, o = this.tx, h = this.ty, a = 1 / (i * r + n * -e), u = t.x, l = t.y; return s.x = r * a * u + -n * a * l + (h * n - o * r) * a, s.y = i * a * l + -e * a * u + (-h * i + o * e) * a, s } translate(t, s) { return this.tx += t, this.ty += s, this } scale(t, s) { return this.a *= t, this.d *= s, this.c *= t, this.b *= s, this.tx *= t, this.ty *= s, this } rotate(t) { const s = Math.cos(t), i = Math.sin(t), e = this.a, n = this.c, r = this.tx; return this.a = e * s - this.b * i, this.b = e * i + this.b * s, this.c = n * s - this.d * i, this.d = n * i + this.d * s, this.tx = r * s - this.ty * i, this.ty = r * i + this.ty * s, this } append(t) { const s = this.a, i = this.b, e = this.c, n = this.d; return this.a = t.a * s + t.b * e, this.b = t.a * i + t.b * n, this.c = t.c * s + t.d * e, this.d = t.c * i + t.d * n, this.tx = t.tx * s + t.ty * e + this.tx, this.ty = t.tx * i + t.ty * n + this.ty, this } appendFrom(t, s) { const i = t.a, e = t.b, n = t.c, r = t.d, o = t.tx, h = t.ty, a = s.a, u = s.b, l = s.c, c = s.d; return this.a = i * a + e * l, this.b = i * u + e * c, this.c = n * a + r * l, this.d = n * u + r * c, this.tx = o * a + h * l + s.tx, this.ty = o * u + h * c + s.ty, this } setTransform(t, s, i, e, n, r, o, h, a) { return this.a = Math.cos(o + a) * n, this.b = Math.sin(o + a) * n, this.c = -Math.sin(o - h) * r, this.d = Math.cos(o - h) * r, this.tx = t - (i * this.a + e * this.c), this.ty = s - (i * this.b + e * this.d), this } prepend(t) { const s = this.tx; if (1 !== t.a || 0 !== t.b || 0 !== t.c || 1 !== t.d) { const s = this.a, i = this.c; this.a = s * t.a + this.b * t.c, this.b = s * t.b + this.b * t.d, this.c = i * t.a + this.d * t.c, this.d = i * t.b + this.d * t.d } return this.tx = s * t.a + this.ty * t.c + t.tx, this.ty = s * t.b + this.ty * t.d + t.ty, this } decompose(t) { const s = this.a, i = this.b, e = this.c, n = this.d, r = t.pivot, o = -Math.atan2(-e, n), h = Math.atan2(i, s), a = Math.abs(o + h); return a < 1e-5 || Math.abs(g - a) < 1e-5 ? (t.rotation = h, t.skew.x = t.skew.y = 0) : (t.rotation = 0, t.skew.x = o, t.skew.y = h), t.scale.x = Math.sqrt(s * s + i * i), t.scale.y = Math.sqrt(e * e + n * n), t.position.x = this.tx + (r.x * s + r.y * e), t.position.y = this.ty + (r.x * i + r.y * n), t } invert() { const t = this.a, s = this.b, i = this.c, e = this.d, n = this.tx, r = t * e - s * i; return this.a = e / r, this.b = -s / r, this.c = -i / r, this.d = t / r, this.tx = (i * this.ty - e * n) / r, this.ty = -(t * this.ty - s * n) / r, this } isIdentity() { return 1 === this.a && 0 === this.b && 0 === this.c && 1 === this.d && 0 === this.tx && 0 === this.ty } identity() { return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.tx = 0, this.ty = 0, this } clone() { const s = new t; return s.a = this.a, s.b = this.b, s.c = this.c, s.d = this.d, s.tx = this.tx, s.ty = this.ty, s } copyTo(t) { return t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty, t } copyFrom(t) { return this.a = t.a, this.b = t.b, this.c = t.c, this.d = t.d, this.tx = t.tx, this.ty = t.ty, this } equals(t) { return t.a === this.a && t.b === this.b && t.c === this.c && t.d === this.d && t.tx === this.tx && t.ty === this.ty } toString() { return `[pixi.js:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]` } static get IDENTITY() { return T.identity() } static get shared() { return M.identity() } }; const M = new w, T = new w, A = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1], C = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1], _ = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1], S = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1], P = [], k = [], F = Math.sign; !function () { for (let t = 0; t < 16; t++) { const s = []; P.push(s); for (let i = 0; i < 16; i++) { const e = F(A[t] * A[i] + _[t] * C[i]), n = F(C[t] * A[i] + S[t] * C[i]), r = F(A[t] * _[i] + _[t] * S[i]), o = F(C[t] * _[i] + S[t] * S[i]); for (let t = 0; t < 16; t++)if (A[t] === e && C[t] === n && _[t] === r && S[t] === o) { s.push(t); break } } } for (let t = 0; t < 16; t++) { const s = new w; s.set(A[t], C[t], _[t], S[t], 0, 0), k.push(s) } }(); const E = { E: 0, SE: 1, S: 2, SW: 3, W: 4, NW: 5, N: 6, NE: 7, MIRROR_VERTICAL: 8, MAIN_DIAGONAL: 10, MIRROR_HORIZONTAL: 12, REVERSE_DIAGONAL: 14, uX: t => A[t], uY: t => C[t], vX: t => _[t], vY: t => S[t], inv: t => 8 & t ? 15 & t : 7 & -t, add: (t, s) => P[t][s], sub: (t, s) => P[t][E.inv(s)], rotate180: t => 4 ^ t, isVertical: t => 2 == (3 & t), byDirection: (t, s) => 2 * Math.abs(t) <= Math.abs(s) ? s >= 0 ? E.S : E.N : 2 * Math.abs(s) <= Math.abs(t) ? t > 0 ? E.E : E.W : s > 0 ? t > 0 ? E.SE : E.SW : t > 0 ? E.NE : E.NW, matrixAppendRotationInv: (t, s, i = 0, e = 0) => { const n = k[E.inv(s)]; n.tx = i, n.ty = e, t.append(n) }, transformRectCoords: (t, s, i, e) => { const { x: n, y: r, width: o, height: h } = t, { x: a, y: u, width: l, height: c } = s; return i === E.E ? (e.set(n + a, r + u, o, h), e) : i === E.S ? e.set(l - r - h + a, n + u, h, o) : i === E.W ? e.set(l - n - o + a, c - r - h + u, o, h) : i === E.N ? e.set(r + a, c - n - o + u, h, o) : e.set(n + a, r + u, o, h) } }, R = [new x, new x, new x, new x]; class O { constructor(t = 0, s = 0, i = 0, e = 0) { this.type = "rectangle", this.x = Number(t), this.y = Number(s), this.width = Number(i), this.height = Number(e) } get left() { return this.x } get right() { return this.x + this.width } get top() { return this.y } get bottom() { return this.y + this.height } isEmpty() { return this.left === this.right || this.top === this.bottom } static get EMPTY() { return new O(0, 0, 0, 0) } clone() { return new O(this.x, this.y, this.width, this.height) } copyFromBounds(t) { return this.x = t.minX, this.y = t.minY, this.width = t.maxX - t.minX, this.height = t.maxY - t.minY, this } copyFrom(t) { return this.x = t.x, this.y = t.y, this.width = t.width, this.height = t.height, this } copyTo(t) { return t.copyFrom(this), t } contains(t, s) { return !(this.width <= 0 || this.height <= 0) && t >= this.x && t < this.x + this.width && s >= this.y && s < this.y + this.height } strokeContains(t, s, i, e = .5) { const { width: n, height: r } = this; if (n <= 0 || r <= 0) return !1; const o = this.x, h = this.y, a = i * (1 - e), u = i - a; return t >= o - a && t <= o + n + a && s >= h - a && s <= h + r + a && !(t > o + u && t < o + n - u && s > h + u && s < h + r - u) } intersects(t, s) { if (!s) { const s = this.x < t.x ? t.x : this.x; if ((this.right > t.right ? t.right : this.right) <= s) return !1; const i = this.y < t.y ? t.y : this.y; return (this.bottom > t.bottom ? t.bottom : this.bottom) > i } const i = this.left, e = this.right, n = this.top, r = this.bottom; if (e <= i || r <= n) return !1; const o = R[0].set(t.left, t.top), h = R[1].set(t.left, t.bottom), a = R[2].set(t.right, t.top), u = R[3].set(t.right, t.bottom); if (a.x <= o.x || h.y <= o.y) return !1; const l = Math.sign(s.a * s.d - s.b * s.c); if (0 === l) return !1; if (s.apply(o, o), s.apply(h, h), s.apply(a, a), s.apply(u, u), Math.max(o.x, h.x, a.x, u.x) <= i || Math.min(o.x, h.x, a.x, u.x) >= e || Math.max(o.y, h.y, a.y, u.y) <= n || Math.min(o.y, h.y, a.y, u.y) >= r) return !1; const c = l * (h.y - o.y), f = l * (o.x - h.x), d = c * i + f * n, p = c * e + f * n, m = c * i + f * r, g = c * e + f * r; if (Math.max(d, p, m, g) <= c * o.x + f * o.y || Math.min(d, p, m, g) >= c * u.x + f * u.y) return !1; const v = l * (o.y - a.y), b = l * (a.x - o.x), x = v * i + b * n, y = v * e + b * n, w = v * i + b * r, M = v * e + b * r; return !(Math.max(x, y, w, M) <= v * o.x + b * o.y || Math.min(x, y, w, M) >= v * u.x + b * u.y) } pad(t = 0, s = t) { return this.x -= t, this.y -= s, this.width += 2 * t, this.height += 2 * s, this } fit(t) { const s = Math.max(this.x, t.x), i = Math.min(this.x + this.width, t.x + t.width), e = Math.max(this.y, t.y), n = Math.min(this.y + this.height, t.y + t.height); return this.x = s, this.width = Math.max(i - s, 0), this.y = e, this.height = Math.max(n - e, 0), this } ceil(t = 1, s = .001) { const i = Math.ceil((this.x + this.width - s) * t) / t, e = Math.ceil((this.y + this.height - s) * t) / t; return this.x = Math.floor((this.x + s) * t) / t, this.y = Math.floor((this.y + s) * t) / t, this.width = i - this.x, this.height = e - this.y, this } scale(t, s = t) { return this.x *= t, this.y *= s, this.width *= t, this.height *= s, this } enlarge(t) { const s = Math.min(this.x, t.x), i = Math.max(this.x + this.width, t.x + t.width), e = Math.min(this.y, t.y), n = Math.max(this.y + this.height, t.y + t.height); return this.x = s, this.width = i - s, this.y = e, this.height = n - e, this } getBounds(t) { return t || (t = new O), t.copyFrom(this), t } containsRect(t) { if (this.width <= 0 || this.height <= 0) return !1; const s = t.x, i = t.y, e = t.x + t.width, n = t.y + t.height; return s >= this.x && s < this.x + this.width && i >= this.y && i < this.y + this.height && e >= this.x && e < this.x + this.width && n >= this.y && n < this.y + this.height } set(t, s, i, e) { return this.x = t, this.y = s, this.width = i, this.height = e, this } toString() { return `[pixi.js/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]` } } const U = { default: -1 }; function I(t = "default") { return void 0 === U[t] && (U[t] = -1), ++U[t] } const B = new Set, G = { quiet: !1, noColor: !1 }, $ = (t, s, i = 3) => { if (G.quiet || B.has(s)) return; let e = (new Error).stack; "function" == typeof console.groupCollapsed && G.noColor, void 0 === e || (e = e.split("\n").splice(i).join("\n")), B.add(s) }; Object.defineProperties($, { quiet: { get: () => G.quiet, set: t => { G.quiet = t }, enumerable: !0, configurable: !1 }, noColor: { get: () => G.noColor, set: t => { G.noColor = t }, enumerable: !0, configurable: !1 } }); const z = () => { }; function D(t) { return t += 0 === t ? 1 : 0, --t, t |= t >>> 1, t |= t >>> 2, t |= t >>> 4, 1 + ((t |= t >>> 8) | t >>> 16) } function j(t) { return !(t & t - 1 || !t) } function L(t) { const s = {}; for (const i in t) void 0 !== t[i] && (s[i] = t[i]); return s } const V = Object.create(null), N = class t extends m { constructor(s = {}) { super(), this.F = "textureSampler", this.R = 0, this.O = 1, this.destroyed = !1, s = { ...t.defaultOptions, ...s }, this.addressMode = s.addressMode, this.addressModeU = s.addressModeU ?? this.addressModeU, this.addressModeV = s.addressModeV ?? this.addressModeV, this.addressModeW = s.addressModeW ?? this.addressModeW, this.scaleMode = s.scaleMode, this.magFilter = s.magFilter ?? this.magFilter, this.minFilter = s.minFilter ?? this.minFilter, this.mipmapFilter = s.mipmapFilter ?? this.mipmapFilter, this.lodMinClamp = s.lodMinClamp, this.lodMaxClamp = s.lodMaxClamp, this.compare = s.compare, this.maxAnisotropy = s.maxAnisotropy ?? 1 } set addressMode(t) { this.addressModeU = t, this.addressModeV = t, this.addressModeW = t } get addressMode() { return this.addressModeU } set wrapMode(t) { $(0, "TextureStyle.wrapMode is now TextureStyle.addressMode"), this.addressMode = t } get wrapMode() { return this.addressMode } set scaleMode(t) { this.magFilter = t, this.minFilter = t, this.mipmapFilter = t } get scaleMode() { return this.magFilter } set maxAnisotropy(t) { this.O = Math.min(t, 16), this.O > 1 && (this.scaleMode = "linear") } get maxAnisotropy() { return this.O } get U() { return this.I || this.B() } update() { this.emit("change", this), this.I = null } B() { const t = `${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this.O}`; return this.I = function (t) { const s = V[t]; return void 0 === s && (V[t] = I("resource")), s }(t), this.U } destroy() { this.destroyed = !0, this.emit("destroy", this), this.emit("change", this), this.removeAllListeners() } }; N.defaultOptions = { addressMode: "clamp-to-edge", scaleMode: "linear" }; let W = N; const H = class t extends m { constructor(s = {}) { super(), this.options = s, this.uid = I("textureSource"), this.F = "textureSource", this.U = I("resource"), this.uploadMethodId = "unknown", this.G = 1, this.pixelWidth = 1, this.pixelHeight = 1, this.width = 1, this.height = 1, this.sampleCount = 1, this.mipLevelCount = 1, this.autoGenerateMipmaps = !1, this.format = "rgba8unorm", this.dimension = "2d", this.antialias = !1, this.R = 0, this.$ = -1, this.D = -1, s = { ...t.defaultOptions, ...s }, this.label = s.label ?? "", this.resource = s.resource, this.autoGarbageCollect = s.autoGarbageCollect, this.G = s.resolution, s.width ? this.pixelWidth = s.width * this.G : this.pixelWidth = this.resource ? this.resourceWidth ?? 1 : 1, s.height ? this.pixelHeight = s.height * this.G : this.pixelHeight = this.resource ? this.resourceHeight ?? 1 : 1, this.width = this.pixelWidth / this.G, this.height = this.pixelHeight / this.G, this.format = s.format, this.dimension = s.dimensions, this.mipLevelCount = s.mipLevelCount, this.autoGenerateMipmaps = s.autoGenerateMipmaps, this.sampleCount = s.sampleCount, this.antialias = s.antialias, this.alphaMode = s.alphaMode, this.style = new W(L(s)), this.destroyed = !1, this.j() } get source() { return this } get style() { return this.L } set style(t) { this.style !== t && (this.L?.off("change", this.V, this), this.L = t, this.L?.on("change", this.V, this), this.V()) } set maxAnisotropy(t) { this.L.maxAnisotropy = t } get maxAnisotropy() { return this.L.maxAnisotropy } get addressMode() { return this.L.addressMode } set addressMode(t) { this.L.addressMode = t } get repeatMode() { return this.L.addressMode } set repeatMode(t) { this.L.addressMode = t } get magFilter() { return this.L.magFilter } set magFilter(t) { this.L.magFilter = t } get minFilter() { return this.L.minFilter } set minFilter(t) { this.L.minFilter = t } get mipmapFilter() { return this.L.mipmapFilter } set mipmapFilter(t) { this.L.mipmapFilter = t } get lodMinClamp() { return this.L.lodMinClamp } set lodMinClamp(t) { this.L.lodMinClamp = t } get lodMaxClamp() { return this.L.lodMaxClamp } set lodMaxClamp(t) { this.L.lodMaxClamp = t } V() { this.emit("styleChange", this) } update() { if (this.resource) { const t = this.G; if (this.resize(this.resourceWidth / t, this.resourceHeight / t)) return } this.emit("update", this) } destroy() { this.destroyed = !0, this.emit("destroy", this), this.emit("change", this), this.L && (this.L.destroy(), this.L = null), this.uploadMethodId = null, this.resource = null, this.removeAllListeners() } unload() { this.U = I("resource"), this.emit("change", this), this.emit("unload", this) } get resourceWidth() { const { resource: t } = this; return t.naturalWidth || t.videoWidth || t.displayWidth || t.width } get resourceHeight() { const { resource: t } = this; return t.naturalHeight || t.videoHeight || t.displayHeight || t.height } get resolution() { return this.G } set resolution(t) { this.G !== t && (this.G = t, this.width = this.pixelWidth / t, this.height = this.pixelHeight / t) } resize(t, s, i) { i || (i = this.G), t || (t = this.width), s || (s = this.height); const e = Math.round(t * i), n = Math.round(s * i); return this.width = e / i, this.height = n / i, this.G = i, (this.pixelWidth !== e || this.pixelHeight !== n) && (this.j(), this.pixelWidth = e, this.pixelHeight = n, this.emit("resize", this), this.U = I("resource"), this.emit("change", this), !0) } updateMipmaps() { this.autoGenerateMipmaps && this.mipLevelCount > 1 && this.emit("updateMipmaps", this) } set wrapMode(t) { this.L.wrapMode = t } get wrapMode() { return this.L.wrapMode } set scaleMode(t) { this.L.scaleMode = t } get scaleMode() { return this.L.scaleMode } j() { this.isPowerOfTwo = j(this.pixelWidth) && j(this.pixelHeight) } static test(t) { throw new Error("Unimplemented") } }; H.defaultOptions = { resolution: 1, format: "bgra8unorm", alphaMode: "premultiply-alpha-on-upload", dimensions: "2d", mipLevelCount: 1, autoGenerateMipmaps: !1, sampleCount: 1, antialias: !1, autoGarbageCollect: !1 }; let q = H; class X extends q { constructor(t) { const s = t.resource || new Float32Array(t.width * t.height * 4); let i = t.format; i || (i = s instanceof Float32Array ? "rgba32float" : s instanceof Int32Array || s instanceof Uint32Array ? "rgba32uint" : s instanceof Int16Array || s instanceof Uint16Array ? "rgba16uint" : (Int8Array, "bgra8unorm")), super({ ...t, resource: s, format: i }), this.uploadMethodId = "buffer" } static test(t) { return t instanceof Int8Array || t instanceof Uint8Array || t instanceof Uint8ClampedArray || t instanceof Int16Array || t instanceof Uint16Array || t instanceof Int32Array || t instanceof Uint32Array || t instanceof Float32Array } } X.extension = r.TextureSource; const Y = new w; class K { constructor(t, s) { this.mapCoord = new w, this.uClampFrame = new Float32Array(4), this.uClampOffset = new Float32Array(2), this.H = -1, this.X = 0, this.clampOffset = 0, this.clampMargin = void 0 === s ? t.width < 10 ? 0 : .5 : s, this.isSimple = !1, this.texture = t } get texture() { return this.Y } set texture(t) { this.texture !== t && (this.Y?.removeListener("update", this.update, this), this.Y = t, this.Y.addListener("update", this.update, this), this.update()) } multiplyUvs(t, s) { void 0 === s && (s = t); const i = this.mapCoord; for (let e = 0; e < t.length; e += 2) { const n = t[e], r = t[e + 1]; s[e] = n * i.a + r * i.c + i.tx, s[e + 1] = n * i.b + r * i.d + i.ty } return s } update() { const t = this.Y; this.X++; const s = t.uvs; this.mapCoord.set(s.x1 - s.x0, s.y1 - s.y0, s.x3 - s.x0, s.y3 - s.y0, s.x0, s.y0); const i = t.orig, e = t.trim; e && (Y.set(i.width / e.width, 0, 0, i.height / e.height, -e.x / e.width, -e.y / e.height), this.mapCoord.append(Y)); const n = t.source, r = this.uClampFrame, o = this.clampMargin / n.G, h = this.clampOffset / n.G; return r[0] = (t.frame.x + o + h) / n.width, r[1] = (t.frame.y + o + h) / n.height, r[2] = (t.frame.x + t.frame.width - o + h) / n.width, r[3] = (t.frame.y + t.frame.height - o + h) / n.height, this.uClampOffset[0] = this.clampOffset / n.pixelWidth, this.uClampOffset[1] = this.clampOffset / n.pixelHeight, this.isSimple = t.frame.width === n.width && t.frame.height === n.height && 0 === t.rotate, !0 } } class Z extends m { constructor({ source: t, label: s, frame: i, orig: e, trim: n, defaultAnchor: r, defaultBorders: o, rotate: h, dynamic: a } = {}) { if (super(), this.uid = I("texture"), this.uvs = { x0: 0, y0: 0, x1: 0, y1: 0, x2: 0, y2: 0, x3: 0, y3: 0 }, this.frame = new O, this.noFrame = !1, this.dynamic = !1, this.isTexture = !0, this.label = s, this.source = t?.source ?? new q, this.noFrame = !i, i) this.frame.copyFrom(i); else { const { width: t, height: s } = this.K; this.frame.width = t, this.frame.height = s } this.orig = e || this.frame, this.trim = n, this.rotate = h ?? 0, this.defaultAnchor = r, this.defaultBorders = o, this.destroyed = !1, this.dynamic = a || !1, this.updateUvs() } set source(t) { this.K && this.K.off("resize", this.update, this), this.K = t, t.on("resize", this.update, this), this.emit("update", this) } get source() { return this.K } get textureMatrix() { return this.Z || (this.Z = new K(this)), this.Z } get width() { return this.orig.width } get height() { return this.orig.height } updateUvs() { const { uvs: t, frame: s } = this, { width: i, height: e } = this.K, n = s.x / i, r = s.y / e, o = s.width / i, h = s.height / e; let a = this.rotate; if (a) { const s = o / 2, i = h / 2, e = n + s, u = r + i; a = E.add(a, E.NW), t.x0 = e + s * E.uX(a), t.y0 = u + i * E.uY(a), a = E.add(a, 2), t.x1 = e + s * E.uX(a), t.y1 = u + i * E.uY(a), a = E.add(a, 2), t.x2 = e + s * E.uX(a), t.y2 = u + i * E.uY(a), a = E.add(a, 2), t.x3 = e + s * E.uX(a), t.y3 = u + i * E.uY(a) } else t.x0 = n, t.y0 = r, t.x1 = n + o, t.y1 = r, t.x2 = n + o, t.y2 = r + h, t.x3 = n, t.y3 = r + h } destroy(t = !1) { this.K && (this.K.off("resize", this.update, this), t && (this.K.destroy(), this.K = null)), this.Z = null, this.destroyed = !0, this.emit("destroy", this), this.removeAllListeners() } update() { this.noFrame && (this.frame.width = this.K.width, this.frame.height = this.K.height), this.updateUvs(), this.emit("update", this) } get baseTexture() { return $(0, "Texture.baseTexture is now Texture.source"), this.K } } function Q(t, s, i) { const { width: e, height: n } = i.orig, r = i.trim; if (r) { const i = r.width, o = r.height; t.minX = r.x - s.M * e, t.maxX = t.minX + i, t.minY = r.y - s.T * n, t.maxY = t.minY + o } else t.minX = -s.M * e, t.maxX = t.minX + e, t.minY = -s.T * n, t.maxY = t.minY + n } Z.EMPTY = new Z({ label: "EMPTY", source: new q({ label: "EMPTY" }) }), Z.EMPTY.destroy = z, Z.WHITE = new Z({ source: new X({ resource: new Uint8Array([255, 255, 255, 255]), width: 1, height: 1, alphaMode: "premultiply-alpha-on-upload", label: "WHITE" }), label: "WHITE" }), Z.WHITE.destroy = z; const J = new w; class tt { constructor(t = 1 / 0, s = 1 / 0, i = -1 / 0, e = -1 / 0) { this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.matrix = J, this.minX = t, this.minY = s, this.maxX = i, this.maxY = e } isEmpty() { return this.minX > this.maxX || this.minY > this.maxY } get rectangle() { this.J || (this.J = new O); const t = this.J; return this.minX > this.maxX || this.minY > this.maxY ? (t.x = 0, t.y = 0, t.width = 0, t.height = 0) : t.copyFromBounds(this), t } clear() { return this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.matrix = J, this } set(t, s, i, e) { this.minX = t, this.minY = s, this.maxX = i, this.maxY = e } addFrame(t, s, i, e, n) { n || (n = this.matrix); const r = n.a, o = n.b, h = n.c, a = n.d, u = n.tx, l = n.ty; let c = this.minX, f = this.minY, d = this.maxX, p = this.maxY, m = r * t + h * s + u, g = o * t + a * s + l; m < c && (c = m), g < f && (f = g), m > d && (d = m), g > p && (p = g), m = r * i + h * s + u, g = o * i + a * s + l, m < c && (c = m), g < f && (f = g), m > d && (d = m), g > p && (p = g), m = r * t + h * e + u, g = o * t + a * e + l, m < c && (c = m), g < f && (f = g), m > d && (d = m), g > p && (p = g), m = r * i + h * e + u, g = o * i + a * e + l, m < c && (c = m), g < f && (f = g), m > d && (d = m), g > p && (p = g), this.minX = c, this.minY = f, this.maxX = d, this.maxY = p } addRect(t, s) { this.addFrame(t.x, t.y, t.x + t.width, t.y + t.height, s) } addBounds(t, s) { this.addFrame(t.minX, t.minY, t.maxX, t.maxY, s) } addBoundsMask(t) { this.minX = this.minX > t.minX ? this.minX : t.minX, this.minY = this.minY > t.minY ? this.minY : t.minY, this.maxX = this.maxX < t.maxX ? this.maxX : t.maxX, this.maxY = this.maxY < t.maxY ? this.maxY : t.maxY } applyMatrix(t) { const s = this.minX, i = this.minY, e = this.maxX, n = this.maxY, { a: r, b: o, c: h, d: a, tx: u, ty: l } = t; let c = r * s + h * i + u, f = o * s + a * i + l; this.minX = c, this.minY = f, this.maxX = c, this.maxY = f, c = r * e + h * i + u, f = o * e + a * i + l, this.minX = c < this.minX ? c : this.minX, this.minY = f < this.minY ? f : this.minY, this.maxX = c > this.maxX ? c : this.maxX, this.maxY = f > this.maxY ? f : this.maxY, c = r * s + h * n + u, f = o * s + a * n + l, this.minX = c < this.minX ? c : this.minX, this.minY = f < this.minY ? f : this.minY, this.maxX = c > this.maxX ? c : this.maxX, this.maxY = f > this.maxY ? f : this.maxY, c = r * e + h * n + u, f = o * e + a * n + l, this.minX = c < this.minX ? c : this.minX, this.minY = f < this.minY ? f : this.minY, this.maxX = c > this.maxX ? c : this.maxX, this.maxY = f > this.maxY ? f : this.maxY } fit(t) { return this.minX < t.left && (this.minX = t.left), this.maxX > t.right && (this.maxX = t.right), this.minY < t.top && (this.minY = t.top), this.maxY > t.bottom && (this.maxY = t.bottom), this } fitBounds(t, s, i, e) { return this.minX < t && (this.minX = t), this.maxX > s && (this.maxX = s), this.minY < i && (this.minY = i), this.maxY > e && (this.maxY = e), this } pad(t, s = t) { return this.minX -= t, this.maxX += t, this.minY -= s, this.maxY += s, this } ceil() { return this.minX = Math.floor(this.minX), this.minY = Math.floor(this.minY), this.maxX = Math.ceil(this.maxX), this.maxY = Math.ceil(this.maxY), this } clone() { return new tt(this.minX, this.minY, this.maxX, this.maxY) } scale(t, s = t) { return this.minX *= t, this.minY *= s, this.maxX *= t, this.maxY *= s, this } get x() { return this.minX } set x(t) { const s = this.maxX - this.minX; this.minX = t, this.maxX = t + s } get y() { return this.minY } set y(t) { const s = this.maxY - this.minY; this.minY = t, this.maxY = t + s } get width() { return this.maxX - this.minX } set width(t) { this.maxX = this.minX + t } get height() { return this.maxY - this.minY } set height(t) { this.maxY = this.minY + t } get left() { return this.minX } get right() { return this.maxX } get top() { return this.minY } get bottom() { return this.maxY } get isPositive() { return this.maxX - this.minX > 0 && this.maxY - this.minY > 0 } get isValid() { return this.minX + this.minY !== 1 / 0 } addVertexData(t, s, i, e) { let n = this.minX, r = this.minY, o = this.maxX, h = this.maxY; e || (e = this.matrix); const a = e.a, u = e.b, l = e.c, c = e.d, f = e.tx, d = e.ty; for (let p = s; p < i; p += 2) { const s = t[p], i = t[p + 1], e = a * s + l * i + f, m = u * s + c * i + d; n = e < n ? e : n, r = m < r ? m : r, o = e > o ? e : o, h = m > h ? m : h } this.minX = n, this.minY = r, this.maxX = o, this.maxY = h } containsPoint(t, s) { return this.minX <= t && this.minY <= s && this.maxX >= t && this.maxY >= s } toString() { return `[pixi.js:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]` } copyFrom(t) { return this.minX = t.minX, this.minY = t.minY, this.maxX = t.maxX, this.maxY = t.maxY, this } } var st = { grad: .9, turn: 360, rad: 360 / (2 * Math.PI) }, it = function (t) { return "string" == typeof t ? t.length > 0 : "number" == typeof t }, et = function (t, s, i) { return void 0 === s && (s = 0), void 0 === i && (i = Math.pow(10, s)), Math.round(i * t) / i + 0 }, nt = function (t, s, i) { return void 0 === s && (s = 0), void 0 === i && (i = 1), t > i ? i : t > s ? t : s }, rt = function (t) { return (t = isFinite(t) ? t % 360 : 0) > 0 ? t : t + 360 }, ot = function (t) { return { r: nt(t.r, 0, 255), g: nt(t.g, 0, 255), b: nt(t.b, 0, 255), a: nt(t.a) } }, ht = function (t) { return { r: et(t.r), g: et(t.g), b: et(t.b), a: et(t.a, 3) } }, at = /^#([0-9a-f]{3,8})$/i, ut = function (t) { var s = t.toString(16); return s.length < 2 ? "0" + s : s }, lt = function (t) { var s = t.r, i = t.g, e = t.b, n = t.a, r = Math.max(s, i, e), o = r - Math.min(s, i, e), h = o ? r === s ? (i - e) / o : r === i ? 2 + (e - s) / o : 4 + (s - i) / o : 0; return { h: 60 * (h < 0 ? h + 6 : h), s: r ? o / r * 100 : 0, v: r / 255 * 100, a: n } }, ct = function (t) { var s = t.h, i = t.s, e = t.v, n = t.a; s = s / 360 * 6, i /= 100, e /= 100; var r = Math.floor(s), o = e * (1 - i), h = e * (1 - (s - r) * i), a = e * (1 - (1 - s + r) * i), u = r % 6; return { r: 255 * [e, h, o, o, a, e][u], g: 255 * [a, e, e, h, o, o][u], b: 255 * [o, o, a, e, e, h][u], a: n } }, ft = function (t) { return { h: rt(t.h), s: nt(t.s, 0, 100), l: nt(t.l, 0, 100), a: nt(t.a) } }, dt = function (t) { return { h: et(t.h), s: et(t.s), l: et(t.l), a: et(t.a, 3) } }, pt = function (t) { return ct((i = (s = t).s, { h: s.h, s: (i *= ((e = s.l) < 50 ? e : 100 - e) / 100) > 0 ? 2 * i / (e + i) * 100 : 0, v: e + i, a: s.a })); var s, i, e }, mt = function (t) { return { h: (s = lt(t)).h, s: (n = (200 - (i = s.s)) * (e = s.v) / 100) > 0 && n < 200 ? i * e / 100 / (n <= 100 ? n : 200 - n) * 100 : 0, l: n / 2, a: s.a }; var s, i, e, n }, gt = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, vt = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, bt = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, xt = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, yt = { string: [[function (t) { var s = at.exec(t); return s ? (t = s[1]).length <= 4 ? { r: parseInt(t[0] + t[0], 16), g: parseInt(t[1] + t[1], 16), b: parseInt(t[2] + t[2], 16), a: 4 === t.length ? et(parseInt(t[3] + t[3], 16) / 255, 2) : 1 } : 6 === t.length || 8 === t.length ? { r: parseInt(t.substr(0, 2), 16), g: parseInt(t.substr(2, 2), 16), b: parseInt(t.substr(4, 2), 16), a: 8 === t.length ? et(parseInt(t.substr(6, 2), 16) / 255, 2) : 1 } : null : null }, "hex"], [function (t) { var s = bt.exec(t) || xt.exec(t); return s ? s[2] !== s[4] || s[4] !== s[6] ? null : ot({ r: Number(s[1]) / (s[2] ? 100 / 255 : 1), g: Number(s[3]) / (s[4] ? 100 / 255 : 1), b: Number(s[5]) / (s[6] ? 100 / 255 : 1), a: void 0 === s[7] ? 1 : Number(s[7]) / (s[8] ? 100 : 1) }) : null }, "rgb"], [function (t) { var s = gt.exec(t) || vt.exec(t); if (!s) return null; var i, e, n = ft({ h: (i = s[1], e = s[2], void 0 === e && (e = "deg"), Number(i) * (st[e] || 1)), s: Number(s[3]), l: Number(s[4]), a: void 0 === s[5] ? 1 : Number(s[5]) / (s[6] ? 100 : 1) }); return pt(n) }, "hsl"]], object: [[function (t) { var s = t.r, i = t.g, e = t.b, n = t.a, r = void 0 === n ? 1 : n; return it(s) && it(i) && it(e) ? ot({ r: Number(s), g: Number(i), b: Number(e), a: Number(r) }) : null }, "rgb"], [function (t) { var s = t.h, i = t.s, e = t.l, n = t.a, r = void 0 === n ? 1 : n; if (!it(s) || !it(i) || !it(e)) return null; var o = ft({ h: Number(s), s: Number(i), l: Number(e), a: Number(r) }); return pt(o) }, "hsl"], [function (t) { var s = t.h, i = t.s, e = t.v, n = t.a, r = void 0 === n ? 1 : n; if (!it(s) || !it(i) || !it(e)) return null; var o, h = (o = { h: Number(s), s: Number(i), v: Number(e), a: Number(r) }, { h: rt(o.h), s: nt(o.s, 0, 100), v: nt(o.v, 0, 100), a: nt(o.a) }); return ct(h) }, "hsv"]] }, wt = function (t, s) { for (var i = 0; i < s.length; i++) { var e = s[i][0](t); if (e) return [e, s[i][1]] } return [null, void 0] }, Mt = function (t, s) { var i = mt(t); return { h: i.h, s: nt(i.s + 100 * s, 0, 100), l: i.l, a: i.a } }, Tt = function (t) { return (299 * t.r + 587 * t.g + 114 * t.b) / 1e3 / 255 }, At = function (t, s) { var i = mt(t); return { h: i.h, s: i.s, l: nt(i.l + 100 * s, 0, 100), a: i.a } }, Ct = function () { function t(t) { this.parsed = function (t) { return "string" == typeof t ? wt(t.trim(), yt.string) : "object" == typeof t && null !== t ? wt(t, yt.object) : [null, void 0] }(t)[0], this.rgba = this.parsed || { r: 0, g: 0, b: 0, a: 1 } } return t.prototype.isValid = function () { return null !== this.parsed }, t.prototype.brightness = function () { return et(Tt(this.rgba), 2) }, t.prototype.isDark = function () { return Tt(this.rgba) < .5 }, t.prototype.isLight = function () { return Tt(this.rgba) >= .5 }, t.prototype.toHex = function () { return s = (t = ht(this.rgba)).r, i = t.g, e = t.b, r = (n = t.a) < 1 ? ut(et(255 * n)) : "", "#" + ut(s) + ut(i) + ut(e) + r; var t, s, i, e, n, r }, t.prototype.toRgb = function () { return ht(this.rgba) }, t.prototype.toRgbString = function () { return s = (t = ht(this.rgba)).r, i = t.g, e = t.b, (n = t.a) < 1 ? "rgba(" + s + ", " + i + ", " + e + ", " + n + ")" : "rgb(" + s + ", " + i + ", " + e + ")"; var t, s, i, e, n }, t.prototype.toHsl = function () { return dt(mt(this.rgba)) }, t.prototype.toHslString = function () { return s = (t = dt(mt(this.rgba))).h, i = t.s, e = t.l, (n = t.a) < 1 ? "hsla(" + s + ", " + i + "%, " + e + "%, " + n + ")" : "hsl(" + s + ", " + i + "%, " + e + "%)"; var t, s, i, e, n }, t.prototype.toHsv = function () { return t = lt(this.rgba), { h: et(t.h), s: et(t.s), v: et(t.v), a: et(t.a, 3) }; var t }, t.prototype.invert = function () { return _t({ r: 255 - (t = this.rgba).r, g: 255 - t.g, b: 255 - t.b, a: t.a }); var t }, t.prototype.saturate = function (t) { return void 0 === t && (t = .1), _t(Mt(this.rgba, t)) }, t.prototype.desaturate = function (t) { return void 0 === t && (t = .1), _t(Mt(this.rgba, -t)) }, t.prototype.grayscale = function () { return _t(Mt(this.rgba, -1)) }, t.prototype.lighten = function (t) { return void 0 === t && (t = .1), _t(At(this.rgba, t)) }, t.prototype.darken = function (t) { return void 0 === t && (t = .1), _t(At(this.rgba, -t)) }, t.prototype.rotate = function (t) { return void 0 === t && (t = 15), this.hue(this.hue() + t) }, t.prototype.alpha = function (t) { return "number" == typeof t ? _t({ r: (s = this.rgba).r, g: s.g, b: s.b, a: t }) : et(this.rgba.a, 3); var s }, t.prototype.hue = function (t) { var s = mt(this.rgba); return "number" == typeof t ? _t({ h: t, s: s.s, l: s.l, a: s.a }) : et(s.h) }, t.prototype.isEqual = function (t) { return this.toHex() === _t(t).toHex() }, t }(), _t = function (t) { return t instanceof Ct ? t : new Ct(t) }, St = [];[function (t, s) { var i = { white: "#ffffff", bisque: "#ffe4c4", blue: "#0000ff", cadetblue: "#5f9ea0", chartreuse: "#7fff00", chocolate: "#d2691e", coral: "#ff7f50", antiquewhite: "#faebd7", aqua: "#00ffff", azure: "#f0ffff", whitesmoke: "#f5f5f5", papayawhip: "#ffefd5", plum: "#dda0dd", blanchedalmond: "#ffebcd", black: "#000000", gold: "#ffd700", goldenrod: "#daa520", gainsboro: "#dcdcdc", cornsilk: "#fff8dc", cornflowerblue: "#6495ed", burlywood: "#deb887", aquamarine: "#7fffd4", beige: "#f5f5dc", crimson: "#dc143c", cyan: "#00ffff", darkblue: "#00008b", darkcyan: "#008b8b", darkgoldenrod: "#b8860b", darkkhaki: "#bdb76b", darkgray: "#a9a9a9", darkgreen: "#006400", darkgrey: "#a9a9a9", peachpuff: "#ffdab9", darkmagenta: "#8b008b", darkred: "#8b0000", darkorchid: "#9932cc", darkorange: "#ff8c00", darkslateblue: "#483d8b", gray: "#808080", darkslategray: "#2f4f4f", darkslategrey: "#2f4f4f", deeppink: "#ff1493", deepskyblue: "#00bfff", wheat: "#f5deb3", firebrick: "#b22222", floralwhite: "#fffaf0", ghostwhite: "#f8f8ff", darkviolet: "#9400d3", magenta: "#ff00ff", green: "#008000", dodgerblue: "#1e90ff", grey: "#808080", honeydew: "#f0fff0", hotpink: "#ff69b4", blueviolet: "#8a2be2", forestgreen: "#228b22", lawngreen: "#7cfc00", indianred: "#cd5c5c", indigo: "#4b0082", fuchsia: "#ff00ff", brown: "#a52a2a", maroon: "#800000", mediumblue: "#0000cd", lightcoral: "#f08080", darkturquoise: "#00ced1", lightcyan: "#e0ffff", ivory: "#fffff0", lightyellow: "#ffffe0", lightsalmon: "#ffa07a", lightseagreen: "#20b2aa", linen: "#faf0e6", mediumaquamarine: "#66cdaa", lemonchiffon: "#fffacd", lime: "#00ff00", khaki: "#f0e68c", mediumseagreen: "#3cb371", limegreen: "#32cd32", mediumspringgreen: "#00fa9a", lightskyblue: "#87cefa", lightblue: "#add8e6", midnightblue: "#191970", lightpink: "#ffb6c1", mistyrose: "#ffe4e1", moccasin: "#ffe4b5", mintcream: "#f5fffa", lightslategray: "#778899", lightslategrey: "#778899", navajowhite: "#ffdead", navy: "#000080", mediumvioletred: "#c71585", powderblue: "#b0e0e6", palegoldenrod: "#eee8aa", oldlace: "#fdf5e6", paleturquoise: "#afeeee", mediumturquoise: "#48d1cc", mediumorchid: "#ba55d3", rebeccapurple: "#663399", lightsteelblue: "#b0c4de", mediumslateblue: "#7b68ee", thistle: "#d8bfd8", tan: "#d2b48c", orchid: "#da70d6", mediumpurple: "#9370db", purple: "#800080", pink: "#ffc0cb", skyblue: "#87ceeb", springgreen: "#00ff7f", palegreen: "#98fb98", red: "#ff0000", yellow: "#ffff00", slateblue: "#6a5acd", lavenderblush: "#fff0f5", peru: "#cd853f", palevioletred: "#db7093", violet: "#ee82ee", teal: "#008080", slategray: "#708090", slategrey: "#708090", aliceblue: "#f0f8ff", darkseagreen: "#8fbc8f", darkolivegreen: "#556b2f", greenyellow: "#adff2f", seagreen: "#2e8b57", seashell: "#fff5ee", tomato: "#ff6347", silver: "#c0c0c0", sienna: "#a0522d", lavender: "#e6e6fa", lightgreen: "#90ee90", orange: "#ffa500", orangered: "#ff4500", steelblue: "#4682b4", royalblue: "#4169e1", turquoise: "#40e0d0", yellowgreen: "#9acd32", salmon: "#fa8072", saddlebrown: "#8b4513", sandybrown: "#f4a460", rosybrown: "#bc8f8f", darksalmon: "#e9967a", lightgoldenrodyellow: "#fafad2", snow: "#fffafa", lightgrey: "#d3d3d3", lightgray: "#d3d3d3", dimgray: "#696969", dimgrey: "#696969", olivedrab: "#6b8e23", olive: "#808000" }, e = {}; for (var n in i) e[i[n]] = n; var r = {}; t.prototype.toName = function (s) { if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b)) return "transparent"; var n, o, h = e[this.toHex()]; if (h) return h; if (null == s ? void 0 : s.closest) { var a = this.toRgb(), u = 1 / 0, l = "black"; if (!r.length) for (var c in i) r[c] = new t(i[c]).toRgb(); for (var f in i) { var d = (n = a, o = r[f], Math.pow(n.r - o.r, 2) + Math.pow(n.g - o.g, 2) + Math.pow(n.b - o.b, 2)); d < u && (u = d, l = f) } return l } }, s.string.push([function (s) { var e = s.toLowerCase(), n = "transparent" === e ? "#0000" : i[e]; return n ? new t(n).toRgb() : null }, "name"]) }].forEach(function (t) { St.indexOf(t) < 0 && (t(Ct, yt), St.push(t)) }); const Pt = class t { constructor(t = 16777215) { this.tt = null, this.st = new Float32Array(4), this.st.fill(1), this.it = 16777215, this.value = t } get red() { return this.st[0] } get green() { return this.st[1] } get blue() { return this.st[2] } get alpha() { return this.st[3] } setValue(t) { return this.value = t, this } set value(s) { if (s instanceof t) this.tt = this.et(s.tt), this.it = s.it, this.st.set(s.st); else { if (null === s) throw new Error("Cannot set Color#value to null"); null !== this.tt && this.nt(this.tt, s) || (this.tt = this.et(s), this.rt(this.tt)) } } get value() { return this.tt } et(t) { return "string" == typeof t || "number" == typeof t || t instanceof Number || null === t ? t : Array.isArray(t) || ArrayBuffer.isView(t) ? t.slice(0) : "object" == typeof t && null !== t ? { ...t } : t } nt(t, s) { const i = typeof t; if (i !== typeof s) return !1; if ("number" === i || "string" === i || t instanceof Number) return t === s; if (Array.isArray(t) && Array.isArray(s) || ArrayBuffer.isView(t) && ArrayBuffer.isView(s)) return t.length === s.length && t.every((t, i) => t === s[i]); if (null !== t && null !== s) { const i = Object.keys(t), e = Object.keys(s); return i.length === e.length && i.every(i => t[i] === s[i]) } return t === s } toRgba() { const [t, s, i, e] = this.st; return { r: t, g: s, b: i, a: e } } toRgb() { const [t, s, i] = this.st; return { r: t, g: s, b: i } } toRgbaString() { const [t, s, i] = this.toUint8RgbArray(); return `rgba(${t},${s},${i},${this.alpha})` } toUint8RgbArray(t) { const [s, i, e] = this.st; return this.ot || (this.ot = []), t || (t = this.ot), t[0] = Math.round(255 * s), t[1] = Math.round(255 * i), t[2] = Math.round(255 * e), t } toArray(t) { this.ht || (this.ht = []), t || (t = this.ht); const [s, i, e, n] = this.st; return t[0] = s, t[1] = i, t[2] = e, t[3] = n, t } toRgbArray(t) { this.ot || (this.ot = []), t || (t = this.ot); const [s, i, e] = this.st; return t[0] = s, t[1] = i, t[2] = e, t } toNumber() { return this.it } toBgrNumber() { const [t, s, i] = this.toUint8RgbArray(); return (i << 16) + (s << 8) + t } toLittleEndianNumber() { const t = this.it; return (t >> 16) + (65280 & t) + ((255 & t) << 16) } multiply(s) { const [i, e, n, r] = t.ut.setValue(s).st; return this.st[0] *= i, this.st[1] *= e, this.st[2] *= n, this.st[3] *= r, this.lt(), this.tt = null, this } premultiply(t, s = !0) { return s && (this.st[0] *= t, this.st[1] *= t, this.st[2] *= t), this.st[3] = t, this.lt(), this.tt = null, this } toPremultiplied(t, s = !0) { if (1 === t) return (255 << 24) + this.it; if (0 === t) return s ? 0 : this.it; let i = this.it >> 16 & 255, e = this.it >> 8 & 255, n = 255 & this.it; return s && (i = i * t + .5 | 0, e = e * t + .5 | 0, n = n * t + .5 | 0), (255 * t << 24) + (i << 16) + (e << 8) + n } toHex() { const t = this.it.toString(16); return `#${"000000".substring(0, 6 - t.length) + t}` } toHexa() { const t = Math.round(255 * this.st[3]).toString(16); return this.toHex() + "00".substring(0, 2 - t.length) + t } setAlpha(t) { return this.st[3] = this.ct(t), this } rt(s) { let i, e, n, r; if (("number" == typeof s || s instanceof Number) && s >= 0 && s <= 16777215) i = (s >> 16 & 255) / 255, e = (s >> 8 & 255) / 255, n = (255 & s) / 255, r = 1; else if ((Array.isArray(s) || s instanceof Float32Array) && s.length >= 3 && s.length <= 4) s = this.ct(s), [i, e, n, r = 1] = s; else if ((s instanceof Uint8Array || s instanceof Uint8ClampedArray) && s.length >= 3 && s.length <= 4) s = this.ct(s, 0, 255), [i, e, n, r = 255] = s, i /= 255, e /= 255, n /= 255, r /= 255; else if ("string" == typeof s || "object" == typeof s) { if ("string" == typeof s) { const i = t.HEX_PATTERN.exec(s); i && (s = `#${i[2]}`) } const o = _t(s); o.isValid() && (({ r: i, g: e, b: n, a: r } = o.rgba), i /= 255, e /= 255, n /= 255) } if (void 0 === i) throw new Error(`Unable to convert color ${s}`); this.st[0] = i, this.st[1] = e, this.st[2] = n, this.st[3] = r, this.lt() } lt() { this.ct(this.st); const [t, s, i] = this.st; this.it = (255 * t << 16) + (255 * s << 8) + (255 * i | 0) } ct(t, s = 0, i = 1) { return "number" == typeof t ? Math.min(Math.max(t, s), i) : (t.forEach((e, n) => { t[n] = Math.min(Math.max(e, s), i) }), t) } static isColorLike(s) { return "number" == typeof s || "string" == typeof s || s instanceof Number || s instanceof t || Array.isArray(s) || s instanceof Uint8Array || s instanceof Uint8ClampedArray || s instanceof Float32Array || void 0 !== s.r && void 0 !== s.g && void 0 !== s.b || void 0 !== s.r && void 0 !== s.g && void 0 !== s.b && void 0 !== s.a || void 0 !== s.h && void 0 !== s.s && void 0 !== s.l || void 0 !== s.h && void 0 !== s.s && void 0 !== s.l && void 0 !== s.a || void 0 !== s.h && void 0 !== s.s && void 0 !== s.v || void 0 !== s.h && void 0 !== s.s && void 0 !== s.v && void 0 !== s.a } }; Pt.shared = new Pt, Pt.ut = new Pt, Pt.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i; let kt = Pt, Ft = 0; function Et(...t) { 500 !== Ft && Ft++ } const Rt = { ft: new Set, register(t) { this.ft.add(t) }, unregister(t) { this.ft.delete(t) }, release() { this.ft.forEach(t => t.clear()) }, get registeredCount() { return this.ft.size }, isRegistered(t) { return this.ft.has(t) }, reset() { this.ft.clear() } }; class Ot { constructor(t, s) { this.dt = [], this.gt = 0, this.vt = 0, this.bt = t, s && this.prepopulate(s) } prepopulate(t) { for (let s = 0; s < t; s++)this.dt[this.vt++] = new this.bt; this.gt += t } get(t) { let s; return this.vt > 0 ? s = this.dt[--this.vt] : (s = new this.bt, this.gt++), s.init?.(t), s } return(t) { t.reset?.(), this.dt[this.vt++] = t } get totalSize() { return this.gt } get totalFree() { return this.vt } get totalUsed() { return this.gt - this.vt } clear() { if (this.dt.length > 0 && this.dt[0].destroy) for (let t = 0; t < this.vt; t++)this.dt[t].destroy(); this.dt.length = 0, this.gt = 0, this.vt = 0 } } const Ut = new class { constructor() { this.xt = new Map } prepopulate(t, s) { this.getPool(t).prepopulate(s) } get(t, s) { return this.getPool(t).get(s) } return(t) { this.getPool(t.constructor).return(t) } getPool(t) { return this.xt.has(t) || this.xt.set(t, new Ot(t)), this.xt.get(t) } stats() { const t = {}; return this.xt.forEach(s => { const i = t[s.bt.name] ? s.bt.name + s.bt.ID : s.bt.name; t[i] = { free: s.totalFree, used: s.totalUsed, size: s.totalSize } }), t } clear() { this.xt.forEach(t => t.clear()), this.xt.clear() } }; Rt.register(Ut); const It = { get isCachedAsTexture() { return !!this.renderGroup?.isCachedAsTexture }, cacheAsTexture(t) { "boolean" == typeof t && !1 === t ? this.disableRenderGroup() : (this.enableRenderGroup(), this.renderGroup.enableCacheAsTexture(!0 === t ? {} : t)) }, updateCacheTexture() { this.renderGroup?.updateCacheTexture() }, get cacheAsBitmap() { return this.isCachedAsTexture }, set cacheAsBitmap(t) { $(0, "cacheAsBitmap is deprecated, use cacheAsTexture instead."), this.cacheAsTexture(t) } }; function Bt(t, s, i) { const e = t.length; let n; if (s >= e || 0 === i) return; const r = e - (i = s + i > e ? e - s : i); for (n = s; n < r; ++n)t[n] = t[n + i]; t.length = r } const Gt = { allowChildren: !0, removeChildren(t = 0, s) { const i = s ?? this.children.length, e = i - t, n = []; if (e > 0 && e <= i) { for (let e = i - 1; e >= t; e--) { const t = this.children[e]; t && (n.push(t), t.parent = null) } Bt(this.children, t, i); const s = this.renderGroup || this.parentRenderGroup; s && s.removeChildren(n); for (let t = 0; t < n.length; ++t) { const s = n[t]; s.parentRenderLayer?.detach(s), this.emit("childRemoved", s, this, t), n[t].emit("removed", this) } return n.length > 0 && this.yt++, n } if (0 === e && 0 === this.children.length) return n; throw new RangeError("removeChildren: numeric values are outside the acceptable range.") }, removeChildAt(t) { const s = this.getChildAt(t); return this.removeChild(s) }, getChildAt(t) { if (t < 0 || t >= this.children.length) throw new Error(`getChildAt: Index (${t}) does not exist.`); return this.children[t] }, setChildIndex(t, s) { if (s < 0 || s >= this.children.length) throw new Error(`The index ${s} supplied is out of bounds ${this.children.length}`); this.getChildIndex(t), this.addChildAt(t, s) }, getChildIndex(t) { const s = this.children.indexOf(t); if (-1 === s) throw new Error("The supplied Container must be a child of the caller"); return s }, addChildAt(t, s) { this.allowChildren || $(0, "addChildAt: Only Containers will be allowed to add children in v8.0.0"); const { children: i } = this; if (s < 0 || s > i.length) throw new Error(`${t}addChildAt: The index ${s} supplied is out of bounds ${i.length}`); if (t.parent) { const i = t.parent.children.indexOf(t); if (t.parent === this && i === s) return t; -1 !== i && t.parent.children.splice(i, 1) } s === i.length ? i.push(t) : i.splice(s, 0, t), t.parent = this, t.didChange = !0, t.wt = 15; const e = this.renderGroup || this.parentRenderGroup; return e && e.addChild(t), this.sortableChildren && (this.sortDirty = !0), this.emit("childAdded", t, this, s), t.emit("added", this), t }, swapChildren(t, s) { if (t === s) return; const i = this.getChildIndex(t), e = this.getChildIndex(s); this.children[i] = s, this.children[e] = t; const n = this.renderGroup || this.parentRenderGroup; n && (n.structureDidChange = !0), this.Mt++ }, removeFromParent() { this.parent?.removeChild(this) }, reparentChild(...t) { return 1 === t.length ? this.reparentChildAt(t[0], this.children.length) : (t.forEach(t => this.reparentChildAt(t, this.children.length)), t[0]) }, reparentChildAt(t, s) { if (t.parent === this) return this.setChildIndex(t, s), t; const i = t.worldTransform.clone(); t.removeFromParent(), this.addChildAt(t, s); const e = this.worldTransform.clone(); return e.invert(), i.prepend(e), t.setFromMatrix(i), t }, replaceChild(t, s) { t.updateLocalTransform(), this.addChildAt(s, this.getChildIndex(t)), s.setFromMatrix(t.localTransform), s.updateLocalTransform(), this.removeChild(t) } }, $t = { collectRenderables(t, s, i) { this.parentRenderLayer && this.parentRenderLayer !== i || this.globalDisplayStatus < 7 || !this.includeInBuild || (this.sortableChildren && this.sortChildren(), this.isSimple ? this.collectRenderablesSimple(t, s, i) : this.renderGroup ? s.renderPipes.renderGroup.addRenderGroup(this.renderGroup, t) : this.collectRenderablesWithEffects(t, s, i)) }, collectRenderablesSimple(t, s, i) { const e = this.children, n = e.length; for (let r = 0; r < n; r++)e[r].collectRenderables(t, s, i) }, collectRenderablesWithEffects(t, s, i) { const { renderPipes: e } = s; for (let n = 0; n < this.effects.length; n++) { const s = this.effects[n]; e[s.pipe].push(s, this, t) } this.collectRenderablesSimple(t, s, i); for (let n = this.effects.length - 1; n >= 0; n--) { const s = this.effects[n]; e[s.pipe].pop(s, this, t) } } }; class zt { constructor() { this.pipe = "filter", this.priority = 1 } destroy() { for (let t = 0; t < this.filters.length; t++)this.filters[t].destroy(); this.filters = null, this.filterArea = null } } const Dt = new class { constructor() { this.Tt = [], this.At = [], this.Ct = !1 } init() { this.Ct || (this.Ct = !0, this.Tt.forEach(t => { this.add({ test: t.test, maskClass: t }) })) } add(t) { this.At.push(t) } getMaskEffect(t) { this.Ct || this.init(); for (let s = 0; s < this.At.length; s++) { const i = this.At[s]; if (i.test(t)) return Ut.get(i.maskClass, t) } return t } returnMaskEffect(t) { Ut.return(t) } }; a.handleByList(r.MaskEffect, Dt.Tt); const jt = { _t: null, St: { inverse: !1 }, Pt: null, effects: [], kt() { const t = this.renderGroup || this.parentRenderGroup; t && (t.structureDidChange = !0) }, addEffect(t) { -1 === this.effects.indexOf(t) && (this.effects.push(t), this.effects.sort((t, s) => t.priority - s.priority), this.kt(), this.Ft()) }, removeEffect(t) { const s = this.effects.indexOf(t); -1 !== s && (this.effects.splice(s, 1), this.kt(), this.Ft()) }, set mask(t) { const s = this._t; s?.mask !== t && (s && (this.removeEffect(s), Dt.returnMaskEffect(s), this._t = null), null != t && (this._t = Dt.getMaskEffect(t), this.addEffect(this._t))) }, get mask() { return this._t?.mask }, setMask(t) { this.St = { ...this.St, ...t }, t.mask && (this.mask = t.mask), this.kt() }, set filters(t) { !Array.isArray(t) && t && (t = [t]); const s = this.Pt || (this.Pt = new zt), i = t?.length > 0, e = i !== s.filters?.length > 0; t = Array.isArray(t) ? t.slice(0) : t, s.filters = Object.freeze(t), e && (i ? this.addEffect(s) : (this.removeEffect(s), s.filters = t ?? null)) }, get filters() { return this.Pt?.filters }, set filterArea(t) { this.Pt || (this.Pt = new zt), this.Pt.filterArea = t }, get filterArea() { return this.Pt?.filterArea } }, Lt = { label: null, get name() { return $(0, "Container.name property has been removed, use Container.label instead"), this.label }, set name(t) { $(0, "Container.name property has been removed, use Container.label instead"), this.label = t }, getChildByName(t, s = !1) { return this.getChildByLabel(t, s) }, getChildByLabel(t, s = !1) { const i = this.children; for (let e = 0; e < i.length; e++) { const s = i[e]; if (s.label === t || t instanceof RegExp && t.test(s.label)) return s } if (s) for (let e = 0; e < i.length; e++) { const s = i[e].getChildByLabel(t, !0); if (s) return s } return null }, getChildrenByLabel(t, s = !1, i = []) { const e = this.children; for (let n = 0; n < e.length; n++) { const s = e[n]; (s.label === t || t instanceof RegExp && t.test(s.label)) && i.push(s) } if (s) for (let n = 0; n < e.length; n++)e[n].getChildrenByLabel(t, !0, i); return i } }, Vt = Ut.getPool(w), Nt = Ut.getPool(tt), Wt = new w, Ht = { getFastGlobalBounds(t, s) { s || (s = new tt), s.clear(), this.Et(!!t, s, this.parentRenderLayer), s.isValid || s.set(0, 0, 0, 0); const i = this.renderGroup || this.parentRenderGroup; return s.applyMatrix(i.worldTransform), s }, Et(t, s, i) { let e = s; if (t && this.parentRenderLayer && this.parentRenderLayer !== i) return; if (7 !== this.localDisplayStatus || !this.measurable) return; const n = !!this.effects.length; if ((this.renderGroup || n) && (e = Nt.get().clear()), this.boundsArea) s.addRect(this.boundsArea, this.worldTransform); else { if (this.renderPipeId) { const t = this.bounds; e.addFrame(t.minX, t.minY, t.maxX, t.maxY, this.groupTransform) } const s = this.children; for (let n = 0; n < s.length; n++)s[n].Et(t, e, i) } if (n) { let t = !1; const i = this.renderGroup || this.parentRenderGroup; for (let s = 0; s < this.effects.length; s++)this.effects[s].addBounds && (t || (t = !0, e.applyMatrix(i.worldTransform)), this.effects[s].addBounds(e, !0)); t && e.applyMatrix(i.worldTransform.copyTo(Wt).invert()), s.addBounds(e), Nt.return(e) } else this.renderGroup && (s.addBounds(e, this.relativeGroupTransform), Nt.return(e)) } }; function qt(t, s, i) { let e, n; return i.clear(), t.parent ? s ? e = t.parent.worldTransform : (n = Vt.get().identity(), e = Yt(t, n)) : e = w.IDENTITY, Xt(t, i, e, s), n && Vt.return(n), i.isValid || i.set(0, 0, 0, 0), i } function Xt(t, s, i, e) { if (!t.visible || !t.measurable) return; let n; e ? n = t.worldTransform : (t.updateLocalTransform(), n = Vt.get(), n.appendFrom(t.localTransform, i)); const r = s, o = !!t.effects.length; if (o && (s = Nt.get().clear()), t.boundsArea) s.addRect(t.boundsArea, n); else { const i = t.bounds; i && !i.isEmpty() && (s.matrix = n, s.addBounds(i)); for (let r = 0; r < t.children.length; r++)Xt(t.children[r], s, n, e) } if (o) { for (let i = 0; i < t.effects.length; i++)t.effects[i].addBounds?.(s); r.addBounds(s, w.IDENTITY), Nt.return(s) } e || Vt.return(n) } function Yt(t, s) { const i = t.parent; return i && (Yt(i, s), i.updateLocalTransform(), s.append(i.localTransform)), s } function Kt(t, s) { return 16777215 !== t && s ? 16777215 !== s && t ? ((t >> 16 & 255) * (s >> 16 & 255) / 255 << 16) + ((t >> 8 & 255) * (s >> 8 & 255) / 255 << 8) + ((255 & t) * (255 & s) / 255 | 0) : t : s } const Zt = 16777215; function Qt(t, s) { return t === Zt ? s : s === Zt ? t : Kt(t, s) } function Jt(t) { return ((255 & t) << 16) + (65280 & t) + (t >> 16 & 255) } const ts = { getGlobalAlpha(t) { if (t) return this.renderGroup ? this.renderGroup.worldAlpha : this.parentRenderGroup ? this.parentRenderGroup.worldAlpha * this.alpha : this.alpha; let s = this.alpha, i = this.parent; for (; i;)s *= i.alpha, i = i.parent; return s }, getGlobalTransform(t = new w, s) { if (s) return t.copyFrom(this.worldTransform); this.updateLocalTransform(); const i = Yt(this, Vt.get().identity()); return t.appendFrom(this.localTransform, i), Vt.return(i), t }, getGlobalTint(t) { if (t) return this.renderGroup ? Jt(this.renderGroup.worldColor) : this.parentRenderGroup ? Jt(Qt(this.localColor, this.parentRenderGroup.worldColor)) : this.tint; let s = this.localColor, i = this.parent; for (; i;)s = Qt(s, i.localColor), i = i.parent; return Jt(s) } }; function ss(t, s, i) { return s.clear(), i || (i = w.IDENTITY), is(t, s, i, t, !0), s.isValid || s.set(0, 0, 0, 0), s } function is(t, s, i, e, n) { let r; if (n) r = Vt.get(), r = i.copyTo(r); else { if (!t.visible || !t.measurable) return; t.updateLocalTransform(); const s = t.localTransform; r = Vt.get(), r.appendFrom(s, i) } const o = s, h = !!t.effects.length; if (h && (s = Nt.get().clear()), t.boundsArea) s.addRect(t.boundsArea, r); else { t.renderPipeId && (s.matrix = r, s.addBounds(t.bounds)); const i = t.children; for (let t = 0; t < i.length; t++)is(i[t], s, r, e, !1) } if (h) { for (let i = 0; i < t.effects.length; i++)t.effects[i].addLocalBounds?.(s, e); o.addBounds(s, w.IDENTITY), Nt.return(s) } Vt.return(r) } function es(t, s) { const i = t.children; for (let e = 0; e < i.length; e++) { const t = i[e], n = t.uid, r = (65535 & t.yt) << 16 | 65535 & t.Mt, o = s.index; s.data[o] === n && s.data[o + 1] === r || (s.data[s.index] = n, s.data[s.index + 1] = r, s.didChange = !0), s.index = o + 2, t.children.length && es(t, s) } return s.didChange } const ns = new w, rs = { Rt: -1, Ot: null, Ut(t, s) { const i = Math.sign(this.scale.x) || 1; this.scale.x = 0 !== s ? t / s * i : i }, It(t, s) { const i = Math.sign(this.scale.y) || 1; this.scale.y = 0 !== s ? t / s * i : i }, getLocalBounds() { this.Ot || (this.Ot = { data: [], index: 1, didChange: !1, localBounds: new tt }); const t = this.Ot; return t.index = 1, t.didChange = !1, t.data[0] !== this.yt && (t.didChange = !0, t.data[0] = this.yt), es(this, t), t.didChange && ss(this, t.localBounds, ns), t.localBounds }, getBounds(t, s) { return qt(this, t, s || new tt) } }, os = { Bt: null, set onRender(t) { const s = this.renderGroup || this.parentRenderGroup; if (!t) return this.Bt && s?.removeOnRender(this), void (this.Bt = null); this.Bt || s?.addOnRender(this), this.Bt = t }, get onRender() { return this.Bt } }, hs = { Gt: 0, sortDirty: !1, sortableChildren: !1, get zIndex() { return this.Gt }, set zIndex(t) { this.Gt !== t && (this.Gt = t, this.depthOfChildModified()) }, depthOfChildModified() { this.parent && (this.parent.sortableChildren = !0, this.parent.sortDirty = !0), this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0) }, sortChildren() { this.sortDirty && (this.sortDirty = !1, this.children.sort(as)) } }; function as(t, s) { return t.Gt - s.Gt } const us = { getGlobalPosition(t = new x, s = !1) { return this.parent ? this.parent.toGlobal(this.$t, t, s) : (t.x = this.$t.x, t.y = this.$t.y), t }, toGlobal(t, s, i = !1) { const e = this.getGlobalTransform(Vt.get(), i); return s = e.apply(t, s), Vt.return(e), s }, toLocal(t, s, i, e) { s && (t = s.toGlobal(t, i, e)); const n = this.getGlobalTransform(Vt.get(), e); return i = n.applyInverse(t, i), Vt.return(n), i } }; class ls { constructor() { this.uid = I("instructionSet"), this.instructions = [], this.instructionSize = 0, this.renderables = [], this.gcTick = 0 } reset() { this.instructionSize = 0 } destroy() { this.instructions.length = 0, this.renderables.length = 0, this.renderPipes = null, this.gcTick = 0 } add(t) { this.instructions[this.instructionSize++] = t } log() { this.instructions.length = this.instructionSize } } let cs = 0; const fs = new class { constructor(t) { this.zt = Object.create(null), this.Dt = {}, this.textureOptions = t || {}, this.enableFullScreen = !1, this.textureStyle = new W(this.textureOptions) } createTexture(t, s, i) { const e = new q({ ...this.textureOptions, width: t, height: s, resolution: 1, antialias: i, autoGarbageCollect: !1 }); return new Z({ source: e, label: "texturePool_" + cs++ }) } getOptimalTexture(t, s, i = 1, e) { let n = Math.ceil(t * i - 1e-6), r = Math.ceil(s * i - 1e-6); n = D(n), r = D(r); const o = (n << 17) + (r << 1) + (e ? 1 : 0); this.Dt[o] || (this.Dt[o] = []); let h = this.Dt[o].pop(); return h || (h = this.createTexture(n, r, e)), h.source.G = i, h.source.width = n / i, h.source.height = r / i, h.source.pixelWidth = n, h.source.pixelHeight = r, h.frame.x = 0, h.frame.y = 0, h.frame.width = t, h.frame.height = s, h.updateUvs(), this.zt[h.uid] = o, h } getSameSizeTexture(t, s = !1) { const i = t.source; return this.getOptimalTexture(t.width, t.height, i.G, s) } returnTexture(t, s = !1) { const i = this.zt[t.uid]; s && (t.source.style = this.textureStyle), this.Dt[i].push(t) } clear(t) { if (t = !1 !== t) for (const s in this.Dt) { const t = this.Dt[s]; if (t) for (let s = 0; s < t.length; s++)t[s].destroy(!0) } this.Dt = {} } }; Rt.register(fs); class ds { constructor() { this.renderPipeId = "renderGroup", this.root = null, this.canBundle = !1, this.renderGroupParent = null, this.renderGroupChildren = [], this.worldTransform = new w, this.worldColorAlpha = 4294967295, this.worldColor = 16777215, this.worldAlpha = 1, this.childrenToUpdate = Object.create(null), this.updateTick = 0, this.gcTick = 0, this.childrenRenderablesToUpdate = { list: [], index: 0 }, this.structureDidChange = !0, this.instructionSet = new ls, this.jt = [], this.textureNeedsUpdate = !0, this.isCachedAsTexture = !1, this.Lt = 7 } init(t) { this.root = t, t.Bt && this.addOnRender(t), t.didChange = !0; const s = t.children; for (let i = 0; i < s.length; i++) { const t = s[i]; t.wt = 15, this.addChild(t) } } enableCacheAsTexture(t = {}) { this.textureOptions = t, this.isCachedAsTexture = !0, this.textureNeedsUpdate = !0 } disableCacheAsTexture() { this.isCachedAsTexture = !1, this.texture && (fs.returnTexture(this.texture, !0), this.texture = null) } updateCacheTexture() { this.textureNeedsUpdate = !0; const t = this.Vt; t && !t.textureNeedsUpdate && t.updateCacheTexture() } reset() { this.renderGroupChildren.length = 0; for (const t in this.childrenToUpdate) { const s = this.childrenToUpdate[t]; s.list.fill(null), s.index = 0 } this.childrenRenderablesToUpdate.index = 0, this.childrenRenderablesToUpdate.list.fill(null), this.root = null, this.updateTick = 0, this.structureDidChange = !0, this.jt.length = 0, this.renderGroupParent = null, this.disableCacheAsTexture() } get localTransform() { return this.root.localTransform } addRenderGroupChild(t) { t.renderGroupParent && t.renderGroupParent.Nt(t), t.renderGroupParent = this, this.renderGroupChildren.push(t) } Nt(t) { const s = this.renderGroupChildren.indexOf(t); s > -1 && this.renderGroupChildren.splice(s, 1), t.renderGroupParent = null } addChild(t) { if (this.structureDidChange = !0, t.parentRenderGroup = this, t.updateTick = -1, t.parent === this.root ? t.relativeRenderGroupDepth = 1 : t.relativeRenderGroupDepth = t.parent.relativeRenderGroupDepth + 1, t.didChange = !0, this.onChildUpdate(t), t.renderGroup) return void this.addRenderGroupChild(t.renderGroup); t.Bt && this.addOnRender(t); const s = t.children; for (let i = 0; i < s.length; i++)this.addChild(s[i]) } removeChild(t) { if (this.structureDidChange = !0, t.Bt && (t.renderGroup || this.removeOnRender(t)), t.parentRenderGroup = null, t.renderGroup) return void this.Nt(t.renderGroup); const s = t.children; for (let i = 0; i < s.length; i++)this.removeChild(s[i]) } removeChildren(t) { for (let s = 0; s < t.length; s++)this.removeChild(t[s]) } onChildUpdate(t) { let s = this.childrenToUpdate[t.relativeRenderGroupDepth]; s || (s = this.childrenToUpdate[t.relativeRenderGroupDepth] = { index: 0, list: [] }), s.list[s.index++] = t } updateRenderable(t) { t.globalDisplayStatus < 7 || (this.instructionSet.renderPipes[t.renderPipeId].updateRenderable(t), t.didViewUpdate = !1) } onChildViewUpdate(t) { this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = t } get isRenderable() { return 7 === this.root.localDisplayStatus && this.worldAlpha > 0 } addOnRender(t) { this.jt.push(t) } removeOnRender(t) { this.jt.splice(this.jt.indexOf(t), 1) } runOnRender(t) { for (let s = 0; s < this.jt.length; s++)this.jt[s].Bt(t) } destroy() { this.disableCacheAsTexture(), this.renderGroupParent = null, this.root = null, this.childrenRenderablesToUpdate = null, this.childrenToUpdate = null, this.renderGroupChildren = null, this.jt = null, this.instructionSet = null } getChildren(t = []) { const s = this.root.children; for (let i = 0; i < s.length; i++)this.Wt(s[i], t); return t } Wt(t, s = []) { if (s.push(t), t.renderGroup) return s; const i = t.children; for (let e = 0; e < i.length; e++)this.Wt(i[e], s); return s } invalidateMatrices() { this.Lt = 7 } get inverseWorldTransform() { return 1 & this.Lt ? (this.Lt &= -2, this.Ht || (this.Ht = new w), this.Ht.copyFrom(this.worldTransform).invert()) : this.Ht } get textureOffsetInverseTransform() { return 2 & this.Lt ? (this.Lt &= -3, this.qt || (this.qt = new w), this.qt.copyFrom(this.inverseWorldTransform).translate(-this.Xt.x, -this.Xt.y)) : this.qt } get inverseParentTextureTransform() { if (!(4 & this.Lt)) return this.Yt; this.Lt &= -5; const t = this.Vt; return t ? (this.Yt || (this.Yt = new w), this.Yt.copyFrom(this.worldTransform).prepend(t.inverseWorldTransform).translate(-t.Xt.x, -t.Xt.y)) : this.worldTransform } get cacheToLocalTransform() { return this.isCachedAsTexture ? this.textureOffsetInverseTransform : this.Vt ? this.Vt.textureOffsetInverseTransform : null } } const ps = new c(null), ms = new c(null), gs = new c(null, 1, 1), vs = new c(null); class bs extends m { constructor(t = {}) { super(), this.uid = I("renderable"), this.wt = 15, this.renderGroup = null, this.parentRenderGroup = null, this.parentRenderGroupIndex = 0, this.didChange = !1, this.didViewUpdate = !1, this.relativeRenderGroupDepth = 0, this.children = [], this.parent = null, this.includeInBuild = !0, this.measurable = !0, this.isSimple = !0, this.parentRenderLayer = null, this.updateTick = -1, this.localTransform = new w, this.relativeGroupTransform = new w, this.groupTransform = this.relativeGroupTransform, this.destroyed = !1, this.$t = new c(this, 0, 0), this.Kt = gs, this.Zt = ms, this.Qt = vs, this.Jt = ps, this.ts = 1, this.ss = 0, this.es = 0, this.ns = 1, this.rs = 0, this.localColor = 16777215, this.localAlpha = 1, this.groupAlpha = 1, this.groupColor = 16777215, this.groupColorAlpha = 4294967295, this.localBlendMode = "inherit", this.groupBlendMode = "normal", this.localDisplayStatus = 7, this.globalDisplayStatus = 7, this.Mt = 0, this.yt = 0, this.hs = -1, this.effects = [], function (t, s, i = {}) { for (const e in s) i[e] || void 0 === s[e] || (t[e] = s[e]) }(this, t, { children: !0, parent: !0, effects: !0 }), t.children?.forEach(t => this.addChild(t)), t.parent?.addChild(this) } static mixin(t) { $(0, "Container.mixin is deprecated, please use extensions.mixin instead."), a.mixin(bs, t) } set us(t) { this.yt = t >> 12 & 4095, this.Mt = 4095 & t } get us() { return 4095 & this.Mt | (4095 & this.yt) << 12 } addChild(...t) { if (this.allowChildren || $(0, "addChild: Only Containers will be allowed to add children in v8.0.0"), t.length > 1) { for (let s = 0; s < t.length; s++)this.addChild(t[s]); return t[0] } const s = t[0], i = this.renderGroup || this.parentRenderGroup; return s.parent === this ? (this.children.splice(this.children.indexOf(s), 1), this.children.push(s), i && (i.structureDidChange = !0), s) : (s.parent && s.parent.removeChild(s), this.children.push(s), this.sortableChildren && (this.sortDirty = !0), s.parent = this, s.didChange = !0, s.wt = 15, i && i.addChild(s), this.emit("childAdded", s, this, this.children.length - 1), s.emit("added", this), this.yt++, 0 !== s.Gt && s.depthOfChildModified(), s) } removeChild(...t) { if (t.length > 1) { for (let s = 0; s < t.length; s++)this.removeChild(t[s]); return t[0] } const s = t[0], i = this.children.indexOf(s); return i > -1 && (this.yt++, this.children.splice(i, 1), this.renderGroup ? this.renderGroup.removeChild(s) : this.parentRenderGroup && this.parentRenderGroup.removeChild(s), s.parentRenderLayer && s.parentRenderLayer.detach(s), s.parent = null, this.emit("childRemoved", s, this, i), s.emit("removed", this)), s } C(t) { t && t === this.Jt && this.ls(), this.Mt++, this.didChange || (this.didChange = !0, this.parentRenderGroup && this.parentRenderGroup.onChildUpdate(this)) } set isRenderGroup(t) { !!this.renderGroup !== t && (t ? this.enableRenderGroup() : this.disableRenderGroup()) } get isRenderGroup() { return !!this.renderGroup } enableRenderGroup() { if (this.renderGroup) return; const t = this.parentRenderGroup; t?.removeChild(this), this.renderGroup = Ut.get(ds, this), this.groupTransform = w.IDENTITY, t?.addChild(this), this.Ft() } disableRenderGroup() { if (!this.renderGroup) return; const t = this.parentRenderGroup; t?.removeChild(this), Ut.return(this.renderGroup), this.renderGroup = null, this.groupTransform = this.relativeGroupTransform, t?.addChild(this), this.Ft() } Ft() { this.isSimple = !this.renderGroup && 0 === this.effects.length } get worldTransform() { return this.cs || (this.cs = new w), this.renderGroup ? this.cs.copyFrom(this.renderGroup.worldTransform) : this.parentRenderGroup && this.cs.appendFrom(this.relativeGroupTransform, this.parentRenderGroup.worldTransform), this.cs } get x() { return this.$t.x } set x(t) { this.$t.x = t } get y() { return this.$t.y } set y(t) { this.$t.y = t } get position() { return this.$t } set position(t) { this.$t.copyFrom(t) } get rotation() { return this.rs } set rotation(t) { this.rs !== t && (this.rs = t, this.C(this.Jt)) } get angle() { return this.rotation * v } set angle(t) { this.rotation = t * b } get pivot() { return this.Zt === ms && (this.Zt = new c(this, 0, 0)), this.Zt } set pivot(t) { this.Zt === ms && (this.Zt = new c(this, 0, 0), this.Qt !== vs && Et()), "number" == typeof t ? this.Zt.set(t) : this.Zt.copyFrom(t) } get skew() { return this.Jt === ps && (this.Jt = new c(this, 0, 0)), this.Jt } set skew(t) { this.Jt === ps && (this.Jt = new c(this, 0, 0)), this.Jt.copyFrom(t) } get scale() { return this.Kt === gs && (this.Kt = new c(this, 1, 1)), this.Kt } set scale(t) { this.Kt === gs && (this.Kt = new c(this, 0, 0)), "string" == typeof t && (t = parseFloat(t)), "number" == typeof t ? this.Kt.set(t) : this.Kt.copyFrom(t) } get origin() { return this.Qt === vs && (this.Qt = new c(this, 0, 0)), this.Qt } set origin(t) { this.Qt === vs && (this.Qt = new c(this, 0, 0), this.Zt !== ms && Et()), "number" == typeof t ? this.Qt.set(t) : this.Qt.copyFrom(t) } get width() { return Math.abs(this.scale.x * this.getLocalBounds().width) } set width(t) { const s = this.getLocalBounds().width; this.Ut(t, s) } get height() { return Math.abs(this.scale.y * this.getLocalBounds().height) } set height(t) { const s = this.getLocalBounds().height; this.It(t, s) } getSize(t) { t || (t = {}); const s = this.getLocalBounds(); return t.width = Math.abs(this.scale.x * s.width), t.height = Math.abs(this.scale.y * s.height), t } setSize(t, s) { const i = this.getLocalBounds(); "object" == typeof t ? (s = t.height ?? t.width, t = t.width) : s ?? (s = t), void 0 !== t && this.Ut(t, i.width), void 0 !== s && this.It(s, i.height) } ls() { const t = this.rs, s = this.Jt; this.ts = Math.cos(t + s.T), this.ss = Math.sin(t + s.T), this.es = -Math.sin(t - s.M), this.ns = Math.cos(t - s.M) } updateTransform(t) { return this.position.set("number" == typeof t.x ? t.x : this.position.x, "number" == typeof t.y ? t.y : this.position.y), this.scale.set("number" == typeof t.scaleX ? t.scaleX || 1 : this.scale.x, "number" == typeof t.scaleY ? t.scaleY || 1 : this.scale.y), this.rotation = "number" == typeof t.rotation ? t.rotation : this.rotation, this.skew.set("number" == typeof t.skewX ? t.skewX : this.skew.x, "number" == typeof t.skewY ? t.skewY : this.skew.y), this.pivot.set("number" == typeof t.pivotX ? t.pivotX : this.pivot.x, "number" == typeof t.pivotY ? t.pivotY : this.pivot.y), this.origin.set("number" == typeof t.originX ? t.originX : this.origin.x, "number" == typeof t.originY ? t.originY : this.origin.y), this } setFromMatrix(t) { t.decompose(this) } updateLocalTransform() { const t = this.Mt; if (this.hs === t) return; this.hs = t; const s = this.localTransform, i = this.Kt, e = this.Zt, n = this.Qt, r = this.$t, o = i.M, h = i.T, a = e.M, u = e.T, l = -n.M, c = -n.T; s.a = this.ts * o, s.b = this.ss * o, s.c = this.es * h, s.d = this.ns * h, s.tx = r.M - (a * s.a + u * s.c) + (l * s.a + c * s.c) - l, s.ty = r.T - (a * s.b + u * s.d) + (l * s.b + c * s.d) - c } set alpha(t) { t !== this.localAlpha && (this.localAlpha = t, this.wt |= 1, this.C()) } get alpha() { return this.localAlpha } set tint(t) { const s = kt.shared.setValue(t ?? 16777215).toBgrNumber(); s !== this.localColor && (this.localColor = s, this.wt |= 1, this.C()) } get tint() { return Jt(this.localColor) } set blendMode(t) { this.localBlendMode !== t && (this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0), this.wt |= 2, this.localBlendMode = t, this.C()) } get blendMode() { return this.localBlendMode } get visible() { return !!(2 & this.localDisplayStatus) } set visible(t) { const s = t ? 2 : 0; (2 & this.localDisplayStatus) !== s && (this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0), this.wt |= 4, this.localDisplayStatus ^= 2, this.C()) } get culled() { return !(4 & this.localDisplayStatus) } set culled(t) { const s = t ? 0 : 4; (4 & this.localDisplayStatus) !== s && (this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0), this.wt |= 4, this.localDisplayStatus ^= 4, this.C()) } get renderable() { return !!(1 & this.localDisplayStatus) } set renderable(t) { const s = t ? 1 : 0; (1 & this.localDisplayStatus) !== s && (this.wt |= 4, this.localDisplayStatus ^= 1, this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0), this.C()) } get isRenderable() { return 7 === this.localDisplayStatus && this.groupAlpha > 0 } destroy(t = !1) { if (this.destroyed) return; let s; if (this.destroyed = !0, this.children.length && (s = this.removeChildren(0, this.children.length)), this.removeFromParent(), this.parent = null, this._t = null, this.Pt = null, this.effects = null, this.$t = null, this.Kt = null, this.Zt = null, this.Qt = null, this.Jt = null, this.emit("destroyed", this), this.removeAllListeners(), ("boolean" == typeof t ? t : t?.children) && s) for (let i = 0; i < s.length; ++i)s[i].destroy(t); this.renderGroup?.destroy(), this.renderGroup = null } } a.mixin(bs, Gt, Ht, us, os, rs, jt, Lt, hs, { cullArea: null, cullable: !1, cullableChildren: !0 }, It, ts, $t); class xs extends bs { constructor(t) { super(t), this.canBundle = !0, this.allowChildren = !1, this.fs = 0, this.ds = -1, this.ps = Object.create(null), this.gs = new tt(0, 1, 0, 0), this.vs = !0 } get bounds() { return this.vs ? (this.updateBounds(), this.vs = !1, this.gs) : this.gs } get roundPixels() { return !!this.fs } set roundPixels(t) { this.fs = t ? 1 : 0 } containsPoint(t) { const s = this.bounds, { x: i, y: e } = t; return i >= s.minX && i <= s.maxX && e >= s.minY && e <= s.maxY } onViewUpdate() { if (this.yt++, this.vs = !0, this.didViewUpdate) return; this.didViewUpdate = !0; const t = this.renderGroup || this.parentRenderGroup; t && t.onChildViewUpdate(this) } destroy(t) { super.destroy(t), this.gs = null; for (const s in this.ps) this.ps[s].destroy?.(); this.ps = null } collectRenderablesSimple(t, s, i) { const { renderPipes: e } = s; e.blendMode.pushBlendMode(this, this.groupBlendMode, t), e[this.renderPipeId].addRenderable(this, t), this.didViewUpdate = !1; const n = this.children, r = n.length; for (let o = 0; o < r; o++)n[o].collectRenderables(t, s, i); e.blendMode.popBlendMode(t) } } class ys extends xs { constructor(t = Z.EMPTY) { t instanceof Z && (t = { texture: t }); const { texture: s = Z.EMPTY, anchor: i, roundPixels: e, width: n, height: r, ...o } = t; super({ label: "Sprite", ...o }), this.renderPipeId = "sprite", this.batched = !0, this.bs = { minX: 0, maxX: 1, minY: 0, maxY: 0 }, this.xs = new c({ C: () => { this.onViewUpdate() } }), i ? this.anchor = i : s.defaultAnchor && (this.anchor = s.defaultAnchor), this.texture = s, this.allowChildren = !1, this.roundPixels = e ?? !1, void 0 !== n && (this.width = n), void 0 !== r && (this.height = r) } static from(t, s = !1) { return new ys(t instanceof Z ? t : Z.from(t, s)) } set texture(t) { t || (t = Z.EMPTY); const s = this.Y; s !== t && (s && s.dynamic && s.off("update", this.onViewUpdate, this), t.dynamic && t.on("update", this.onViewUpdate, this), this.Y = t, this.ys && this.Ut(this.ys, this.Y.orig.width), this.ws && this.It(this.ws, this.Y.orig.height), this.onViewUpdate()) } get texture() { return this.Y } get visualBounds() { return Q(this.bs, this.xs, this.Y), this.bs } get sourceBounds() { return $(0, "Sprite.sourceBounds is deprecated, use visualBounds instead."), this.visualBounds } updateBounds() { const t = this.xs, s = this.Y, i = this.gs, { width: e, height: n } = s.orig; i.minX = -t.M * e, i.maxX = i.minX + e, i.minY = -t.T * n, i.maxY = i.minY + n } destroy(t = !1) { if (super.destroy(t), "boolean" == typeof t ? t : t?.texture) { const s = "boolean" == typeof t ? t : t?.textureSource; this.Y.destroy(s) } this.Y = null, this.bs = null, this.gs = null, this.xs = null, this.ps = null } get anchor() { return this.xs } set anchor(t) { "number" == typeof t ? this.xs.set(t) : this.xs.copyFrom(t) } get width() { return Math.abs(this.scale.x) * this.Y.orig.width } set width(t) { this.Ut(t, this.Y.orig.width), this.ys = t } get height() { return Math.abs(this.scale.y) * this.Y.orig.height } set height(t) { this.It(t, this.Y.orig.height), this.ws = t } getSize(t) { return t || (t = {}), t.width = Math.abs(this.scale.x) * this.Y.orig.width, t.height = Math.abs(this.scale.y) * this.Y.orig.height, t } setSize(t, s) { "object" == typeof t ? (s = t.height ?? t.width, t = t.width) : s ?? (s = t), void 0 !== t && this.Ut(t, this.Y.orig.width), void 0 !== s && this.It(s, this.Y.orig.height) } } const ws = new tt; function Ms(t, s, i) { const e = ws; t.measurable = !0, qt(t, i, e), s.addBoundsMask(e), t.measurable = !1 } function Ts(t, s, i) { const e = Nt.get(); t.measurable = !0; const n = Vt.get().identity(); ss(t, e, As(t, i, n)), t.measurable = !1, s.addBoundsMask(e), Vt.return(n), Nt.return(e) } function As(t, s, i) { return t ? (t !== s && (As(t.parent, s, i), t.updateLocalTransform(), i.append(t.localTransform)), i) : (Et(), i) } class Cs { constructor(t) { this.priority = 0, this.inverse = !1, this.pipe = "alphaMask", t?.mask && this.init(t.mask) } init(t) { this.mask = t, this.renderMaskToTexture = !(t instanceof ys), this.mask.renderable = this.renderMaskToTexture, this.mask.includeInBuild = !this.renderMaskToTexture, this.mask.measurable = !1 } reset() { null !== this.mask && (this.mask.measurable = !0, this.mask = null) } addBounds(t, s) { this.inverse || Ms(this.mask, t, s) } addLocalBounds(t, s) { Ts(this.mask, t, s) } containsPoint(t, s) { return s(this.mask, t) } destroy() { this.reset() } static test(t) { return t instanceof ys } } Cs.extension = r.MaskEffect; class _s { constructor(t) { this.priority = 0, this.pipe = "colorMask", t?.mask && this.init(t.mask) } init(t) { this.mask = t } destroy() { } static test(t) { return "number" == typeof t } } _s.extension = r.MaskEffect; class Ss { constructor(t) { this.priority = 0, this.pipe = "stencilMask", t?.mask && this.init(t.mask) } init(t) { this.mask = t, this.mask.includeInBuild = !1, this.mask.measurable = !1 } reset() { null !== this.mask && (this.mask.measurable = !0, this.mask.includeInBuild = !0, this.mask = null) } addBounds(t, s) { Ms(this.mask, t, s) } addLocalBounds(t, s) { Ts(this.mask, t, s) } containsPoint(t, s) { return s(this.mask, t) } destroy() { this.reset() } static test(t) { return t instanceof bs } } Ss.extension = r.MaskEffect; let Ps = { createCanvas: (t, s) => { const i = document.createElement("canvas"); return i.width = t, i.height = s, i }, createImage: () => new Image, getCanvasRenderingContext2D: () => CanvasRenderingContext2D, getWebGLRenderingContext: () => WebGLRenderingContext, getNavigator: () => navigator, getBaseUrl: () => document.baseURI ?? window.location.href, getFontFaceSet: () => document.fonts, fetch: (t, s) => fetch(t, s), parseXML: t => (new DOMParser).parseFromString(t, "text/xml") }; const ks = { get: () => Ps, set(t) { Ps = t } }; class Fs extends q { constructor(t) { t.resource || (t.resource = ks.get().createCanvas()), t.width || (t.width = t.resource.width, t.autoDensity || (t.width /= t.resolution)), t.height || (t.height = t.resource.height, t.autoDensity || (t.height /= t.resolution)), super(t), this.uploadMethodId = "image", this.autoDensity = t.autoDensity, this.resizeCanvas(), this.transparent = !!t.transparent } resizeCanvas() { this.autoDensity && "style" in this.resource && (this.resource.style.width = `${this.width}px`, this.resource.style.height = `${this.height}px`), this.resource.width === this.pixelWidth && this.resource.height === this.pixelHeight || (this.resource.width = this.pixelWidth, this.resource.height = this.pixelHeight) } resize(t = this.width, s = this.height, i = this.G) { const e = super.resize(t, s, i); return e && this.resizeCanvas(), e } static test(t) { return globalThis.HTMLCanvasElement && t instanceof HTMLCanvasElement || globalThis.OffscreenCanvas && t instanceof OffscreenCanvas } get context2D() { return this.Ms || (this.Ms = this.resource.getContext("2d")) } } Fs.extension = r.TextureSource; class Es extends q { constructor(t) { super(t), this.uploadMethodId = "image", this.autoGarbageCollect = !0 } static test(t) { return globalThis.HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap || globalThis.VideoFrame && t instanceof VideoFrame } } Es.extension = r.TextureSource; var Rs = (t => (t[t.INTERACTION = 50] = "INTERACTION", t[t.HIGH = 25] = "HIGH", t[t.NORMAL = 0] = "NORMAL", t[t.LOW = -25] = "LOW", t[t.UTILITY = -50] = "UTILITY", t))(Rs || {}); class Os { constructor(t, s = null, i = 0, e = !1) { this.next = null, this.previous = null, this.Ts = !1, this.As = t, this.Cs = s, this.priority = i, this._s = e } match(t, s = null) { return this.As === t && this.Cs === s } emit(t) { this.As && (this.Cs ? this.As.call(this.Cs, t) : this.As(t)); const s = this.next; return this._s && this.destroy(!0), this.Ts && (this.next = null), s } connect(t) { this.previous = t, t.next && (t.next.previous = this), this.next = t.next, t.next = this } destroy(t = !1) { this.Ts = !0, this.As = null, this.Cs = null, this.previous && (this.previous.next = this.next), this.next && (this.next.previous = this.previous); const s = this.next; return this.next = t ? null : s, this.previous = null, s } } const Us = class t { constructor() { this.autoStart = !1, this.deltaTime = 1, this.lastTime = -1, this.speed = 1, this.started = !1, this.Ss = null, this.Ps = 100, this.ks = 0, this.Fs = !1, this.Es = -1, this.Rs = new Os(null, null, 1 / 0), this.deltaMS = 1 / t.targetFPMS, this.elapsedMS = 1 / t.targetFPMS, this.Os = t => { this.Ss = null, this.started && (this.update(t), this.started && null === this.Ss && this.Rs.next && (this.Ss = requestAnimationFrame(this.Os))) } } Us() { null === this.Ss && this.Rs.next && (this.lastTime = performance.now(), this.Es = this.lastTime, this.Ss = requestAnimationFrame(this.Os)) } Is() { null !== this.Ss && (cancelAnimationFrame(this.Ss), this.Ss = null) } Bs() { this.started ? this.Us() : this.autoStart && this.start() } add(t, s, i = Rs.NORMAL) { return this.Gs(new Os(t, s, i)) } addOnce(t, s, i = Rs.NORMAL) { return this.Gs(new Os(t, s, i, !0)) } Gs(t) { let s = this.Rs.next, i = this.Rs; if (s) { for (; s;) { if (t.priority > s.priority) { t.connect(i); break } i = s, s = s.next } t.previous || t.connect(i) } else t.connect(i); return this.Bs(), this } remove(t, s) { let i = this.Rs.next; for (; i;)i = i.match(t, s) ? i.destroy() : i.next; return this.Rs.next || this.Is(), this } get count() { if (!this.Rs) return 0; let t = 0, s = this.Rs; for (; s = s.next;)t++; return t } start() { this.started || (this.started = !0, this.Us()) } stop() { this.started && (this.started = !1, this.Is()) } destroy() { if (!this.Fs) { this.stop(); let t = this.Rs.next; for (; t;)t = t.destroy(!0); this.Rs.destroy(), this.Rs = null } } update(s = performance.now()) { let i; if (s > this.lastTime) { if (i = this.elapsedMS = s - this.lastTime, i > this.Ps && (i = this.Ps), i *= this.speed, this.ks) { const t = s - this.Es | 0; if (t < this.ks) return; this.Es = s - t % this.ks } this.deltaMS = i, this.deltaTime = this.deltaMS * t.targetFPMS; const e = this.Rs; let n = e.next; for (; n;)n = n.emit(this); e.next || this.Is() } else this.deltaTime = this.deltaMS = this.elapsedMS = 0; this.lastTime = s } get FPS() { return 1e3 / this.elapsedMS } get minFPS() { return 1e3 / this.Ps } set minFPS(s) { const i = Math.min(this.maxFPS, s), e = Math.min(Math.max(0, i) / 1e3, t.targetFPMS); this.Ps = 1 / e } get maxFPS() { return this.ks ? Math.round(1e3 / this.ks) : 0 } set maxFPS(t) { if (0 === t) this.ks = 0; else { const s = Math.max(this.minFPS, t); this.ks = 1 / (s / 1e3) } } static get shared() { if (!t.$s) { const s = t.$s = new t; s.autoStart = !0, s.Fs = !0 } return t.$s } static get system() { if (!t.zs) { const s = t.zs = new t; s.autoStart = !0, s.Fs = !0 } return t.zs } }; Us.targetFPMS = .06; let Is, Bs = Us; const Gs = class t extends q { constructor(s) { super(s), this.isReady = !1, this.uploadMethodId = "video", s = { ...t.defaultOptions, ...s }, this.Ds = !0, this.js = !1, this.Ls = s.updateFPS || 0, this.Vs = 0, this.autoPlay = !1 !== s.autoPlay, this.alphaMode = s.alphaMode ?? "premultiply-alpha-on-upload", this.Ns = this.Ns.bind(this), this.Ws = null, this.Hs = null, this.qs = null, this.Xs = null, this.Ys = this.Ys.bind(this), this.Ks = this.Ks.bind(this), this.Zs = this.Zs.bind(this), this.Qs = this.Qs.bind(this), this.Js = this.Js.bind(this), this.ti = this.ti.bind(this), !1 !== s.autoLoad && this.load() } updateFrame() { if (!this.destroyed) { if (this.Ls) { const t = Bs.shared.elapsedMS * this.resource.playbackRate; this.Vs = Math.floor(this.Vs - t) } (!this.Ls || this.Vs <= 0) && (this.Vs = this.Ls ? Math.floor(1e3 / this.Ls) : 0), this.isValid && this.update() } } Ns() { this.updateFrame(), this.destroyed ? this.Ws = null : this.Ws = this.resource.requestVideoFrameCallback(this.Ns) } get isValid() { return !!this.resource.videoWidth && !!this.resource.videoHeight } async load() { if (this.Hs) return this.Hs; const t = this.resource, s = this.options; return (t.readyState === t.HAVE_ENOUGH_DATA || t.readyState === t.HAVE_FUTURE_DATA) && t.width && t.height && (t.complete = !0), t.addEventListener("play", this.Qs), t.addEventListener("pause", this.Js), t.addEventListener("seeked", this.ti), this.si() ? this.ii() : (s.preload || t.addEventListener("canplay", this.Ys), t.addEventListener("canplaythrough", this.Ks), t.addEventListener("error", this.Zs, !0)), this.alphaMode = await async function () { return Is ?? (Is = (async () => { const t = ks.get().createCanvas(1, 1).getContext("webgl"); if (!t) return "premultiply-alpha-on-upload"; const s = await new Promise(t => { const s = document.createElement("video"); s.onloadeddata = () => t(s), s.onerror = () => t(null), s.autoplay = !1, s.crossOrigin = "anonymous", s.preload = "auto", s.src = "data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=", s.load() }); if (!s) return "premultiply-alpha-on-upload"; const i = t.createTexture(); t.bindTexture(t.TEXTURE_2D, i); const e = t.createFramebuffer(); t.bindFramebuffer(t.FRAMEBUFFER, e), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, i, 0), t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1), t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, t.NONE), t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, s); const n = new Uint8Array(4); return t.readPixels(0, 0, 1, 1, t.RGBA, t.UNSIGNED_BYTE, n), t.deleteFramebuffer(e), t.deleteTexture(i), t.getExtension("WEBGL_lose_context")?.loseContext(), n[0] <= n[3] ? "premultiplied-alpha" : "premultiply-alpha-on-upload" })()), Is }(), this.Hs = new Promise((i, e) => { this.isValid ? i(this) : (this.qs = i, this.Xs = e, void 0 !== s.preloadTimeoutMs && (this.ei = setTimeout(() => { this.Zs(new ErrorEvent(`Preload exceeded timeout of ${s.preloadTimeoutMs}ms`)) })), t.load()) }), this.Hs } Zs(t) { this.resource.removeEventListener("error", this.Zs, !0), this.emit("error", t), this.Xs && (this.Xs(t), this.Xs = null, this.qs = null) } ni() { const t = this.resource; return !t.paused && !t.ended } si() { return this.resource.readyState > 2 } Qs() { this.isValid || this.ii(), this.ri() } Js() { this.ri() } ti() { this.Ds && !this.ni() && (this.Vs = 0, this.updateFrame(), this.Vs = 0) } Ys() { this.resource.removeEventListener("canplay", this.Ys), this.ii() } Ks() { this.resource.removeEventListener("canplaythrough", this.Ys), this.ei && (clearTimeout(this.ei), this.ei = void 0), this.ii() } ii() { const t = this.resource; this.isValid && (this.isReady = !0, this.resize(t.videoWidth, t.videoHeight)), this.Vs = 0, this.updateFrame(), this.Vs = 0, this.qs && (this.qs(this), this.qs = null, this.Xs = null), this.ni() ? this.Qs() : this.autoPlay && this.resource.play() } destroy() { this.ri(); const t = this.resource; t && (t.removeEventListener("play", this.Qs), t.removeEventListener("pause", this.Js), t.removeEventListener("seeked", this.ti), t.removeEventListener("canplay", this.Ys), t.removeEventListener("canplaythrough", this.Ks), t.removeEventListener("error", this.Zs, !0), t.pause(), t.src = "", t.load()), super.destroy() } get autoUpdate() { return this.Ds } set autoUpdate(t) { t !== this.Ds && (this.Ds = t, this.ri()) } get updateFPS() { return this.Ls } set updateFPS(t) { t !== this.Ls && (this.Ls = t, this.ri()) } ri() { this.Ds && this.ni() ? !this.Ls && this.resource.requestVideoFrameCallback ? (this.js && (Bs.shared.remove(this.updateFrame, this), this.js = !1, this.Vs = 0), null === this.Ws && (this.Ws = this.resource.requestVideoFrameCallback(this.Ns))) : (null !== this.Ws && (this.resource.cancelVideoFrameCallback(this.Ws), this.Ws = null), this.js || (Bs.shared.add(this.updateFrame, this), this.js = !0, this.Vs = 0)) : (null !== this.Ws && (this.resource.cancelVideoFrameCallback(this.Ws), this.Ws = null), this.js && (Bs.shared.remove(this.updateFrame, this), this.js = !1, this.Vs = 0)) } static test(t) { return globalThis.HTMLVideoElement && t instanceof HTMLVideoElement } }; Gs.extension = r.TextureSource, Gs.defaultOptions = { ...q.defaultOptions, autoLoad: !0, autoPlay: !0, updateFPS: 0, crossorigin: !0, loop: !1, muted: !0, playsinline: !0, preload: !1 }, Gs.MIME_TYPES = { ogv: "video/ogg", mov: "video/quicktime", m4v: "video/mp4" }; let $s = Gs; const zs = (t, s, i = !1) => (Array.isArray(t) || (t = [t]), s ? t.map(t => "string" == typeof t || i ? s(t) : t) : t), Ds = new class { constructor() { this.oi = [], this.hi = new Map, this.ai = new Map } reset() { this.ai.clear(), this.hi.clear() } has(t) { return this.hi.has(t) } get(t) { const s = this.hi.get(t); return s || Et(), s } set(t, s) { const i = zs(t); let e; for (let h = 0; h < this.parsers.length; h++) { const t = this.parsers[h]; if (t.test(s)) { e = t.getCacheableAssets(i, s); break } } const n = new Map(Object.entries(e || {})); e || i.forEach(t => { n.set(t, s) }); const r = [...n.keys()], o = { cacheKeys: r, keys: i }; i.forEach(t => { this.ai.set(t, o) }), r.forEach(t => { const i = e ? e[t] : s; this.hi.has(t) && this.hi.get(t) !== i && Et(), this.hi.set(t, n.get(t)) }) } remove(t) { if (!this.ai.has(t)) return void Et(); const s = this.ai.get(t); s.cacheKeys.forEach(t => { this.hi.delete(t) }), s.keys.forEach(t => { this.ai.delete(t) }) } get parsers() { return this.oi } }, js = []; function Ls(t = {}) { const s = t && t.resource, i = s ? t.resource : t, e = s ? t : { resource: t }; for (let n = 0; n < js.length; n++) { const t = js[n]; if (t.test(i)) return new t(e) } throw new Error(`Could not find a source type for resource: ${e.resource}`) } a.handleByList(r.TextureSource, js), Z.from = function (t, s = !1) { return "string" == typeof t ? Ds.get(t) : t instanceof q ? new Z({ source: t }) : function (t = {}, s = !1) { const i = t && t.resource, e = i ? t.resource : t, n = i ? t : { resource: t }; if (!s && Ds.has(e)) return Ds.get(e); const r = new Z({ source: Ls(n) }); return r.on("destroy", () => { Ds.has(e) && Ds.remove(e) }), s || Ds.set(e, r), r }(t, s) }, q.from = Ls, a.add(Cs, _s, Ss, $s, Es, Fs, X); var Vs = (t => (t[t.Low = 0] = "Low", t[t.Normal = 1] = "Normal", t[t.High = 2] = "High", t))(Vs || {}); function Ns(t) { if ("string" != typeof t) throw new TypeError(`Path must be a string. Received ${JSON.stringify(t)}`) } function Ws(t) { return t.split("?")[0].split("#")[0] } const Hs = { toPosix: t => t.replace(new RegExp("\\".replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "g"), "/"), isUrl(t) { return /^https?:/.test(this.toPosix(t)) }, isDataUrl: t => /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(t), isBlobUrl: t => t.startsWith("blob:"), hasProtocol(t) { return /^[^/:]+:/.test(this.toPosix(t)) }, getProtocol(t) { Ns(t), t = this.toPosix(t); const s = /^file:\/\/\//.exec(t); if (s) return s[0]; const i = /^[^/:]+:\/{0,2}/.exec(t); return i ? i[0] : "" }, toAbsolute(t, s, i) { if (Ns(t), this.isDataUrl(t) || this.isBlobUrl(t)) return t; const e = Ws(this.toPosix(s ?? ks.get().getBaseUrl())), n = Ws(this.toPosix(i ?? this.rootname(e))); return (t = this.toPosix(t)).startsWith("/") ? Hs.join(n, t.slice(1)) : this.isAbsolute(t) ? t : this.join(e, t) }, normalize(t) { if (Ns(t), 0 === t.length) return "."; if (this.isDataUrl(t) || this.isBlobUrl(t)) return t; let s = ""; const i = (t = this.toPosix(t)).startsWith("/"); this.hasProtocol(t) && (s = this.rootname(t), t = t.slice(s.length)); const e = t.endsWith("/"); return (t = function (t) { let s = "", i = 0, e = -1, n = 0, r = -1; for (let o = 0; o <= t.length; ++o) { if (o < t.length) r = t.charCodeAt(o); else { if (47 === r) break; r = 47 } if (47 === r) { if (e === o - 1 || 1 === n); else if (e !== o - 1 && 2 === n) { if (s.length < 2 || 2 !== i || 46 !== s.charCodeAt(s.length - 1) || 46 !== s.charCodeAt(s.length - 2)) if (s.length > 2) { const t = s.lastIndexOf("/"); if (t !== s.length - 1) { -1 === t ? (s = "", i = 0) : (s = s.slice(0, t), i = s.length - 1 - s.lastIndexOf("/")), e = o, n = 0; continue } } else if (2 === s.length || 1 === s.length) { s = "", i = 0, e = o, n = 0; continue } } else s.length > 0 ? s += `/${t.slice(e + 1, o)}` : s = t.slice(e + 1, o), i = o - e - 1; e = o, n = 0 } else 46 === r && -1 !== n ? ++n : n = -1 } return s }(t)).length > 0 && e && (t += "/"), i ? `/${t}` : s + t }, isAbsolute(t) { return Ns(t), t = this.toPosix(t), !!this.hasProtocol(t) || t.startsWith("/") }, join(...t) { if (0 === t.length) return "."; let s; for (let i = 0; i < t.length; ++i) { const e = t[i]; if (Ns(e), e.length > 0) if (void 0 === s) s = e; else { const n = t[i - 1] ?? ""; this.joinExtensions.includes(this.extname(n).toLowerCase()) ? s += `/../${e}` : s += `/${e}` } } return void 0 === s ? "." : this.normalize(s) }, dirname(t) { if (Ns(t), 0 === t.length) return "."; let s = (t = this.toPosix(t)).charCodeAt(0); const i = 47 === s; let e = -1, n = !0; const r = this.getProtocol(t), o = t; for (let h = (t = t.slice(r.length)).length - 1; h >= 1; --h)if (s = t.charCodeAt(h), 47 === s) { if (!n) { e = h; break } } else n = !1; return -1 === e ? i ? "/" : this.isUrl(o) ? r + t : r : i && 1 === e ? "//" : r + t.slice(0, e) }, rootname(t) { Ns(t); let s = ""; if (s = (t = this.toPosix(t)).startsWith("/") ? "/" : this.getProtocol(t), this.isUrl(t)) { const i = t.indexOf("/", s.length); s = -1 !== i ? t.slice(0, i) : t, s.endsWith("/") || (s += "/") } return s }, basename(t, s) { Ns(t), s && Ns(s), t = Ws(this.toPosix(t)); let i, e = 0, n = -1, r = !0; if (void 0 !== s && s.length > 0 && s.length <= t.length) { if (s.length === t.length && s === t) return ""; let o = s.length - 1, h = -1; for (i = t.length - 1; i >= 0; --i) { const a = t.charCodeAt(i); if (47 === a) { if (!r) { e = i + 1; break } } else -1 === h && (r = !1, h = i + 1), o >= 0 && (a === s.charCodeAt(o) ? -1 === --o && (n = i) : (o = -1, n = h)) } return e === n ? n = h : -1 === n && (n = t.length), t.slice(e, n) } for (i = t.length - 1; i >= 0; --i)if (47 === t.charCodeAt(i)) { if (!r) { e = i + 1; break } } else -1 === n && (r = !1, n = i + 1); return -1 === n ? "" : t.slice(e, n) }, extname(t) { Ns(t); let s = -1, i = 0, e = -1, n = !0, r = 0; for (let o = (t = Ws(this.toPosix(t))).length - 1; o >= 0; --o) { const h = t.charCodeAt(o); if (47 !== h) -1 === e && (n = !1, e = o + 1), 46 === h ? -1 === s ? s = o : 1 !== r && (r = 1) : -1 !== s && (r = -1); else if (!n) { i = o + 1; break } } return -1 === s || -1 === e || 0 === r || 1 === r && s === e - 1 && s === i + 1 ? "" : t.slice(s, e) }, parse(t) { Ns(t); const s = { root: "", dir: "", base: "", ext: "", name: "" }; if (0 === t.length) return s; let i = (t = Ws(this.toPosix(t))).charCodeAt(0); const e = this.isAbsolute(t); let n; s.root = this.rootname(t), n = e || this.hasProtocol(t) ? 1 : 0; let r = -1, o = 0, h = -1, a = !0, u = t.length - 1, l = 0; for (; u >= n; --u)if (i = t.charCodeAt(u), 47 !== i) -1 === h && (a = !1, h = u + 1), 46 === i ? -1 === r ? r = u : 1 !== l && (l = 1) : -1 !== r && (l = -1); else if (!a) { o = u + 1; break } return -1 === r || -1 === h || 0 === l || 1 === l && r === h - 1 && r === o + 1 ? -1 !== h && (s.base = s.name = 0 === o && e ? t.slice(1, h) : t.slice(o, h)) : (0 === o && e ? (s.name = t.slice(1, r), s.base = t.slice(1, h)) : (s.name = t.slice(o, r), s.base = t.slice(o, h)), s.ext = t.slice(r, h)), s.dir = this.dirname(t), s }, sep: "/", delimiter: ":", joinExtensions: [".html"] }; function qs(t, s, i, e, n) { const r = s[i]; for (let o = 0; o < r.length; o++) { const h = r[o]; i < s.length - 1 ? qs(t.replace(e[i], h), s, i + 1, e, n) : n.push(t.replace(e[i], h)) } } function Xs(t) { const s = t.match(/\{(.*?)\}/g), i = []; if (s) { const e = []; s.forEach(t => { const s = t.substring(1, t.length - 1).split(","); e.push(s) }), qs(t, e, 0, s, i) } else i.push(t); return i } const Ys = t => !Array.isArray(t); class Ks { constructor() { this.ui = { connector: "-", createBundleAssetId: (t, s) => `${t}${this.li}${s}`, extractAssetIdFromBundle: (t, s) => s.replace(`${t}${this.li}`, "") }, this.li = this.ui.connector, this.ci = this.ui.createBundleAssetId, this.fi = this.ui.extractAssetIdFromBundle, this.di = {}, this.pi = [], this.oi = [], this.mi = {}, this.gi = {} } setBundleIdentifier(t) { if (this.li = t.connector ?? this.li, this.ci = t.createBundleAssetId ?? this.ci, this.fi = t.extractAssetIdFromBundle ?? this.fi, "bar" !== this.fi("foo", this.ci("foo", "bar"))) throw new Error("[Resolver] GenerateBundleAssetId are not working correctly") } prefer(...t) { t.forEach(t => { this.pi.push(t), t.priority || (t.priority = Object.keys(t.params)) }), this.mi = {} } set basePath(t) { this.bi = t } get basePath() { return this.bi } set rootPath(t) { this.xi = t } get rootPath() { return this.xi } get parsers() { return this.oi } reset() { this.setBundleIdentifier(this.ui), this.di = {}, this.pi = [], this.mi = {}, this.xi = null, this.bi = null, this.yi = null, this.gi = {}, this.wi = null } setDefaultSearchParams(t) { if ("string" == typeof t) this.wi = t; else { const s = t; this.wi = Object.keys(s).map(t => `${encodeURIComponent(t)}=${encodeURIComponent(s[t])}`).join("&") } } getAlias(t) { const { alias: s, src: i } = t; return zs(s || i, t => "string" == typeof t ? t : Array.isArray(t) ? t.map(t => t?.src ?? t) : t?.src ? t.src : t, !0) } addManifest(t) { this.yi && Et(), this.yi = t, t.bundles.forEach(t => { this.addBundle(t.name, t.assets) }) } addBundle(t, s) { const i = []; let e = s; Array.isArray(s) || (e = Object.entries(s).map(([t, s]) => "string" == typeof s || Array.isArray(s) ? { alias: t, src: s } : { alias: t, ...s })), e.forEach(s => { const e = s.src, n = s.alias; let r; if ("string" == typeof n) { const s = this.ci(t, n); i.push(s), r = [n, s] } else { const s = n.map(s => this.ci(t, s)); i.push(...s), r = [...n, ...s] } this.add({ ...s, alias: r, src: e }) }), this.gi[t] = i } add(t) { const s = []; let i; Array.isArray(t) ? s.push(...t) : s.push(t), i = t => { this.hasKey(t) && Et() }, zs(s).forEach(t => { const { src: s } = t; let { data: e, format: n, loadParser: r, parser: o } = t; const h = zs(s).map(t => "string" == typeof t ? Xs(t) : Array.isArray(t) ? t : [t]), a = this.getAlias(t); Array.isArray(a) ? a.forEach(i) : i(a); const u = [], l = t => { const s = this.oi.find(s => s.test(t)); return { ...s?.parse(t), src: t } }; h.forEach(s => { s.forEach(s => { let i = {}; if ("object" != typeof s ? i = l(s) : (e = s.data ?? e, n = s.format ?? n, (s.loadParser || s.parser) && (r = s.loadParser ?? r, o = s.parser ?? o), i = { ...l(s.src), ...s }), !a) throw new Error(`[Resolver] alias is undefined for this asset: ${i.src}`); i = this.Mi(i, { aliases: a, data: e, format: n, loadParser: r, parser: o, progressSize: t.progressSize }), u.push(i) }) }), a.forEach(t => { this.di[t] = u }) }) } resolveBundle(t) { const s = Ys(t); t = zs(t); const i = {}; return t.forEach(t => { const s = this.gi[t]; if (s) { const e = this.resolve(s), n = {}; for (const s in e) { const i = e[s]; n[this.fi(t, s)] = i } i[t] = n } }), s ? i[t[0]] : i } resolveUrl(t) { const s = this.resolve(t); if ("string" != typeof t) { const t = {}; for (const i in s) t[i] = s[i].src; return t } return s.src } resolve(t) { const s = Ys(t); t = zs(t); const i = {}; return t.forEach(t => { if (!this.mi[t]) if (this.di[t]) { let s = this.di[t]; const i = this.Ti(s); i?.priority.forEach(t => { i.params[t].forEach(i => { const e = s.filter(s => !!s[t] && s[t] === i); e.length && (s = e) }) }), this.mi[t] = s[0] } else this.mi[t] = this.Mi({ alias: [t], src: t }, {}); i[t] = this.mi[t] }), s ? i[t[0]] : i } hasKey(t) { return !!this.di[t] } hasBundle(t) { return !!this.gi[t] } Ti(t) { for (let s = 0; s < t.length; s++) { const i = t[s], e = this.pi.find(t => t.params.format.includes(i.format)); if (e) return e } return this.pi[0] } Ai(t) { return this.wi ? `${t}${/\?/.test(t) ? "&" : "?"}${this.wi}` : t } Mi(t, s) { const { aliases: i, data: e, loadParser: n, parser: r, format: o, progressSize: h } = s; return (this.bi || this.xi) && (t.src = Hs.toAbsolute(t.src, this.bi, this.xi)), t.alias = i ?? t.alias ?? [t.src], t.src = this.Ai(t.src), t.data = { ...e || {}, ...t.data }, t.loadParser = n ?? t.loadParser, t.parser = r ?? t.parser, t.format = o ?? t.format ?? t.src.split(".").pop().split("?").shift().split("#").shift(), void 0 !== h && (t.progressSize = h), t } } Ks.RETINA_PREFIX = /@([0-9\.]+)x/; const Zs = (t, s) => { const i = s.split("?")[1]; return i && (t += `?${i}`), t }, Qs = class t { constructor(t, s) { this.linkedSheets = []; let i = t; t?.source instanceof q && (i = { texture: t, data: s }); const { texture: e, data: n, cachePrefix: r = "" } = i; this.cachePrefix = r, this.Y = e instanceof Z ? e : null, this.textureSource = e.source, this.textures = {}, this.animations = {}, this.data = n; const o = parseFloat(n.meta.scale); o ? (this.resolution = o, e.source.resolution = this.resolution) : this.resolution = e.source.G, this.Ci = this.data.frames, this._i = Object.keys(this.Ci), this.Si = 0, this.Pi = null } parse() { return new Promise(s => { this.Pi = s, this.Si = 0, this._i.length <= t.BATCH_SIZE ? (this.ki(0), this.Fi(), this.Ei()) : this.Ri() }) } ki(s) { let i = s; const e = t.BATCH_SIZE; for (; i - s < e && i < this._i.length;) { const t = this._i[i], s = this.Ci[t], e = s.frame; if (e) { let i = null, n = null; const r = !1 !== s.trimmed && s.sourceSize ? s.sourceSize : s.frame, o = new O(0, 0, Math.floor(r.w) / this.resolution, Math.floor(r.h) / this.resolution); i = s.rotated ? new O(Math.floor(e.x) / this.resolution, Math.floor(e.y) / this.resolution, Math.floor(e.h) / this.resolution, Math.floor(e.w) / this.resolution) : new O(Math.floor(e.x) / this.resolution, Math.floor(e.y) / this.resolution, Math.floor(e.w) / this.resolution, Math.floor(e.h) / this.resolution), !1 !== s.trimmed && s.spriteSourceSize && (n = new O(Math.floor(s.spriteSourceSize.x) / this.resolution, Math.floor(s.spriteSourceSize.y) / this.resolution, Math.floor(e.w) / this.resolution, Math.floor(e.h) / this.resolution)), this.textures[t] = new Z({ source: this.textureSource, frame: i, orig: o, trim: n, rotate: s.rotated ? 2 : 0, defaultAnchor: s.anchor, defaultBorders: s.borders, label: t.toString() }) } i++ } } Fi() { const t = this.data.animations || {}; for (const s in t) { this.animations[s] = []; for (let i = 0; i < t[s].length; i++) { const e = t[s][i]; this.animations[s].push(this.textures[e]) } } } Ei() { const t = this.Pi; this.Pi = null, this.Si = 0, t.call(this, this.textures) } Ri() { this.ki(this.Si * t.BATCH_SIZE), this.Si++, setTimeout(() => { this.Si * t.BATCH_SIZE < this._i.length ? this.Ri() : (this.Fi(), this.Ei()) }, 0) } destroy(t = !1) { for (const s in this.textures) this.textures[s].destroy(); this.Ci = null, this._i = null, this.data = null, this.textures = null, t && (this.Y?.destroy(), this.textureSource.destroy()), this.Y = null, this.textureSource = null, this.linkedSheets = [] } }; Qs.BATCH_SIZE = 1e3; let Js = Qs; const ti = ["jpg", "png", "jpeg", "avif", "webp", "basis", "etc2", "bc7", "bc6h", "bc5", "bc4", "bc3", "bc2", "bc1", "eac", "astc"]; function si(t, s, i) { const e = {}; if (t.forEach(t => { e[t] = s }), Object.keys(s.textures).forEach(t => { e[`${s.cachePrefix}${t}`] = s.textures[t] }), !i) { const i = Hs.dirname(t[0]); s.linkedSheets.forEach((t, n) => { const r = si([`${i}/${s.data.meta.related_multi_packs[n]}`], t, !0); Object.assign(e, r) }) } return e } const ii = { extension: r.Asset, cache: { test: t => t instanceof Js, getCacheableAssets: (t, s) => si(t, s, !1) }, resolver: { extension: { type: r.ResolveParser, name: "resolveSpritesheet" }, test: t => { const s = t.split("?")[0].split("."), i = s.pop(), e = s.pop(); return "json" === i && ti.includes(e) }, parse: t => { const s = t.split("."); return { resolution: parseFloat(Ks.RETINA_PREFIX.exec(t)?.[1] ?? "1"), format: s[s.length - 2], src: t } } }, loader: { name: "spritesheetLoader", id: "spritesheet", extension: { type: r.LoadParser, priority: Vs.Normal, name: "spritesheetLoader" }, testParse: async (t, s) => ".json" === Hs.extname(s.src).toLowerCase() && !!t.frames, async parse(t, s, i) { const { texture: e, imageFilename: n, textureOptions: r, cachePrefix: o } = s?.data ?? {}; let h, a = Hs.dirname(s.src); if (a && a.lastIndexOf("/") !== a.length - 1 && (a += "/"), e instanceof Z) h = e; else { const e = Zs(a + (n ?? t.meta.image), s.src); h = (await i.load([{ src: e, data: r }]))[e] } const u = new Js({ texture: h.source, data: t, cachePrefix: o }); await u.parse(); const l = t?.meta?.related_multi_packs; if (Array.isArray(l)) { const t = []; for (const n of l) { if ("string" != typeof n) continue; let e = a + n; s.data?.ignoreMultiPack || (e = Zs(e, s.src), t.push(i.load({ src: e, data: { textureOptions: r, ignoreMultiPack: !0 } }))) } const e = await Promise.all(t); u.linkedSheets = e, e.forEach(t => { t.linkedSheets = [u].concat(u.linkedSheets.filter(s => s !== t)) }) } return u }, async unload(t, s, i) { await i.unload(t.textureSource.Oi), t.destroy(!1) } } }; a.add(ii); class ei { constructor(t) { this.Ui = "", this.A = null, this.Ii = !1, this.updateTranslation = () => { if (!this.Bi) return; const t = this.Bi.getBoundingClientRect(), s = this.Bi.width, i = this.Bi.height, e = t.width / s * this.Gi.resolution, n = t.height / i * this.Gi.resolution, r = `translate(${t.left}px, ${t.top}px) scale(${e}, ${n})`; r !== this.Ui && (this.$i.style.transform = r, this.Ui = r) }, this.$i = t.domElement, this.Gi = t.renderer, globalThis.OffscreenCanvas && this.Gi.canvas instanceof OffscreenCanvas || (this.Bi = this.Gi.canvas, this.zi()) } get canvas() { return this.Bi } ensureAttached() { !this.$i.parentNode && this.Bi.parentNode && (this.Bi.parentNode.appendChild(this.$i), this.updateTranslation()) } zi() { "ResizeObserver" in globalThis ? (this.A && (this.A.disconnect(), this.A = null), this.A = new ResizeObserver(t => { for (const s of t) { if (s.target !== this.Bi) continue; const t = this.canvas.width, i = this.canvas.height, e = s.contentRect.width / t * this.Gi.resolution, n = s.contentRect.height / i * this.Gi.resolution; (this.Di !== e || this.ji !== n) && (this.updateTranslation(), this.Di = e, this.ji = n) } }), this.A.observe(this.Bi)) : this.Ii || Bs.shared.add(this.updateTranslation, this, Rs.HIGH) } destroy() { this.A ? (this.A.disconnect(), this.A = null) : this.Ii && Bs.shared.remove(this.updateTranslation), this.$i = null, this.Gi = null, this.Bi = null, this.Ii = !1, this.Ui = "", this.Di = null, this.ji = null } } class ni { constructor(t) { this.bubbles = !0, this.cancelBubble = !0, this.cancelable = !1, this.composed = !1, this.defaultPrevented = !1, this.eventPhase = ni.prototype.NONE, this.propagationStopped = !1, this.propagationImmediatelyStopped = !1, this.layer = new x, this.page = new x, this.NONE = 0, this.CAPTURING_PHASE = 1, this.AT_TARGET = 2, this.BUBBLING_PHASE = 3, this.manager = t } get layerX() { return this.layer.x } get layerY() { return this.layer.y } get pageX() { return this.page.x } get pageY() { return this.page.y } get data() { return this } composedPath() { return !this.manager || this.path && this.path[this.path.length - 1] === this.target || (this.path = this.target ? this.manager.propagationPath(this.target) : []), this.path } initEvent(t, s, i) { throw new Error("initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.") } initUIEvent(t, s, i, e, n) { throw new Error("initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.") } preventDefault() { this.nativeEvent instanceof Event && this.nativeEvent.cancelable && this.nativeEvent.preventDefault(), this.defaultPrevented = !0 } stopImmediatePropagation() { this.propagationImmediatelyStopped = !0 } stopPropagation() { this.propagationStopped = !0 } } var ri = /iPhone/i, oi = /iPod/i, hi = /iPad/i, ai = /\biOS-universal(?:.+)Mac\b/i, ui = /\bAndroid(?:.+)Mobile\b/i, li = /Android/i, ci = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i, fi = /Silk/i, di = /Windows Phone/i, pi = /\bWindows(?:.+)ARM\b/i, mi = /BlackBerry/i, gi = /BB10/i, vi = /Opera Mini/i, bi = /\b(CriOS|Chrome)(?:.+)Mobile/i, xi = /Mobile(?:.+)Firefox\b/i, yi = function (t) { return void 0 !== t && "MacIntel" === t.platform && "number" == typeof t.maxTouchPoints && t.maxTouchPoints > 1 && "undefined" == typeof MSStream }; function wi(t) { var s = { userAgent: "", platform: "", maxTouchPoints: 0 }; t || "undefined" == typeof navigator ? "string" == typeof t ? s.userAgent = t : t && t.userAgent && (s = { userAgent: t.userAgent, platform: t.platform, maxTouchPoints: t.maxTouchPoints || 0 }) : s = { userAgent: navigator.userAgent, platform: navigator.platform, maxTouchPoints: navigator.maxTouchPoints || 0 }; var i = s.userAgent, e = i.split("[FBAN"); void 0 !== e[1] && (i = e[0]), void 0 !== (e = i.split("Twitter"))[1] && (i = e[0]); var n = function (t) { return function (s) { return s.test(t) } }(i), r = { apple: { phone: n(ri) && !n(di), ipod: n(oi), tablet: !n(ri) && (n(hi) || yi(s)) && !n(di), universal: n(ai), device: (n(ri) || n(oi) || n(hi) || n(ai) || yi(s)) && !n(di) }, amazon: { phone: n(ci), tablet: !n(ci) && n(fi), device: n(ci) || n(fi) }, android: { phone: !n(di) && n(ci) || !n(di) && n(ui), tablet: !n(di) && !n(ci) && !n(ui) && (n(fi) || n(li)), device: !n(di) && (n(ci) || n(fi) || n(ui) || n(li)) || n(/\bokhttp\b/i) }, windows: { phone: n(di), tablet: n(pi), device: n(di) || n(pi) }, other: { blackberry: n(mi), blackberry10: n(gi), opera: n(vi), firefox: n(xi), chrome: n(bi), device: n(mi) || n(gi) || n(vi) || n(xi) || n(bi) }, any: !1, phone: !1, tablet: !1 }; return r.any = r.apple.device || r.android.device || r.windows.device || r.other.device, r.phone = r.apple.phone || r.android.phone || r.windows.phone, r.tablet = r.apple.tablet || r.android.tablet || r.windows.tablet, r } const Mi = (wi.default ?? wi)(globalThis.navigator), Ti = class t { constructor(t, s = Mi) { this.Li = s, this.debug = !1, this.Vi = !0, this.Ni = !0, this.Wi = !1, this.Hi = !1, this.qi = null, this.Xi = {}, this.Yi = 0, this.Ki = [], this.Zi = 0, this.Qi = 500, this.Ji = !1, this.te = this.se.bind(this), this.ie = this.ee.bind(this), this.ne = null, (s.tablet || s.phone) && this.re(), this.Gi = t } get isActive() { return this.Wi } get isMobileAccessibility() { return this.Hi } get hookDiv() { return this.ne } get div() { return this.qi } re() { const t = document.createElement("button"); t.style.width = "1px", t.style.height = "1px", t.style.position = "absolute", t.style.top = "-1000px", t.style.left = "-1000px", t.style.zIndex = 2..toString(), t.style.backgroundColor = "#FF0000", t.title = "select to enable accessibility for this content", t.addEventListener("focus", () => { this.Hi = !0, this.oe(), this.he() }), document.body.appendChild(t), this.ne = t } he() { this.ne && (document.body.removeChild(this.ne), this.ne = null) } oe() { if (this.Wi) return; this.Wi = !0, this.qi || (this.qi = document.createElement("div"), this.qi.style.position = "absolute", this.qi.style.top = "0px", this.qi.style.left = "0px", this.qi.style.pointerEvents = "none", this.qi.style.zIndex = 2..toString(), this.ae = new ei({ domElement: this.qi, renderer: this.Gi })), this.Vi && globalThis.addEventListener("keydown", this.te, !1), this.Ni && globalThis.document.addEventListener("mousemove", this.ie, !0); const t = this.Gi.view.canvas; if (t.parentNode) this.ae.ensureAttached(), this.ue(); else { const s = new MutationObserver(() => { t.parentNode && (s.disconnect(), this.ae.ensureAttached(), this.ue()) }); s.observe(document.body, { childList: !0, subtree: !0 }) } } ue() { this.Gi.runners.postrender.add(this), this.Gi.lastObjectRendered && this.le(this.Gi.lastObjectRendered) } ce() { if (this.Wi && !this.Hi) { this.Wi = !1, globalThis.document.removeEventListener("mousemove", this.ie, !0), this.Vi && globalThis.addEventListener("keydown", this.te, !1), this.Gi.runners.postrender.remove(this); for (const t of this.Ki) t.fe?.parentNode && (t.fe.parentNode.removeChild(t.fe), t.fe = null), t.de = !1; for (const t in this.Xi) this.Xi[t].forEach(t => { t.parentNode && t.parentNode.removeChild(t) }), delete this.Xi[t]; this.qi?.parentNode && this.qi.parentNode.removeChild(this.qi), this.Xi = {}, this.Ki = [] } } le(t) { if (!t.visible || !t.accessibleChildren) return; t.accessible && (t.de || this.pe(t), t.Yi = this.Yi); const s = t.children; if (s) for (let i = 0; i < s.length; i++)this.le(s[i]) } init(s) { const i = { accessibilityOptions: { ...t.defaultOptions, ...s?.accessibilityOptions || {} } }; this.debug = i.accessibilityOptions.debug, this.Vi = i.accessibilityOptions.activateOnTab, this.Ni = i.accessibilityOptions.deactivateOnMouseMove, i.accessibilityOptions.enabledByDefault && this.oe(), this.Gi.runners.postrender.remove(this) } postrender() { const t = performance.now(); if (this.Li.android.device && t < this.Zi) return; if (this.Zi = t + this.Qi, !(this.Gi.renderingToScreen && this.Gi.view.canvas || this.Ji)) return; const s = new Set; if (this.Gi.lastObjectRendered) { this.le(this.Gi.lastObjectRendered); for (const t of this.Ki) t.Yi === this.Yi && s.add(this.Ki.indexOf(t)) } for (let i = this.Ki.length - 1; i >= 0; i--) { const t = this.Ki[i]; s.has(i) || (t.fe && t.fe.parentNode && (t.fe.parentNode.removeChild(t.fe), this.me(t.accessibleType).push(t.fe), t.fe = null), t.de = !1, Bt(this.Ki, i, 1)) } this.Gi.renderingToScreen && this.ae.ensureAttached(); for (let i = 0; i < this.Ki.length; i++) { const t = this.Ki[i]; if (!t.de || !t.fe) continue; const s = t.fe, e = t.hitArea || t.getBounds().rectangle; if (t.hitArea) { const i = t.worldTransform; s.style.left = `${i.tx + e.x * i.a}px`, s.style.top = `${i.ty + e.y * i.d}px`, s.style.width = e.width * i.a + "px", s.style.height = e.height * i.d + "px" } else this.ge(e), s.style.left = `${e.x}px`, s.style.top = `${e.y}px`, s.style.width = `${e.width}px`, s.style.height = `${e.height}px` } this.Yi++ } ve(t) { t.innerHTML = `type: ${t.type}</br> title : ${t.title}</br> tabIndex: ${t.tabIndex}` } ge(t) { t.x < 0 && (t.width += t.x, t.x = 0), t.y < 0 && (t.height += t.y, t.y = 0); const { width: s, height: i } = this.Gi; t.x + t.width > s && (t.width = s - t.x), t.y + t.height > i && (t.height = i - t.y) } pe(t) { let s = this.me(t.accessibleType).pop(); s ? (s.innerHTML = "", s.removeAttribute("title"), s.removeAttribute("aria-label"), s.tabIndex = 0) : ("button" === t.accessibleType ? s = document.createElement("button") : (s = document.createElement(t.accessibleType), s.style.cssText = "\n                        color: transparent;\n                        pointer-events: none;\n                        padding: 0;\n                        margin: 0;\n                        border: 0;\n                        outline: 0;\n                        background: transparent;\n                        box-sizing: border-box;\n                        user-select: none;\n                        -webkit-user-select: none;\n                        -moz-user-select: none;\n                        -ms-user-select: none;\n                    ", t.accessibleText && (s.innerText = t.accessibleText)), s.style.width = "100px", s.style.height = "100px", s.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent", s.style.position = "absolute", s.style.zIndex = 2..toString(), s.style.borderStyle = "none", navigator.userAgent.toLowerCase().includes("chrome") ? s.setAttribute("aria-live", "off") : s.setAttribute("aria-live", "polite"), navigator.userAgent.match(/rv:.*Gecko\//) ? s.setAttribute("aria-relevant", "additions") : s.setAttribute("aria-relevant", "text"), s.addEventListener("click", this.be.bind(this)), s.addEventListener("focus", this.xe.bind(this)), s.addEventListener("focusout", this.ye.bind(this))), s.style.pointerEvents = t.accessiblePointerEvents, s.type = t.accessibleType, t.accessibleTitle && null !== t.accessibleTitle ? s.title = t.accessibleTitle : t.accessibleHint && null !== t.accessibleHint || (s.title = `container ${t.tabIndex}`), t.accessibleHint && null !== t.accessibleHint && s.setAttribute("aria-label", t.accessibleHint), t.interactive ? s.tabIndex = t.tabIndex : s.tabIndex = 0, this.debug && this.ve(s), t.de = !0, t.fe = s, s.container = t, this.Ki.push(t), this.qi.appendChild(t.fe) } we(t, s) { const { container: i } = t.target, e = this.Gi.events.rootBoundary, n = Object.assign(new ni(e), { target: i }); e.rootTarget = this.Gi.lastObjectRendered, s.forEach(t => e.dispatchEvent(n, t)) } be(t) { this.we(t, ["click", "pointertap", "tap"]) } xe(t) { t.target.getAttribute("aria-live") || t.target.setAttribute("aria-live", "assertive"), this.we(t, ["mouseover"]) } ye(t) { t.target.getAttribute("aria-live") || t.target.setAttribute("aria-live", "polite"), this.we(t, ["mouseout"]) } se(t) { 9 === t.keyCode && this.Vi && this.oe() } ee(t) { 0 === t.movementX && 0 === t.movementY || this.ce() } destroy() { this.ce(), this.he(), this.ae?.destroy(), this.ae = null, this.qi = null, this.Xi = null, this.Ki = null, this.Gi = null, this.ne = null, globalThis.removeEventListener("keydown", this.te), this.te = null, globalThis.document.removeEventListener("mousemove", this.ie, !0), this.ie = null } setAccessibilityEnabled(t) { t ? this.oe() : this.ce() } me(t) { return this.Xi[t] || (this.Xi[t] = []), this.Xi[t] } }; Ti.extension = { type: [r.WebGLSystem, r.WebGPUSystem], name: "accessibility" }, Ti.defaultOptions = { enabledByDefault: !1, debug: !1, activateOnTab: !0, deactivateOnMouseMove: !0 }; let Ai = Ti; const Ci = Object.create(null), _i = Object.create(null); function Si(t, s) { let i = _i[t]; return void 0 === i && (void 0 === Ci[s] && (Ci[s] = 1), _i[t] = i = Ci[s]++), i } let Pi, ki; function Fi() { if (!Pi || Pi?.isContextLost()) { const t = ks.get().createCanvas(); Pi = t.getContext("webgl", {}) } return Pi } function Ei() { if (!ki) { ki = "mediump"; const t = Fi(); if (t && t.getShaderPrecisionFormat) { const s = t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT); ki = s.precision ? "highp" : "mediump" } } return ki } const Ri = {}, Oi = {}, Ui = { stripVersion: function (t, s) { return s ? t.replace("#version 300 es", "") : t }, ensurePrecision: function (t, s, i) { const e = i ? s.maxSupportedFragmentPrecision : s.maxSupportedVertexPrecision; if ("precision" !== t.substring(0, 9)) { let n = i ? s.requestedFragmentPrecision : s.requestedVertexPrecision; return "highp" === n && "highp" !== e && (n = "mediump"), `precision ${n} float;\n${t}` } return "highp" !== e && "precision highp" === t.substring(0, 15) ? t.replace("precision highp", "precision mediump") : t }, addProgramDefines: function (t, s, i) { return s ? t : i ? `\n\n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in varying\n        #define finalColor gl_FragColor\n        #define texture texture2D\n        #endif\n        ${t = t.replace("out vec4 finalColor;", "")}\n        ` : `\n\n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in attribute\n        #define out varying\n        #endif\n        ${t}\n        ` }, setProgramName: function (t, { name: s = "pixi-program" }, i = !0) { s = s.replace(/\s+/g, "-"); const e = i ? Ri : Oi; return e[s += i ? "-fragment" : "-vertex"] ? (e[s]++, s += `-${e[s]}`) : e[s] = 1, -1 !== t.indexOf("#define SHADER_NAME") ? t : `#define SHADER_NAME ${s}\n${t}` }, insertVersion: function (t, s) { return s ? `#version 300 es\n${t}` : t } }, Ii = Object.create(null), Bi = class t { constructor(s) { const i = -1 !== (s = { ...t.defaultOptions, ...s }).fragment.indexOf("#version 300 es"), e = { stripVersion: i, ensurePrecision: { requestedFragmentPrecision: s.preferredFragmentPrecision, requestedVertexPrecision: s.preferredVertexPrecision, maxSupportedVertexPrecision: "highp", maxSupportedFragmentPrecision: Ei() }, setProgramName: { name: s.name }, addProgramDefines: i, insertVersion: i }; let n = s.fragment, r = s.vertex; Object.keys(Ui).forEach(t => { const s = e[t]; n = Ui[t](n, s, !0), r = Ui[t](r, s, !1) }), this.fragment = n, this.vertex = r, this.transformFeedbackVaryings = s.transformFeedbackVaryings, this.Me = Si(`${this.vertex}:${this.fragment}`, "gl-program") } destroy() { this.fragment = null, this.vertex = null, this.Te = null, this.Ae = null, this.Ce = null, this.transformFeedbackVaryings = null, Ii[this._e] = null } static from(s) { const i = `${s.vertex}:${s.fragment}`; return Ii[i] || (Ii[i] = new t(s), Ii[i]._e = i), Ii[i] } }; Bi.defaultOptions = { preferredVertexPrecision: "highp", preferredFragmentPrecision: "mediump" }; let Gi = Bi; const $i = { uint8x2: { size: 2, stride: 2, normalised: !1 }, uint8x4: { size: 4, stride: 4, normalised: !1 }, sint8x2: { size: 2, stride: 2, normalised: !1 }, sint8x4: { size: 4, stride: 4, normalised: !1 }, unorm8x2: { size: 2, stride: 2, normalised: !0 }, unorm8x4: { size: 4, stride: 4, normalised: !0 }, snorm8x2: { size: 2, stride: 2, normalised: !0 }, snorm8x4: { size: 4, stride: 4, normalised: !0 }, uint16x2: { size: 2, stride: 4, normalised: !1 }, uint16x4: { size: 4, stride: 8, normalised: !1 }, sint16x2: { size: 2, stride: 4, normalised: !1 }, sint16x4: { size: 4, stride: 8, normalised: !1 }, unorm16x2: { size: 2, stride: 4, normalised: !0 }, unorm16x4: { size: 4, stride: 8, normalised: !0 }, snorm16x2: { size: 2, stride: 4, normalised: !0 }, snorm16x4: { size: 4, stride: 8, normalised: !0 }, float16x2: { size: 2, stride: 4, normalised: !1 }, float16x4: { size: 4, stride: 8, normalised: !1 }, float32: { size: 1, stride: 4, normalised: !1 }, float32x2: { size: 2, stride: 8, normalised: !1 }, float32x3: { size: 3, stride: 12, normalised: !1 }, float32x4: { size: 4, stride: 16, normalised: !1 }, uint32: { size: 1, stride: 4, normalised: !1 }, uint32x2: { size: 2, stride: 8, normalised: !1 }, uint32x3: { size: 3, stride: 12, normalised: !1 }, uint32x4: { size: 4, stride: 16, normalised: !1 }, sint32: { size: 1, stride: 4, normalised: !1 }, sint32x2: { size: 2, stride: 8, normalised: !1 }, sint32x3: { size: 3, stride: 12, normalised: !1 }, sint32x4: { size: 4, stride: 16, normalised: !1 } }; function zi(t) { return $i[t] ?? $i.float32 } const Di = { f32: "float32", "vec2<f32>": "float32x2", "vec3<f32>": "float32x3", "vec4<f32>": "float32x4", vec2f: "float32x2", vec3f: "float32x3", vec4f: "float32x4", i32: "sint32", "vec2<i32>": "sint32x2", "vec3<i32>": "sint32x3", "vec4<i32>": "sint32x4", u32: "uint32", "vec2<u32>": "uint32x2", "vec3<u32>": "uint32x3", "vec4<u32>": "uint32x4", bool: "uint32", "vec2<bool>": "uint32x2", "vec3<bool>": "uint32x3", "vec4<bool>": "uint32x4" }; function ji(t) { const s = /@group\((\d+)\)/, i = /@binding\((\d+)\)/, e = /var(<[^>]+>)? (\w+)/, n = /:\s*(\w+)/, r = /(\w+)\s*:\s*([\w\<\>]+)/g, o = /struct\s+(\w+)/, h = t.match(/(^|[^/])@(group|binding)\(\d+\)[^;]+;/g)?.map(t => ({ group: parseInt(t.match(s)[1], 10), binding: parseInt(t.match(i)[1], 10), name: t.match(e)[2], isUniform: "<uniform>" === t.match(e)[1], type: t.match(n)[1] })); if (!h) return { groups: [], structs: [] }; const a = t.match(/struct\s+(\w+)\s*{([^}]+)}/g)?.map(t => { const s = t.match(o)[1], i = t.match(r).reduce((t, s) => { const [i, e] = s.split(":"); return t[i.trim()] = e.trim(), t }, {}); return i ? { name: s, members: i } : null }).filter(({ name: t }) => h.some(s => s.type === t)) ?? []; return { groups: h, structs: a } } var Li = (t => (t[t.VERTEX = 1] = "VERTEX", t[t.FRAGMENT = 2] = "FRAGMENT", t[t.COMPUTE = 4] = "COMPUTE", t))(Li || {}); const Vi = Object.create(null); class Ni { constructor(t) { this.Se = 0, this.Pe = 0; const { fragment: s, vertex: i, layout: e, gpuLayout: n, name: r } = t; if (this.name = r, this.fragment = s, this.vertex = i, s.source === i.source) { const t = ji(s.source); this.structsAndGroups = t } else { const t = ji(i.source), e = ji(s.source); this.structsAndGroups = function (t, s) { const i = new Set, e = new Set; return { structs: [...t.structs, ...s.structs].filter(t => !i.has(t.name) && (i.add(t.name), !0)), groups: [...t.groups, ...s.groups].filter(t => { const s = `${t.name}-${t.binding}`; return !e.has(s) && (e.add(s), !0) }) } }(t, e) } this.layout = e ?? function ({ groups: t }) { const s = []; for (let i = 0; i < t.length; i++) { const e = t[i]; s[e.group] || (s[e.group] = {}), s[e.group][e.name] = e.binding } return s }(this.structsAndGroups), this.gpuLayout = n ?? function ({ groups: t }) { const s = []; for (let i = 0; i < t.length; i++) { const e = t[i]; s[e.group] || (s[e.group] = []), e.isUniform ? s[e.group].push({ binding: e.binding, visibility: Li.VERTEX | Li.FRAGMENT, buffer: { type: "uniform" } }) : "sampler" === e.type ? s[e.group].push({ binding: e.binding, visibility: Li.FRAGMENT, sampler: { type: "filtering" } }) : "texture_2d" === e.type && s[e.group].push({ binding: e.binding, visibility: Li.FRAGMENT, texture: { sampleType: "float", viewDimension: "2d", multisampled: !1 } }) } return s }(this.structsAndGroups), this.autoAssignGlobalUniforms = !(void 0 === this.layout[0]?.globalUniforms), this.autoAssignLocalUniforms = !(void 0 === this.layout[1]?.localUniforms), this.ke() } ke() { const { vertex: t, fragment: s } = this, i = t.source + s.source + t.entryPoint + s.entryPoint; this.Se = Si(i, "program") } get attributeData() { return this.Te ?? (this.Te = function ({ source: t, entryPoint: s }) { const i = {}, e = t.indexOf(`fn ${s}`); if (-1 !== e) { const s = t.indexOf("->", e); if (-1 !== s) { const n = t.substring(e, s), r = /@location\((\d+)\)\s+([a-zA-Z0-9_]+)\s*:\s*([a-zA-Z0-9_<>]+)(?:,|\s|$)/g; let o; for (; null !== (o = r.exec(n));) { const t = Di[o[3]] ?? "float32"; i[o[2]] = { location: parseInt(o[1], 10), format: t, stride: zi(t).stride, offset: 0, instance: !1, start: 0 } } } } return i }(this.vertex)), this.Te } destroy() { this.gpuLayout = null, this.layout = null, this.structsAndGroups = null, this.fragment = null, this.vertex = null, Vi[this._e] = null } static from(t) { const s = `${t.vertex.source}:${t.fragment.source}:${t.fragment.entryPoint}:${t.vertex.entryPoint}`; return Vi[s] || (Vi[s] = new Ni(t), Vi[s]._e = s), Vi[s] } } const Wi = ["f32", "i32", "vec2<f32>", "vec3<f32>", "vec4<f32>", "mat2x2<f32>", "mat3x3<f32>", "mat4x4<f32>", "mat3x2<f32>", "mat4x2<f32>", "mat2x3<f32>", "mat4x3<f32>", "mat2x4<f32>", "mat3x4<f32>", "vec2<i32>", "vec3<i32>", "vec4<i32>"], Hi = Wi.reduce((t, s) => (t[s] = !0, t), {}); function qi(t, s) { switch (t) { case "f32": return 0; case "vec2<f32>": return new Float32Array(2 * s); case "vec3<f32>": return new Float32Array(3 * s); case "vec4<f32>": return new Float32Array(4 * s); case "mat2x2<f32>": return new Float32Array([1, 0, 0, 1]); case "mat3x3<f32>": return new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]); case "mat4x4<f32>": return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]) }return null } const Xi = class t { constructor(s, i) { this.R = 0, this.uid = I("uniform"), this.F = "uniformGroup", this.U = I("resource"), this.isUniformGroup = !0, this.Fe = 0, this.destroyed = !1, i = { ...t.defaultOptions, ...i }, this.uniformStructures = s; const e = {}; for (const t in s) { const i = s[t]; if (i.name = t, i.size = i.size ?? 1, !Hi[i.type]) { const t = i.type.match(/^array<(\w+(?:<\w+>)?),\s*(\d+)>$/); if (t) { const [, s, e] = t; throw new Error(`Uniform type ${i.type} is not supported. Use type: '${s}', size: ${e} instead.`) } throw new Error(`Uniform type ${i.type} is not supported. Supported uniform types are: ${Wi.join(", ")}`) } i.value ?? (i.value = qi(i.type, i.size)), e[t] = i.value } this.uniforms = e, this.Fe = 1, this.ubo = i.ubo, this.isStatic = i.isStatic, this.Ee = Si(Object.keys(e).map(t => `${t}-${s[t].type}`).join("-"), "uniform-group") } update() { this.Fe++ } }; Xi.defaultOptions = { ubo: !1, isStatic: !1 }; let Yi = Xi; class Ki { constructor(t) { this.resources = Object.create(null), this.Re = !0; let s = 0; for (const i in t) { const e = t[i]; this.setResource(e, s++) } this.Oe() } Oe() { if (!this.Re) return; this.Re = !1; const t = []; let s = 0; for (const i in this.resources) t[s++] = this.resources[i].U; this.Me = t.join("|") } setResource(t, s) { const i = this.resources[s]; t !== i && (i && t.off?.("change", this.onResourceChange, this), t.on?.("change", this.onResourceChange, this), this.resources[s] = t, this.Re = !0) } getResource(t) { return this.resources[t] } Ue(t) { const s = this.resources; for (const i in s) s[i].R = t } destroy() { const t = this.resources; for (const s in t) { const i = t[s]; i?.off?.("change", this.onResourceChange, this) } this.resources = null } onResourceChange(t) { if (this.Re = !0, t.destroyed) { const s = this.resources; for (const i in s) s[i] === t && (s[i] = null) } else this.Oe() } } var Zi = (t => (t[t.WEBGL = 1] = "WEBGL", t[t.WEBGPU = 2] = "WEBGPU", t[t.BOTH = 3] = "BOTH", t))(Zi || {}); class Qi extends m { constructor(t) { super(), this.uid = I("shader"), this.Ie = Object.create(null), this.Be = [], this.Ts = !1; let { gpuProgram: s, glProgram: i, groups: e, resources: n, compatibleRenderers: r, groupMap: o } = t; this.gpuProgram = s, this.glProgram = i, void 0 === r && (r = 0, s && (r |= Zi.WEBGPU), i && (r |= Zi.WEBGL)), this.compatibleRenderers = r; const h = {}; if (n || e || (n = {}), n && e) throw new Error("[Shader] Cannot have both resources and groups"); if (!s && e && !o) throw new Error("[Shader] No group map or WebGPU shader provided - consider using resources instead."); if (!s && e && o) for (const a in o) for (const t in o[a]) { const s = o[a][t]; h[s] = { group: a, binding: t, name: s } } else if (s && e && !o) { const t = s.structsAndGroups.groups; o = {}, t.forEach(t => { o[t.group] = o[t.group] || {}, o[t.group][t.binding] = t.name, h[t.name] = t }) } else if (n) { e = {}, o = {}, s && s.structsAndGroups.groups.forEach(t => { o[t.group] = o[t.group] || {}, o[t.group][t.binding] = t.name, h[t.name] = t }); let t = 0; for (const s in n) h[s] || (e[99] || (e[99] = new Ki, this.Be.push(e[99])), h[s] = { group: 99, binding: t, name: s }, o[99] = o[99] || {}, o[99][t] = s, t++); for (const s in n) { const t = s; let i = n[s]; i.source || i.F || (i = new Yi(i)); const r = h[t]; r && (e[r.group] || (e[r.group] = new Ki, this.Be.push(e[r.group])), e[r.group].setResource(i, r.binding)) } } this.groups = e, this.Ie = o, this.resources = this.Ge(e, h) } addResource(t, s, i) { var e, n; (e = this.Ie)[s] || (e[s] = {}), (n = this.Ie[s])[i] || (n[i] = t), this.groups[s] || (this.groups[s] = new Ki, this.Be.push(this.groups[s])) } Ge(t, s) { const i = {}; for (const e in s) { const n = s[e]; Object.defineProperty(i, n.name, { get: () => t[n.group].getResource(n.binding), set(s) { t[n.group].setResource(s, n.binding) } }) } return i } destroy(t = !1) { this.Ts || (this.Ts = !0, this.emit("destroy", this), t && (this.gpuProgram?.destroy(), this.glProgram?.destroy()), this.gpuProgram = null, this.glProgram = null, this.removeAllListeners(), this.Ie = null, this.Be.forEach(t => { t.destroy() }), this.Be = null, this.resources = null, this.groups = null) } static from(t) { const { gpu: s, gl: i, ...e } = t; let n, r; return s && (n = Ni.from(s)), i && (r = Gi.from(i)), new Qi({ gpuProgram: n, glProgram: r, ...e }) } } const Ji = { normal: 0, add: 1, multiply: 2, screen: 3, overlay: 4, erase: 5, "normal-npm": 6, "add-npm": 7, "screen-npm": 8, min: 9, max: 10 }, te = class t { constructor() { this.data = 0, this.blendMode = "normal", this.polygonOffset = 0, this.blend = !0, this.depthMask = !0 } get blend() { return !!(1 & this.data) } set blend(t) { !!(1 & this.data) !== t && (this.data ^= 1) } get offsets() { return !!(2 & this.data) } set offsets(t) { !!(2 & this.data) !== t && (this.data ^= 2) } set cullMode(t) { "none" !== t ? (this.culling = !0, this.clockwiseFrontFace = "front" === t) : this.culling = !1 } get cullMode() { return this.culling ? this.clockwiseFrontFace ? "front" : "back" : "none" } get culling() { return !!(4 & this.data) } set culling(t) { !!(4 & this.data) !== t && (this.data ^= 4) } get depthTest() { return !!(8 & this.data) } set depthTest(t) { !!(8 & this.data) !== t && (this.data ^= 8) } get depthMask() { return !!(32 & this.data) } set depthMask(t) { !!(32 & this.data) !== t && (this.data ^= 32) } get clockwiseFrontFace() { return !!(16 & this.data) } set clockwiseFrontFace(t) { !!(16 & this.data) !== t && (this.data ^= 16) } get blendMode() { return this.$e } set blendMode(t) { this.blend = "none" !== t, this.$e = t, this.ze = Ji[t] || 0 } get polygonOffset() { return this.De } set polygonOffset(t) { this.offsets = !!t, this.De = t } toString() { return `[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]` } static for2d() { const s = new t; return s.depthTest = !1, s.blend = !0, s } }; te.default2d = te.for2d(); let se = te; const ie = class t extends Qi { constructor(s) { super(s = { ...t.defaultOptions, ...s }), this.enabled = !0, this.je = se.for2d(), this.blendMode = s.blendMode, this.padding = s.padding, "boolean" == typeof s.antialias ? this.antialias = s.antialias ? "on" : "off" : this.antialias = s.antialias, this.resolution = s.resolution, this.blendRequired = s.blendRequired, this.clipToViewport = s.clipToViewport, this.addResource("uTexture", 0, 1), s.blendRequired && this.addResource("uBackTexture", 0, 3) } apply(t, s, i, e) { t.applyFilter(this, s, i, e) } get blendMode() { return this.je.blendMode } set blendMode(t) { this.je.blendMode = t } static from(s) { const { gpu: i, gl: e, ...n } = s; let r, o; return i && (r = Ni.from(i)), e && (o = Gi.from(e)), new t({ gpuProgram: r, glProgram: o, ...n }) } }; ie.defaultOptions = { blendMode: "normal", resolution: 1, padding: 0, antialias: "off", blendRequired: !1, clipToViewport: !0 }; let ee = ie; const ne = []; let re; function oe() { if ("boolean" == typeof re) return re; try { const t = new Function("param1", "param2", "param3", "return param1[param2] === param3;"); re = !0 === t({ a: "b" }, "a", "b") } catch (t) { re = !1 } return re } function he(t, s, i = 2) { const e = s && s.length, n = e ? s[0] * i : t.length; let r = ae(t, 0, n, i, !0); const o = []; if (!r || r.next === r.prev) return o; let h, a, u; if (e && (r = function (t, s, i, e) { const n = []; for (let r = 0, o = s.length; r < o; r++) { const i = ae(t, s[r] * e, r < o - 1 ? s[r + 1] * e : t.length, e, !1); i === i.next && (i.steiner = !0), n.push(xe(i)) } n.sort(me); for (let r = 0; r < n.length; r++)i = ge(n[r], i); return i }(t, s, r, i)), t.length > 80 * i) { h = t[0], a = t[1]; let s = h, e = a; for (let r = i; r < n; r += i) { const i = t[r], n = t[r + 1]; i < h && (h = i), n < a && (a = n), i > s && (s = i), n > e && (e = n) } u = Math.max(s - h, e - a), u = 0 !== u ? 32767 / u : 0 } return le(r, o, i, h, a, u, 0), o } function ae(t, s, i, e, n) { let r; if (n === function (t, s, i, e) { let n = 0; for (let r = s, o = i - e; r < i; r += e)n += (t[o] - t[r]) * (t[r + 1] + t[o + 1]), o = r; return n }(t, s, i, e) > 0) for (let o = s; o < i; o += e)r = Fe(o / e | 0, t[o], t[o + 1], r); else for (let o = i - e; o >= s; o -= e)r = Fe(o / e | 0, t[o], t[o + 1], r); return r && Ae(r, r.next) && (Ee(r), r = r.next), r } function ue(t, s) { if (!t) return t; s || (s = t); let i, e = t; do { if (i = !1, e.steiner || !Ae(e, e.next) && 0 !== Te(e.prev, e, e.next)) e = e.next; else { if (Ee(e), e = s = e.prev, e === e.next) break; i = !0 } } while (i || e !== s); return s } function le(t, s, i, e, n, r, o) { if (!t) return; !o && r && function (t, s, i, e) { let n = t; do { 0 === n.z && (n.z = be(n.x, n.y, s, i, e)), n.prevZ = n.prev, n.nextZ = n.next, n = n.next } while (n !== t); n.prevZ.nextZ = null, n.prevZ = null, function (t) { let s, i = 1; do { let e, n = t; t = null; let r = null; for (s = 0; n;) { s++; let o = n, h = 0; for (let t = 0; t < i && (h++, o = o.nextZ, o); t++); let a = i; for (; h > 0 || a > 0 && o;)0 !== h && (0 === a || !o || n.z <= o.z) ? (e = n, n = n.nextZ, h--) : (e = o, o = o.nextZ, a--), r ? r.nextZ = e : t = e, e.prevZ = r, r = e; n = o } r.nextZ = null, i *= 2 } while (s > 1) }(n) }(t, e, n, r); let h = t; for (; t.prev !== t.next;) { const a = t.prev, u = t.next; if (r ? fe(t, e, n, r) : ce(t)) s.push(a.i, t.i, u.i), Ee(t), t = u.next, h = u.next; else if ((t = u) === h) { o ? 1 === o ? le(t = de(ue(t), s), s, i, e, n, r, 2) : 2 === o && pe(t, s, i, e, n, r) : le(ue(t), s, i, e, n, r, 1); break } } } function ce(t) { const s = t.prev, i = t, e = t.next; if (Te(s, i, e) >= 0) return !1; const n = s.x, r = i.x, o = e.x, h = s.y, a = i.y, u = e.y, l = Math.min(n, r, o), c = Math.min(h, a, u), f = Math.max(n, r, o), d = Math.max(h, a, u); let p = e.next; for (; p !== s;) { if (p.x >= l && p.x <= f && p.y >= c && p.y <= d && we(n, h, r, a, o, u, p.x, p.y) && Te(p.prev, p, p.next) >= 0) return !1; p = p.next } return !0 } function fe(t, s, i, e) { const n = t.prev, r = t, o = t.next; if (Te(n, r, o) >= 0) return !1; const h = n.x, a = r.x, u = o.x, l = n.y, c = r.y, f = o.y, d = Math.min(h, a, u), p = Math.min(l, c, f), m = Math.max(h, a, u), g = Math.max(l, c, f), v = be(d, p, s, i, e), b = be(m, g, s, i, e); let x = t.prevZ, y = t.nextZ; for (; x && x.z >= v && y && y.z <= b;) { if (x.x >= d && x.x <= m && x.y >= p && x.y <= g && x !== n && x !== o && we(h, l, a, c, u, f, x.x, x.y) && Te(x.prev, x, x.next) >= 0) return !1; if (x = x.prevZ, y.x >= d && y.x <= m && y.y >= p && y.y <= g && y !== n && y !== o && we(h, l, a, c, u, f, y.x, y.y) && Te(y.prev, y, y.next) >= 0) return !1; y = y.nextZ } for (; x && x.z >= v;) { if (x.x >= d && x.x <= m && x.y >= p && x.y <= g && x !== n && x !== o && we(h, l, a, c, u, f, x.x, x.y) && Te(x.prev, x, x.next) >= 0) return !1; x = x.prevZ } for (; y && y.z <= b;) { if (y.x >= d && y.x <= m && y.y >= p && y.y <= g && y !== n && y !== o && we(h, l, a, c, u, f, y.x, y.y) && Te(y.prev, y, y.next) >= 0) return !1; y = y.nextZ } return !0 } function de(t, s) { let i = t; do { const e = i.prev, n = i.next.next; !Ae(e, n) && Ce(e, i, i.next, n) && Pe(e, n) && Pe(n, e) && (s.push(e.i, i.i, n.i), Ee(i), Ee(i.next), i = t = n), i = i.next } while (i !== t); return ue(i) } function pe(t, s, i, e, n, r) { let o = t; do { let t = o.next.next; for (; t !== o.prev;) { if (o.i !== t.i && Me(o, t)) { let h = ke(o, t); return o = ue(o, o.next), h = ue(h, h.next), le(o, s, i, e, n, r, 0), void le(h, s, i, e, n, r, 0) } t = t.next } o = o.next } while (o !== t) } function me(t, s) { let i = t.x - s.x; return 0 === i && (i = t.y - s.y, 0 === i) && (i = (t.next.y - t.y) / (t.next.x - t.x) - (s.next.y - s.y) / (s.next.x - s.x)), i } function ge(t, s) { const i = function (t, s) { let i = s; const e = t.x, n = t.y; let r, o = -1 / 0; if (Ae(t, i)) return i; do { if (Ae(t, i.next)) return i.next; if (n <= i.y && n >= i.next.y && i.next.y !== i.y) { const t = i.x + (n - i.y) * (i.next.x - i.x) / (i.next.y - i.y); if (t <= e && t > o && (o = t, r = i.x < i.next.x ? i : i.next, t === e)) return r } i = i.next } while (i !== s); if (!r) return null; const h = r, a = r.x, u = r.y; let l = 1 / 0; i = r; do { if (e >= i.x && i.x >= a && e !== i.x && ye(n < u ? e : o, n, a, u, n < u ? o : e, n, i.x, i.y)) { const s = Math.abs(n - i.y) / (e - i.x); Pe(i, t) && (s < l || s === l && (i.x > r.x || i.x === r.x && ve(r, i))) && (r = i, l = s) } i = i.next } while (i !== h); return r }(t, s); if (!i) return s; const e = ke(i, t); return ue(e, e.next), ue(i, i.next) } function ve(t, s) { return Te(t.prev, t, s.prev) < 0 && Te(s.next, t, t.next) < 0 } function be(t, s, i, e, n) { return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = (t - i) * n | 0) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (s = 1431655765 & ((s = 858993459 & ((s = 252645135 & ((s = 16711935 & ((s = (s - e) * n | 0) | s << 8)) | s << 4)) | s << 2)) | s << 1)) << 1 } function xe(t) { let s = t, i = t; do { (s.x < i.x || s.x === i.x && s.y < i.y) && (i = s), s = s.next } while (s !== t); return i } function ye(t, s, i, e, n, r, o, h) { return (n - o) * (s - h) >= (t - o) * (r - h) && (t - o) * (e - h) >= (i - o) * (s - h) && (i - o) * (r - h) >= (n - o) * (e - h) } function we(t, s, i, e, n, r, o, h) { return !(t === o && s === h) && ye(t, s, i, e, n, r, o, h) } function Me(t, s) { return t.next.i !== s.i && t.prev.i !== s.i && !function (t, s) { let i = t; do { if (i.i !== t.i && i.next.i !== t.i && i.i !== s.i && i.next.i !== s.i && Ce(i, i.next, t, s)) return !0; i = i.next } while (i !== t); return !1 }(t, s) && (Pe(t, s) && Pe(s, t) && function (t, s) { let i = t, e = !1; const n = (t.x + s.x) / 2, r = (t.y + s.y) / 2; do { i.y > r != i.next.y > r && i.next.y !== i.y && n < (i.next.x - i.x) * (r - i.y) / (i.next.y - i.y) + i.x && (e = !e), i = i.next } while (i !== t); return e }(t, s) && (Te(t.prev, t, s.prev) || Te(t, s.prev, s)) || Ae(t, s) && Te(t.prev, t, t.next) > 0 && Te(s.prev, s, s.next) > 0) } function Te(t, s, i) { return (s.y - t.y) * (i.x - s.x) - (s.x - t.x) * (i.y - s.y) } function Ae(t, s) { return t.x === s.x && t.y === s.y } function Ce(t, s, i, e) { const n = Se(Te(t, s, i)), r = Se(Te(t, s, e)), o = Se(Te(i, e, t)), h = Se(Te(i, e, s)); return n !== r && o !== h || !(0 !== n || !_e(t, i, s)) || !(0 !== r || !_e(t, e, s)) || !(0 !== o || !_e(i, t, e)) || !(0 !== h || !_e(i, s, e)) } function _e(t, s, i) { return s.x <= Math.max(t.x, i.x) && s.x >= Math.min(t.x, i.x) && s.y <= Math.max(t.y, i.y) && s.y >= Math.min(t.y, i.y) } function Se(t) { return t > 0 ? 1 : t < 0 ? -1 : 0 } function Pe(t, s) { return Te(t.prev, t, t.next) < 0 ? Te(t, s, t.next) >= 0 && Te(t, t.prev, s) >= 0 : Te(t, s, t.prev) < 0 || Te(t, t.next, s) < 0 } function ke(t, s) { const i = Re(t.i, t.x, t.y), e = Re(s.i, s.x, s.y), n = t.next, r = s.prev; return t.next = s, s.prev = t, i.next = n, n.prev = i, e.next = i, i.prev = e, r.next = e, e.prev = r, e } function Fe(t, s, i, e) { const n = Re(t, s, i); return e ? (n.next = e.next, n.prev = e, e.next.prev = n, e.next = n) : (n.prev = n, n.next = n), n } function Ee(t) { t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ) } function Re(t, s, i) { return { i: t, x: s, y: i, prev: null, next: null, z: 0, prevZ: null, nextZ: null, steiner: !1 } } a.handleByNamedList(r.Environment, ne); const Oe = he.default || he; var Ue = (t => (t[t.NONE = 0] = "NONE", t[t.COLOR = 16384] = "COLOR", t[t.STENCIL = 1024] = "STENCIL", t[t.DEPTH = 256] = "DEPTH", t[t.COLOR_DEPTH = 16640] = "COLOR_DEPTH", t[t.COLOR_STENCIL = 17408] = "COLOR_STENCIL", t[t.DEPTH_STENCIL = 1280] = "DEPTH_STENCIL", t[t.ALL = 17664] = "ALL", t))(Ue || {}); class Ie { constructor(t) { this.items = [], this.Le = t } emit(t, s, i, e, n, r, o, h) { const { name: a, items: u } = this; for (let l = 0, c = u.length; l < c; l++)u[l][a](t, s, i, e, n, r, o, h); return this } add(t) { return t[this.Le] && (this.remove(t), this.items.push(t)), this } remove(t) { const s = this.items.indexOf(t); return -1 !== s && this.items.splice(s, 1), this } contains(t) { return -1 !== this.items.indexOf(t) } removeAll() { return this.items.length = 0, this } destroy() { this.removeAll(), this.items = null, this.Le = null } get empty() { return 0 === this.items.length } get name() { return this.Le } } const Be = ["init", "destroy", "contextChange", "resolutionChange", "resetState", "renderEnd", "renderStart", "render", "update", "postrender", "prerender"], Ge = class t extends m { constructor(t) { super(), this.uid = I("renderer"), this.runners = Object.create(null), this.renderPipes = Object.create(null), this.Ve = {}, this.Ne = Object.create(null), this.type = t.type, this.name = t.name, this.config = t; const s = [...Be, ...this.config.runners ?? []]; this.We(...s), this.He() } async init(s = {}) { const i = !0 === s.skipExtensionImports || !1 === s.manageImports; await async function (t) { if (!t) for (let s = 0; s < ne.length; s++) { const t = ne[s]; if (t.value.test()) return void (await t.value.load()) } }(i), this.qe(this.config.systems), this.Xe(this.config.renderPipes, this.config.renderPipeAdaptors); for (const t in this.Ne) s = { ...this.Ne[t].constructor.defaultOptions, ...s }; s = { ...t.defaultOptions, ...s }, this.fs = s.roundPixels ? 1 : 0; for (let t = 0; t < this.runners.init.items.length; t++)await this.runners.init.items[t].init(s); this.Ve = s } render(t, s) { let i = t; if (i instanceof bs && (i = { container: i }, s && ($(0, "passing a second argument is deprecated, please use render options instead"), i.target = s.renderTexture)), i.target || (i.target = this.view.renderTarget), i.target === this.view.renderTarget && (this.Ye = i.container, i.clearColor ?? (i.clearColor = this.background.colorRgba), i.clear ?? (i.clear = this.background.clearBeforeRender)), i.clearColor) { const t = Array.isArray(i.clearColor) && 4 === i.clearColor.length; i.clearColor = t ? i.clearColor : kt.shared.setValue(i.clearColor).toArray() } i.transform || (i.container.updateLocalTransform(), i.transform = i.container.localTransform), i.container.visible && (i.container.enableRenderGroup(), this.runners.prerender.emit(i), this.runners.renderStart.emit(i), this.runners.render.emit(i), this.runners.renderEnd.emit(i), this.runners.postrender.emit(i)) } resize(t, s, i) { const e = this.view.resolution; this.view.resize(t, s, i), this.emit("resize", this.view.screen.width, this.view.screen.height, this.view.resolution), void 0 !== i && i !== e && this.runners.resolutionChange.emit(i) } clear(t = {}) { t.target || (t.target = this.renderTarget.renderTarget), t.clearColor || (t.clearColor = this.background.colorRgba), t.clear ?? (t.clear = Ue.ALL); const { clear: s, clearColor: i, target: e } = t; kt.shared.setValue(i ?? this.background.colorRgba), this.renderTarget.clear(e, s, kt.shared.toArray()) } get resolution() { return this.view.resolution } set resolution(t) { this.view.resolution = t, this.runners.resolutionChange.emit(t) } get width() { return this.view.texture.frame.width } get height() { return this.view.texture.frame.height } get canvas() { return this.view.canvas } get lastObjectRendered() { return this.Ye } get renderingToScreen() { return this.renderTarget.renderingToScreen } get screen() { return this.view.screen } We(...t) { t.forEach(t => { this.runners[t] = new Ie(t) }) } qe(t) { let s; for (s in t) { const i = t[s]; this.Ke(i.value, i.name) } } Ke(t, s) { const i = new t(this); if (this[s]) throw new Error(`Whoops! The name "${s}" is already in use`); this[s] = i, this.Ne[s] = i; for (const e in this.runners) this.runners[e].add(i); return this } Xe(t, s) { const i = s.reduce((t, s) => (t[s.name] = s.value, t), {}); t.forEach(t => { const s = t.value, e = t.name, n = i[e]; this.renderPipes[e] = new s(this, n ? new n : null), this.runners.destroy.add(this.renderPipes[e]) }) } destroy(t = !1) { this.runners.destroy.items.reverse(), this.runners.destroy.emit(t), (!0 === t || "object" == typeof t && t.releaseGlobalResources) && Rt.release(), Object.values(this.runners).forEach(t => { t.destroy() }), this.Ne = null, this.renderPipes = null } generateTexture(t) { return this.textureGenerator.generateTexture(t) } get roundPixels() { return !!this.fs } He() { if (!oe()) throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.") } resetState() { this.runners.resetState.emit() } }; Ge.defaultOptions = { resolution: 1, failIfMajorPerformanceCaveat: !1, roundPixels: !1 }; let $e, ze, De = Ge; function je(t) { return void 0 !== $e || ($e = (() => { const s = { stencil: !0, failIfMajorPerformanceCaveat: t ?? De.defaultOptions.failIfMajorPerformanceCaveat }; try { if (!ks.get().getWebGLRenderingContext()) return !1; let t = ks.get().createCanvas().getContext("webgl", s); const i = !!t?.getContextAttributes()?.stencil; if (t) { const s = t.getExtension("WEBGL_lose_context"); s && s.loseContext() } return t = null, i } catch (i) { return !1 } })()), $e } async function Le(t = {}) { return void 0 !== ze || (ze = await (async () => { const s = ks.get().getNavigator().gpu; if (!s) return !1; try { const i = await s.requestAdapter(t); return await i.requestDevice(), !0 } catch (i) { return !1 } })()), ze } const Ve = ["webgl", "webgpu", "canvas"], Ne = "8.14.3"; class We { static init() { globalThis.__PIXI_APP_INIT__?.(this, Ne) } static destroy() { } } We.extension = r.Application; class He { constructor(t) { this.Gi = t } init() { globalThis.__PIXI_RENDERER_INIT__?.(this.Gi, Ne) } destroy() { this.Gi = null } } He.extension = { type: [r.WebGLSystem, r.WebGPUSystem], name: "initHook", priority: -10 }; const qe = class t { constructor(...t) { this.stage = new bs, void 0 !== t[0] && $(0, "Application constructor options are deprecated, please use Application.init() instead.") } async init(s) { s = { ...s }, this.stage || (this.stage = new bs), this.renderer = await async function (t) { let s, i = []; t.preference ? (i.push(t.preference), Ve.forEach(s => { s !== t.preference && i.push(s) })) : i = Ve.slice(); let e = {}; for (let o = 0; o < i.length; o++) { const r = i[o]; if ("webgpu" === r && await Le()) { const { WebGPURenderer: i } = await n(async () => { const { WebGPURenderer: t } = await Promise.resolve().then(() => jl); return { WebGPURenderer: t } }, void 0, import.meta.url); s = i, e = { ...t, ...t.webgpu }; break } if ("webgl" === r && je(t.failIfMajorPerformanceCaveat ?? De.defaultOptions.failIfMajorPerformanceCaveat)) { const { WebGLRenderer: i } = await n(async () => { const { WebGLRenderer: t } = await Promise.resolve().then(() => sl); return { WebGLRenderer: t } }, void 0, import.meta.url); s = i, e = { ...t, ...t.webgl }; break } if ("canvas" === r) throw e = { ...t }, new Error("CanvasRenderer is not yet implemented") } if (delete e.webgpu, delete e.webgl, !s) throw new Error("No available renderer for the current environment"); const r = new s; return await r.init(e), r }(s), t.Ze.forEach(t => { t.init.call(this, s) }) } render() { this.renderer.render({ container: this.stage }) } get canvas() { return this.renderer.canvas } get view() { return $(0, "Application.view is deprecated, please use Application.canvas instead."), this.renderer.canvas } get screen() { return this.renderer.screen } destroy(s = !1, i = !1) { const e = t.Ze.slice(0); e.reverse(), e.forEach(t => { t.destroy.call(this) }), this.stage.destroy(i), this.stage = null, this.renderer.destroy(s), this.renderer = null } }; qe.Ze = []; let Xe = qe; a.handleByList(r.Application, Xe.Ze), a.add(We); class Ye { static init(t) { Object.defineProperty(this, "resizeTo", { configurable: !0, set(t) { globalThis.removeEventListener("resize", this.queueResize), this.Qe = t, t && (globalThis.addEventListener("resize", this.queueResize), this.resize()) }, get() { return this.Qe } }), this.queueResize = () => { this.Qe && (this.Je(), this.tn = requestAnimationFrame(() => this.resize())) }, this.Je = () => { this.tn && (cancelAnimationFrame(this.tn), this.tn = null) }, this.resize = () => { if (!this.Qe) return; let t, s; if (this.Je(), this.Qe === globalThis.window) t = globalThis.innerWidth, s = globalThis.innerHeight; else { const { clientWidth: i, clientHeight: e } = this.Qe; t = i, s = e } this.renderer.resize(t, s), this.render() }, this.tn = null, this.Qe = null, this.resizeTo = t.resizeTo || null } static destroy() { globalThis.removeEventListener("resize", this.queueResize), this.Je(), this.Je = null, this.queueResize = null, this.resizeTo = null, this.resize = null } } Ye.extension = r.Application; class Ke { static init(t) { t = Object.assign({ autoStart: !0, sharedTicker: !1 }, t), Object.defineProperty(this, "ticker", { configurable: !0, set(t) { this.sn && this.sn.remove(this.render, this), this.sn = t, t && t.add(this.render, this, Rs.LOW) }, get() { return this.sn } }), this.stop = () => { this.sn.stop() }, this.start = () => { this.sn.start() }, this.sn = null, this.ticker = t.sharedTicker ? Bs.shared : new Bs, t.autoStart && this.start() } static destroy() { if (this.sn) { const t = this.sn; this.ticker = null, t.destroy() } } } Ke.extension = r.Application; class Ze extends m { constructor() { super(...arguments), this.chars = Object.create(null), this.lineHeight = 0, this.fontFamily = "", this.fontMetrics = { fontSize: 0, ascent: 0, descent: 0 }, this.baseLineOffset = 0, this.distanceField = { type: "none", range: 0 }, this.pages = [], this.applyFillAsTint = !0, this.baseMeasurementFontSize = 100, this.baseRenderedFontSize = 100 } get font() { return $(0, "BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead."), this.fontFamily } get pageTextures() { return $(0, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."), this.pages } get size() { return $(0, "BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead."), this.fontMetrics.fontSize } get distanceFieldRange() { return $(0, "BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead."), this.distanceField.range } get distanceFieldType() { return $(0, "BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead."), this.distanceField.type } destroy(t = !1) { this.emit("destroy", this), this.removeAllListeners(); for (const s in this.chars) this.chars[s].texture?.destroy(); this.chars = null, t && (this.pages.forEach(t => t.texture.destroy(!0)), this.pages = null) } } class Qe { constructor(t = 0, s = 0, i = !1) { this.first = null, this.items = Object.create(null), this.last = null, this.max = t, this.resetTtl = i, this.size = 0, this.ttl = s } clear() { return this.first = null, this.items = Object.create(null), this.last = null, this.size = 0, this } delete(t) { if (this.has(t)) { const s = this.items[t]; delete this.items[t], this.size--, null !== s.prev && (s.prev.next = s.next), null !== s.next && (s.next.prev = s.prev), this.first === s && (this.first = s.next), this.last === s && (this.last = s.prev) } return this } entries(t = this.keys()) { return t.map(t => [t, this.get(t)]) } evict(t = !1) { if (t || this.size > 0) { const t = this.first; delete this.items[t.key], 0 === --this.size ? (this.first = null, this.last = null) : (this.first = t.next, this.first.prev = null) } return this } expiresAt(t) { let s; return this.has(t) && (s = this.items[t].expiry), s } get(t) { const s = this.items[t]; if (void 0 !== s) return this.ttl > 0 && s.expiry <= Date.now() ? void this.delete(t) : (this.moveToEnd(s), s.value) } has(t) { return t in this.items } moveToEnd(t) { this.last !== t && (null !== t.prev && (t.prev.next = t.next), null !== t.next && (t.next.prev = t.prev), this.first === t && (this.first = t.next), t.prev = this.last, t.next = null, null !== this.last && (this.last.next = t), this.last = t, null === this.first && (this.first = t)) } keys() { const t = []; let s = this.first; for (; null !== s;)t.push(s.key), s = s.next; return t } setWithEvicted(t, s, i = this.resetTtl) { let e = null; if (this.has(t)) this.set(t, s, !0, i); else { this.max > 0 && this.size === this.max && (e = { ...this.first }, this.evict(!0)); let i = this.items[t] = { expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl, key: t, prev: this.last, next: null, value: s }; 1 === ++this.size ? this.first = i : this.last.next = i, this.last = i } return e } set(t, s, i = !1, e = this.resetTtl) { let n = this.items[t]; return i || void 0 !== n ? (n.value = s, !1 === i && e && (n.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl), this.moveToEnd(n)) : (this.max > 0 && this.size === this.max && this.evict(!0), n = this.items[t] = { expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl, key: t, prev: this.last, next: null, value: s }, 1 === ++this.size ? this.first = n : this.last.next = n, this.last = n), this } values(t = this.keys()) { return t.map(t => this.get(t)) } } function Je(t = 1e3, s = 0, i = !1) { if (isNaN(t) || t < 0) throw new TypeError("Invalid max value"); if (isNaN(s) || s < 0) throw new TypeError("Invalid ttl value"); if ("boolean" != typeof i) throw new TypeError("Invalid resetTtl value"); return new Qe(t, s, i) } const tn = ["serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui"]; function sn(t) { const s = "number" == typeof t.fontSize ? `${t.fontSize}px` : t.fontSize; let i = t.fontFamily; Array.isArray(t.fontFamily) || (i = t.fontFamily.split(",")); for (let e = i.length - 1; e >= 0; e--) { let t = i[e].trim(); /([\"\'])[^\'\"]+\1/.test(t) || tn.includes(t) || (t = `"${t}"`), i[e] = t } return `${t.fontStyle} ${t.fontVariant} ${t.fontWeight} ${s} ${i.join(",")}` } const en = { willReadFrequently: !0 }, nn = class t { static get experimentalLetterSpacingSupported() { let s = t.en; if (void 0 === s) { const i = ks.get().getCanvasRenderingContext2D().prototype; s = t.en = "letterSpacing" in i || "textLetterSpacing" in i } return s } constructor(t, s, i, e, n, r, o, h, a) { this.text = t, this.style = s, this.width = i, this.height = e, this.lines = n, this.lineWidths = r, this.lineHeight = o, this.maxLineWidth = h, this.fontProperties = a } static measureText(s = " ", i, e = t.Bi, n = i.wordWrap) { const r = `${s}-${i.styleKey}-wordWrap-${n}`; if (t.nn.has(r)) return t.nn.get(r); const o = sn(i), h = t.measureFont(o); 0 === h.fontSize && (h.fontSize = i.fontSize, h.ascent = i.fontSize); const a = t.rn; a.font = o; const u = (n ? t.hn(s, i, e) : s).split(/(?:\r\n|\r|\n)/), l = new Array(u.length); let c = 0; for (let v = 0; v < u.length; v++) { const s = t.an(u[v], i.letterSpacing, a); l[v] = s, c = Math.max(c, s) } const f = i.un?.width || 0; let d = c + f; i.dropShadow && (d += i.dropShadow.distance); const p = i.lineHeight || h.fontSize; let m = Math.max(p, h.fontSize + f) + (u.length - 1) * (p + i.leading); i.dropShadow && (m += i.dropShadow.distance); const g = new t(s, i, d, m, u, l, p + i.leading, c, h); return t.nn.set(r, g), g } static an(s, i, e) { let n = !1; t.experimentalLetterSpacingSupported && (t.experimentalLetterSpacing ? (e.letterSpacing = `${i}px`, e.textLetterSpacing = `${i}px`, n = !0) : (e.letterSpacing = "0px", e.textLetterSpacing = "0px")); const r = e.measureText(s); let o = r.width; const h = -r.actualBoundingBoxLeft; let a = r.actualBoundingBoxRight - h; if (o > 0) if (n) o -= i, a -= i; else { const e = (t.graphemeSegmenter(s).length - 1) * i; o += e, a += e } return Math.max(o, a) } static hn(s, i, e = t.Bi) { const n = e.getContext("2d", en); let r = 0, o = "", h = ""; const a = Object.create(null), { letterSpacing: u, whiteSpace: l } = i, c = t.ln(l), f = t.cn(l); let d = !c; const p = i.wordWrapWidth + u, m = t.dn(s); for (let g = 0; g < m.length; g++) { let s = m[g]; if (t.pn(s)) { if (!f) { h += t.mn(o), d = !c, o = "", r = 0; continue } s = " " } if (c) { const i = t.isBreakingSpace(s), e = t.isBreakingSpace(o[o.length - 1]); if (i && e) continue } const e = t.gn(s, u, a, n); if (e > p) if ("" !== o && (h += t.mn(o), o = "", r = 0), t.canBreakWords(s, i.breakWords)) { const e = t.wordWrapSplit(s); for (let l = 0; l < e.length; l++) { let c = e[l], f = c, m = 1; for (; e[l + m];) { const n = e[l + m]; if (t.canBreakChars(f, n, s, l, i.breakWords)) break; c += n, f = n, m++ } l += m - 1; const g = t.gn(c, u, a, n); g + r > p && (h += t.mn(o), d = !1, o = "", r = 0), o += c, r += g } } else { o.length > 0 && (h += t.mn(o), o = "", r = 0); const i = g === m.length - 1; h += t.mn(s, !i), d = !1, o = "", r = 0 } else e + r > p && (d = !1, h += t.mn(o), o = "", r = 0), (o.length > 0 || !t.isBreakingSpace(s) || d) && (o += s, r += e) } return h += t.mn(o, !1), h } static mn(s, i = !0) { return s = t.vn(s), i ? `${s}\n` : s } static gn(s, i, e, n) { let r = e[s]; return "number" != typeof r && (r = t.an(s, i, n) + i, e[s] = r), r } static ln(t) { return "normal" === t || "pre-line" === t } static cn(t) { return "normal" === t } static vn(s) { if ("string" != typeof s) return ""; for (let i = s.length - 1; i >= 0; i--) { const e = s[i]; if (!t.isBreakingSpace(e)) break; s = s.slice(0, -1) } return s } static pn(s) { return "string" == typeof s && t.bn.includes(s.charCodeAt(0)) } static isBreakingSpace(s, i) { return "string" == typeof s && t.xn.includes(s.charCodeAt(0)) } static dn(s) { const i = []; let e = ""; if ("string" != typeof s) return i; for (let n = 0; n < s.length; n++) { const r = s[n], o = s[n + 1]; t.isBreakingSpace(r, o) || t.pn(r) ? ("" !== e && (i.push(e), e = ""), "\r" === r && "\n" === o ? (i.push("\r\n"), n++) : i.push(r)) : e += r } return "" !== e && i.push(e), i } static canBreakWords(t, s) { return s } static canBreakChars(t, s, i, e, n) { return !0 } static wordWrapSplit(s) { return t.graphemeSegmenter(s) } static measureFont(s) { if (t.yn[s]) return t.yn[s]; const i = t.Cs; i.font = s; const e = i.measureText(t.METRICS_STRING + t.BASELINE_SYMBOL), n = { ascent: e.actualBoundingBoxAscent, descent: e.actualBoundingBoxDescent, fontSize: e.actualBoundingBoxAscent + e.actualBoundingBoxDescent }; return t.yn[s] = n, n } static clearMetrics(s = "") { s ? delete t.yn[s] : t.yn = {} } static get Bi() { if (!t.wn) { let i; try { const s = new OffscreenCanvas(0, 0), e = s.getContext("2d", en); if (e?.measureText) return t.wn = s, s; i = ks.get().createCanvas() } catch (s) { i = ks.get().createCanvas() } i.width = i.height = 10, t.wn = i } return t.wn } static get Cs() { return t.rn || (t.rn = t.Bi.getContext("2d", en)), t.rn } }; nn.METRICS_STRING = "|q", nn.BASELINE_SYMBOL = "M", nn.BASELINE_MULTIPLIER = 1.4, nn.HEIGHT_MULTIPLIER = 2, nn.graphemeSegmenter = (() => { if ("function" == typeof Intl?.Segmenter) { const t = new Intl.Segmenter; return s => { const i = t.segment(s), e = []; let n = 0; for (const t of i) e[n++] = t.segment; return e } } return t => [...t] })(), nn.experimentalLetterSpacing = !1, nn.yn = {}, nn.bn = [10, 13], nn.xn = [9, 32, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8200, 8201, 8202, 8287, 12288], nn.nn = Je(1e3); let rn = nn; const on = [{ offset: 0, color: "white" }, { offset: 1, color: "black" }], hn = class t { constructor(...s) { this.uid = I("fillGradient"), this.Os = 0, this.type = "linear", this.colorStops = []; let i = function (t) { let s = t[0] ?? {}; return ("number" == typeof s || t[1]) && ($(0, "use options object instead"), s = { type: "linear", start: { x: t[0], y: t[1] }, end: { x: t[2], y: t[3] }, textureSpace: t[4], textureSize: t[5] ?? an.defaultLinearOptions.textureSize }), s }(s); i = { ..."radial" === i.type ? t.defaultRadialOptions : t.defaultLinearOptions, ...L(i) }, this.Mn = i.textureSize, this.Tn = i.wrapMode, "radial" === i.type ? (this.center = i.center, this.outerCenter = i.outerCenter ?? this.center, this.innerRadius = i.innerRadius, this.outerRadius = i.outerRadius, this.scale = i.scale, this.rotation = i.rotation) : (this.start = i.start, this.end = i.end), this.textureSpace = i.textureSpace, this.type = i.type, i.colorStops.forEach(t => { this.addColorStop(t.offset, t.color) }) } addColorStop(t, s) { return this.colorStops.push({ offset: t, color: kt.shared.setValue(s).toHexa() }), this } buildLinearGradient() { if (this.texture) return; let { x: t, y: s } = this.start, { x: i, y: e } = this.end, n = i - t, r = e - s; const o = n < 0 || r < 0; if ("clamp-to-edge" === this.Tn) { if (n < 0) { const s = t; t = i, i = s, n *= -1 } if (r < 0) { const t = s; s = e, e = t, r *= -1 } } const h = this.colorStops.length ? this.colorStops : on, a = this.Mn, { canvas: u, context: l } = ln(a, 1), c = o ? l.createLinearGradient(this.Mn, 0, 0, 0) : l.createLinearGradient(0, 0, this.Mn, 0); un(c, h), l.fillStyle = c, l.fillRect(0, 0, a, 1), this.texture = new Z({ source: new Es({ resource: u, addressMode: this.Tn }) }); const f = Math.sqrt(n * n + r * r), d = Math.atan2(r, n), p = new w; p.scale(f / a, 1), p.rotate(d), p.translate(t, s), "local" === this.textureSpace && p.scale(a, a), this.transform = p } buildGradient() { this.texture || this.Os++, "linear" === this.type ? this.buildLinearGradient() : this.buildRadialGradient() } buildRadialGradient() { if (this.texture) return; const t = this.colorStops.length ? this.colorStops : on, s = this.Mn, { canvas: i, context: e } = ln(s, s), { x: n, y: r } = this.center, { x: o, y: h } = this.outerCenter, a = this.innerRadius, u = this.outerRadius, l = o - u, c = h - u, f = s / (2 * u), d = (n - l) * f, p = (r - c) * f, m = e.createRadialGradient(d, p, a * f, (o - l) * f, (h - c) * f, u * f); un(m, t), e.fillStyle = t[t.length - 1].color, e.fillRect(0, 0, s, s), e.fillStyle = m, e.translate(d, p), e.rotate(this.rotation), e.scale(1, this.scale), e.translate(-d, -p), e.fillRect(0, 0, s, s), this.texture = new Z({ source: new Es({ resource: i, addressMode: this.Tn }) }); const g = new w; g.scale(1 / f, 1 / f), g.translate(l, c), "local" === this.textureSpace && g.scale(s, s), this.transform = g } destroy() { this.texture?.destroy(!0), this.texture = null, this.transform = null, this.colorStops = [], this.start = null, this.end = null, this.center = null, this.outerCenter = null } get styleKey() { return `fill-gradient-${this.uid}-${this.Os}` } }; hn.defaultLinearOptions = { start: { x: 0, y: 0 }, end: { x: 0, y: 1 }, colorStops: [], textureSpace: "local", type: "linear", textureSize: 256, wrapMode: "clamp-to-edge" }, hn.defaultRadialOptions = { center: { x: .5, y: .5 }, innerRadius: 0, outerRadius: .5, colorStops: [], scale: 1, textureSpace: "local", type: "radial", textureSize: 256, wrapMode: "clamp-to-edge" }; let an = hn; function un(t, s) { for (let i = 0; i < s.length; i++) { const e = s[i]; t.addColorStop(e.offset, e.color) } } function ln(t, s) { const i = ks.get().createCanvas(t, s), e = i.getContext("2d"); return { canvas: i, context: e } } const cn = { repeat: { addressModeU: "repeat", addressModeV: "repeat" }, "repeat-x": { addressModeU: "repeat", addressModeV: "clamp-to-edge" }, "repeat-y": { addressModeU: "clamp-to-edge", addressModeV: "repeat" }, "no-repeat": { addressModeU: "clamp-to-edge", addressModeV: "clamp-to-edge" } }; class fn { constructor(t, s) { this.uid = I("fillPattern"), this.Os = 0, this.transform = new w, this.texture = t, this.transform.scale(1 / t.frame.width, 1 / t.frame.height), s && (t.source.style.addressModeU = cn[s].addressModeU, t.source.style.addressModeV = cn[s].addressModeV) } setTransform(t) { const s = this.texture; this.transform.copyFrom(t), this.transform.invert(), this.transform.scale(1 / s.frame.width, 1 / s.frame.height), this.Os++ } get texture() { return this.Y } set texture(t) { this.Y !== t && (this.Y = t, this.Os++) } get styleKey() { return `fill-pattern-${this.uid}-${this.Os}` } destroy() { this.texture.destroy(!0), this.texture = null } } var dn, pn; const mn = f(function () { if (pn) return dn; pn = 1, dn = function (e) { var n = []; return e.replace(s, function (s, e, r) { var o = e.toLowerCase(); for (r = function (t) { var s = t.match(i); return s ? s.map(Number) : [] }(r), "m" == o && r.length > 2 && (n.push([e].concat(r.splice(0, 2))), o = "l", e = "m" == e ? "l" : "L"); ;) { if (r.length == t[o]) return r.unshift(e), n.push(r); if (r.length < t[o]) throw new Error("malformed path data"); n.push([e].concat(r.splice(0, t[o]))) } }), n }; var t = { a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0 }, s = /([astvzqmhlc])([^astvzqmhlc]*)/gi, i = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/gi; return dn }()); class gn { constructor(t = 0, s = 0, i = 0) { this.type = "circle", this.x = t, this.y = s, this.radius = i } clone() { return new gn(this.x, this.y, this.radius) } contains(t, s) { if (this.radius <= 0) return !1; const i = this.radius * this.radius; let e = this.x - t, n = this.y - s; return e *= e, n *= n, e + n <= i } strokeContains(t, s, i, e = .5) { if (0 === this.radius) return !1; const n = this.x - t, r = this.y - s, o = this.radius, h = (1 - e) * i, a = Math.sqrt(n * n + r * r); return a <= o + h && a > o - (i - h) } getBounds(t) { return t || (t = new O), t.x = this.x - this.radius, t.y = this.y - this.radius, t.width = 2 * this.radius, t.height = 2 * this.radius, t } copyFrom(t) { return this.x = t.x, this.y = t.y, this.radius = t.radius, this } copyTo(t) { return t.copyFrom(this), t } toString() { return `[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]` } } class vn { constructor(t = 0, s = 0, i = 0, e = 0) { this.type = "ellipse", this.x = t, this.y = s, this.halfWidth = i, this.halfHeight = e } clone() { return new vn(this.x, this.y, this.halfWidth, this.halfHeight) } contains(t, s) { if (this.halfWidth <= 0 || this.halfHeight <= 0) return !1; let i = (t - this.x) / this.halfWidth, e = (s - this.y) / this.halfHeight; return i *= i, e *= e, i + e <= 1 } strokeContains(t, s, i, e = .5) { const { halfWidth: n, halfHeight: r } = this; if (n <= 0 || r <= 0) return !1; const o = i * (1 - e), h = i - o, a = n - h, u = r - h, l = n + o, c = r + o, f = t - this.x, d = s - this.y; return f * f / (a * a) + d * d / (u * u) > 1 && f * f / (l * l) + d * d / (c * c) <= 1 } getBounds(t) { return t || (t = new O), t.x = this.x - this.halfWidth, t.y = this.y - this.halfHeight, t.width = 2 * this.halfWidth, t.height = 2 * this.halfHeight, t } copyFrom(t) { return this.x = t.x, this.y = t.y, this.halfWidth = t.halfWidth, this.halfHeight = t.halfHeight, this } copyTo(t) { return t.copyFrom(this), t } toString() { return `[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]` } } function bn(t, s, i, e, n, r) { const o = n - i, h = r - e, a = o * o + h * h; let u, l, c = -1; 0 !== a && (c = ((t - i) * o + (s - e) * h) / a), c < 0 ? (u = i, l = e) : c > 1 ? (u = n, l = r) : (u = i + c * o, l = e + c * h); const f = t - u, d = s - l; return f * f + d * d } class xn { constructor(...t) { this.type = "polygon"; let s = Array.isArray(t[0]) ? t[0] : t; if ("number" != typeof s[0]) { const t = []; for (let i = 0, e = s.length; i < e; i++)t.push(s[i].x, s[i].y); s = t } this.points = s, this.closePath = !0 } isClockwise() { let t = 0; const s = this.points, i = s.length; for (let e = 0; e < i; e += 2) { const n = s[e], r = s[e + 1]; t += (s[(e + 2) % i] - n) * (s[(e + 3) % i] + r) } return t < 0 } containsPolygon(t) { const s = this.getBounds(void 0), i = t.getBounds(void 0); if (!s.containsRect(i)) return !1; const e = t.points; for (let n = 0; n < e.length; n += 2) { const t = e[n], s = e[n + 1]; if (!this.contains(t, s)) return !1 } return !0 } clone() { const t = this.points.slice(), s = new xn(t); return s.closePath = this.closePath, s } contains(t, s) { let i = !1; const e = this.points.length / 2; for (let n = 0, r = e - 1; n < e; r = n++) { const e = this.points[2 * n], o = this.points[2 * n + 1], h = this.points[2 * r], a = this.points[2 * r + 1]; o > s != a > s && t < (s - o) / (a - o) * (h - e) + e && (i = !i) } return i } strokeContains(t, s, i, e = .5) { const n = i * i, r = n * (1 - e), o = n - r, { points: h } = this, a = h.length - (this.closePath ? 0 : 2); for (let u = 0; u < a; u += 2) { const i = h[u], e = h[u + 1], n = h[(u + 2) % h.length], a = h[(u + 3) % h.length]; if (bn(t, s, i, e, n, a) <= (Math.sign((n - i) * (s - e) - (a - e) * (t - i)) < 0 ? o : r)) return !0 } return !1 } getBounds(t) { t || (t = new O); const s = this.points; let i = 1 / 0, e = -1 / 0, n = 1 / 0, r = -1 / 0; for (let o = 0, h = s.length; o < h; o += 2) { const t = s[o], h = s[o + 1]; i = t < i ? t : i, e = t > e ? t : e, n = h < n ? h : n, r = h > r ? h : r } return t.x = i, t.width = e - i, t.y = n, t.height = r - n, t } copyFrom(t) { return this.points = t.points.slice(), this.closePath = t.closePath, this } copyTo(t) { return t.copyFrom(this), t } toString() { return `[pixi.js/math:PolygoncloseStroke=${this.closePath}points=${this.points.reduce((t, s) => `${t}, ${s}`, "")}]` } get lastX() { return this.points[this.points.length - 2] } get lastY() { return this.points[this.points.length - 1] } get x() { return $(0, "Polygon.lastX is deprecated, please use Polygon.lastX instead."), this.points[this.points.length - 2] } get y() { return $(0, "Polygon.y is deprecated, please use Polygon.lastY instead."), this.points[this.points.length - 1] } get startX() { return this.points[0] } get startY() { return this.points[1] } } const yn = (t, s, i, e, n, r, o) => { const h = t - i, a = s - e, u = Math.sqrt(h * h + a * a); return u >= n - r && u <= n + o }; class wn { constructor(t = 0, s = 0, i = 0, e = 0, n = 20) { this.type = "roundedRectangle", this.x = t, this.y = s, this.width = i, this.height = e, this.radius = n } getBounds(t) { return t || (t = new O), t.x = this.x, t.y = this.y, t.width = this.width, t.height = this.height, t } clone() { return new wn(this.x, this.y, this.width, this.height, this.radius) } copyFrom(t) { return this.x = t.x, this.y = t.y, this.width = t.width, this.height = t.height, this } copyTo(t) { return t.copyFrom(this), t } contains(t, s) { if (this.width <= 0 || this.height <= 0) return !1; if (t >= this.x && t <= this.x + this.width && s >= this.y && s <= this.y + this.height) { const i = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2)); if (s >= this.y + i && s <= this.y + this.height - i || t >= this.x + i && t <= this.x + this.width - i) return !0; let e = t - (this.x + i), n = s - (this.y + i); const r = i * i; if (e * e + n * n <= r) return !0; if (e = t - (this.x + this.width - i), e * e + n * n <= r) return !0; if (n = s - (this.y + this.height - i), e * e + n * n <= r) return !0; if (e = t - (this.x + i), e * e + n * n <= r) return !0 } return !1 } strokeContains(t, s, i, e = .5) { const { x: n, y: r, width: o, height: h, radius: a } = this, u = i * (1 - e), l = i - u, c = n + a, f = r + a, d = n + o, p = r + h; return (t >= n - u && t <= n + l || t >= d - l && t <= d + u) && s >= f && s <= f + (h - 2 * a) || (s >= r - u && s <= r + l || s >= p - l && s <= p + u) && t >= c && t <= c + (o - 2 * a) || t < c && s < f && yn(t, s, c, f, a, l, u) || t > d - a && s < f && yn(t, s, d - a, f, a, l, u) || t > d - a && s > p - a && yn(t, s, d - a, p - a, a, l, u) || t < c && s > p - a && yn(t, s, c, p - a, a, l, u) } toString() { return `[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]` } } const Mn = {}; function Tn(t, s, i) { let e = 2166136261; for (let n = 0; n < s; n++)e ^= t[n].uid, e = Math.imul(e, 16777619), e >>>= 0; return Mn[e] || function (t, s, i, e) { const n = {}; let r = 0; for (let h = 0; h < e; h++) { const i = h < s ? t[h] : Z.EMPTY.source; n[r++] = i.source, n[r++] = i.style } const o = new Ki(n); return Mn[i] = o, o }(t, s, e, i) } class An { constructor(t) { "number" == typeof t ? this.rawBinaryData = new ArrayBuffer(t) : t instanceof Uint8Array ? this.rawBinaryData = t.buffer : this.rawBinaryData = t, this.uint32View = new Uint32Array(this.rawBinaryData), this.float32View = new Float32Array(this.rawBinaryData), this.size = this.rawBinaryData.byteLength } get int8View() { return this.An || (this.An = new Int8Array(this.rawBinaryData)), this.An } get uint8View() { return this.Cn || (this.Cn = new Uint8Array(this.rawBinaryData)), this.Cn } get int16View() { return this._n || (this._n = new Int16Array(this.rawBinaryData)), this._n } get int32View() { return this.Sn || (this.Sn = new Int32Array(this.rawBinaryData)), this.Sn } get float64View() { return this.Pn || (this.Pn = new Float64Array(this.rawBinaryData)), this.Pn } get bigUint64View() { return this.kn || (this.kn = new BigUint64Array(this.rawBinaryData)), this.kn } view(t) { return this[`${t}View`] } destroy() { this.rawBinaryData = null, this.uint32View = null, this.float32View = null, this.uint16View = null, this.An = null, this.Cn = null, this._n = null, this.Sn = null, this.Pn = null, this.kn = null } static sizeOf(t) { switch (t) { case "int8": case "uint8": return 1; case "int16": case "uint16": return 2; case "int32": case "uint32": case "float32": return 4; default: throw new Error(`${t} isn't a valid view type`) } } } function Cn(t, s) { const i = t.byteLength / 8 | 0, e = new Float64Array(t, 0, i); new Float64Array(s, 0, i).set(e); const n = t.byteLength - 8 * i; if (n > 0) { const e = new Uint8Array(t, 8 * i, n); new Uint8Array(s, 8 * i, n).set(e) } } const _n = { normal: "normal-npm", add: "add-npm", screen: "screen-npm" }; var Sn = (t => (t[t.DISABLED = 0] = "DISABLED", t[t.RENDERING_MASK_ADD = 1] = "RENDERING_MASK_ADD", t[t.MASK_ACTIVE = 2] = "MASK_ACTIVE", t[t.INVERSE_MASK_ACTIVE = 3] = "INVERSE_MASK_ACTIVE", t[t.RENDERING_MASK_REMOVE = 4] = "RENDERING_MASK_REMOVE", t[t.NONE = 5] = "NONE", t))(Sn || {}); function Pn(t, s) { return "no-premultiply-alpha" === s.alphaMode && _n[t] || t } const kn = ["precision mediump float;", "void main(void){", "float test = 0.1;", "%forloop%", "gl_FragColor = vec4(0.0);", "}"].join("\n"); function Fn(t) { let s = ""; for (let i = 0; i < t; ++i)i > 0 && (s += "\nelse "), i < t - 1 && (s += `if(test == ${i}.0){}`); return s } function En(t, s) { if (0 === t) throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`"); const i = s.createShader(s.FRAGMENT_SHADER); try { for (; ;) { const e = kn.replace(/%forloop%/gi, Fn(t)); if (s.shaderSource(i, e), s.compileShader(i), s.getShaderParameter(i, s.COMPILE_STATUS)) break; t = t / 2 | 0 } } finally { s.deleteShader(i) } return t } let Rn = null; class On { constructor() { this.ids = Object.create(null), this.textures = [], this.count = 0 } clear() { for (let t = 0; t < this.count; t++) { const s = this.textures[t]; this.textures[t] = null, this.ids[s.uid] = null } this.count = 0 } } class Un { constructor() { this.renderPipeId = "batch", this.action = "startBatch", this.start = 0, this.size = 0, this.textures = new On, this.blendMode = "normal", this.topology = "triangle-strip", this.canBundle = !0 } destroy() { this.textures = null, this.gpuBindGroup = null, this.bindGroup = null, this.batcher = null } } const In = []; let Bn = 0; function Gn() { return Bn > 0 ? In[--Bn] : new Un } function $n(t) { In[Bn++] = t } Rt.register({ clear: () => { if (In.length > 0) for (const t of In) t && t.destroy(); In.length = 0, Bn = 0 } }); let zn = 0; const Dn = class t { constructor(s) { this.uid = I("batcher"), this.dirty = !0, this.batchIndex = 0, this.batches = [], this.Fn = [], (s = { ...t.defaultOptions, ...s }).maxTextures || ($(0, "maxTextures is a required option for Batcher now, please pass it in the options"), s.maxTextures = function () { if (Rn) return Rn; const t = Fi(); return Rn = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS), Rn = En(Rn, t), t.getExtension("WEBGL_lose_context")?.loseContext(), Rn }()); const { maxTextures: i, attributesInitialSize: e, indicesInitialSize: n } = s; this.attributeBuffer = new An(4 * e), this.indexBuffer = new Uint16Array(n), this.maxTextures = i } begin() { this.elementSize = 0, this.elementStart = 0, this.indexSize = 0, this.attributeSize = 0; for (let t = 0; t < this.batchIndex; t++)$n(this.batches[t]); this.batchIndex = 0, this.En = 0, this.Rn = 0, this.dirty = !0 } add(t) { this.Fn[this.elementSize++] = t, t.On = this.indexSize, t.Un = this.attributeSize, t.In = this, this.indexSize += t.indexSize, this.attributeSize += t.attributeSize * this.vertexSize } checkAndUpdateTexture(t, s) { const i = t.Bn.textures.ids[s.K.uid]; return !(!i && 0 !== i || (t.Gn = i, t.texture = s, 0)) } updateElement(t) { this.dirty = !0; const s = this.attributeBuffer; t.packAsQuad ? this.packQuadAttributes(t, s.float32View, s.uint32View, t.Un, t.Gn) : this.packAttributes(t, s.float32View, s.uint32View, t.Un, t.Gn) } break(t) { const s = this.Fn; if (!s[this.elementStart]) return; let i = Gn(), e = i.textures; e.clear(); const n = s[this.elementStart]; let r = Pn(n.blendMode, n.texture.K), o = n.topology; 4 * this.attributeSize > this.attributeBuffer.size && this.$n(4 * this.attributeSize), this.indexSize > this.indexBuffer.length && this.zn(this.indexSize); const h = this.attributeBuffer.float32View, a = this.attributeBuffer.uint32View, u = this.indexBuffer; let l = this.Rn, c = this.En, f = "startBatch"; const d = this.maxTextures; for (let p = this.elementStart; p < this.elementSize; ++p) { const n = s[p]; s[p] = null; const m = n.texture.K, g = Pn(n.blendMode, m), v = r !== g || o !== n.topology; m.$ !== zn || v ? (m.$ = zn, (e.count >= d || v) && (this.Dn(i, c, l - c, e, r, o, t, f), f = "renderBatch", c = l, r = g, o = n.topology, i = Gn(), e = i.textures, e.clear(), ++zn), n.Gn = m.D = e.count, e.ids[m.uid] = e.count, e.textures[e.count++] = m, n.Bn = i, l += n.indexSize, n.packAsQuad ? (this.packQuadAttributes(n, h, a, n.Un, n.Gn), this.packQuadIndex(u, n.On, n.Un / this.vertexSize)) : (this.packAttributes(n, h, a, n.Un, n.Gn), this.packIndex(n, u, n.On, n.Un / this.vertexSize))) : (n.Gn = m.D, l += n.indexSize, n.packAsQuad ? (this.packQuadAttributes(n, h, a, n.Un, n.Gn), this.packQuadIndex(u, n.On, n.Un / this.vertexSize)) : (this.packAttributes(n, h, a, n.Un, n.Gn), this.packIndex(n, u, n.On, n.Un / this.vertexSize)), n.Bn = i) } e.count > 0 && (this.Dn(i, c, l - c, e, r, o, t, f), c = l, ++zn), this.elementStart = this.elementSize, this.En = c, this.Rn = l } Dn(t, s, i, e, n, r, o, h) { t.gpuBindGroup = null, t.bindGroup = null, t.action = h, t.batcher = this, t.textures = e, t.blendMode = n, t.topology = r, t.start = s, t.size = i, ++zn, this.batches[this.batchIndex++] = t, o.add(t) } finish(t) { this.break(t) } ensureAttributeBuffer(t) { 4 * t <= this.attributeBuffer.size || this.$n(4 * t) } ensureIndexBuffer(t) { t <= this.indexBuffer.length || this.zn(t) } $n(t) { const s = Math.max(t, 2 * this.attributeBuffer.size), i = new An(s); Cn(this.attributeBuffer.rawBinaryData, i.rawBinaryData), this.attributeBuffer = i } zn(t) { const s = this.indexBuffer; let i = Math.max(t, 1.5 * s.length); i += i % 2; const e = i > 65535 ? new Uint32Array(i) : new Uint16Array(i); if (e.BYTES_PER_ELEMENT !== s.BYTES_PER_ELEMENT) for (let n = 0; n < s.length; n++)e[n] = s[n]; else Cn(s.buffer, e.buffer); this.indexBuffer = e } packQuadIndex(t, s, i) { t[s] = i + 0, t[s + 1] = i + 1, t[s + 2] = i + 2, t[s + 3] = i + 0, t[s + 4] = i + 2, t[s + 5] = i + 3 } packIndex(t, s, i, e) { const n = t.indices, r = t.indexSize, o = t.indexOffset, h = t.attributeOffset; for (let a = 0; a < r; a++)s[i++] = e + n[a + o] - h } destroy(t = {}) { if (null !== this.batches) { for (let t = 0; t < this.batches.length; t++)$n(this.batches[t]); this.batches = null, this.geometry.destroy(!0), this.geometry = null, t.shader && (this.shader?.destroy(), this.shader = null); for (let t = 0; t < this.Fn.length; t++)this.Fn[t] && (this.Fn[t].Bn = null); this.Fn = null, this.indexBuffer = null, this.attributeBuffer.destroy(), this.attributeBuffer = null } } }; Dn.defaultOptions = { maxTextures: null, attributesInitialSize: 4, indicesInitialSize: 6 }; let jn = Dn; var Ln = (t => (t[t.MAP_READ = 1] = "MAP_READ", t[t.MAP_WRITE = 2] = "MAP_WRITE", t[t.COPY_SRC = 4] = "COPY_SRC", t[t.COPY_DST = 8] = "COPY_DST", t[t.INDEX = 16] = "INDEX", t[t.VERTEX = 32] = "VERTEX", t[t.UNIFORM = 64] = "UNIFORM", t[t.STORAGE = 128] = "STORAGE", t[t.INDIRECT = 256] = "INDIRECT", t[t.QUERY_RESOLVE = 512] = "QUERY_RESOLVE", t[t.STATIC = 1024] = "STATIC", t))(Ln || {}); class Vn extends m { constructor(t) { let { data: s, size: i } = t; const { usage: e, label: n, shrinkToFit: r } = t; super(), this.uid = I("buffer"), this.F = "buffer", this.U = I("resource"), this.R = 0, this.X = 1, this.jn = null, this.shrinkToFit = !0, this.destroyed = !1, s instanceof Array && (s = new Float32Array(s)), this.Ln = s, i ?? (i = s?.byteLength); const o = !!s; this.descriptor = { size: i, usage: e, mappedAtCreation: o, label: n }, this.shrinkToFit = r ?? !0 } get data() { return this.Ln } set data(t) { this.setDataWithSize(t, t.length, !0) } get dataInt32() { return this.jn || (this.jn = new Int32Array(this.data.buffer)), this.jn } get static() { return !!(this.descriptor.usage & Ln.STATIC) } set static(t) { t ? this.descriptor.usage |= Ln.STATIC : this.descriptor.usage &= ~Ln.STATIC } setDataWithSize(t, s, i) { if (this.X++, this.Vn = s * t.BYTES_PER_ELEMENT, this.Ln === t) return void (i && this.emit("update", this)); const e = this.Ln; this.Ln = t, this.jn = null, e && e.length === t.length || !this.shrinkToFit && e && t.byteLength < e.byteLength ? i && this.emit("update", this) : (this.descriptor.size = t.byteLength, this.U = I("resource"), this.emit("change", this)) } update(t) { this.Vn = t ?? this.Vn, this.X++, this.emit("update", this) } destroy() { this.destroyed = !0, this.emit("destroy", this), this.emit("change", this), this.Ln = null, this.descriptor = null, this.removeAllListeners() } } function Nn(t, s) { if (!(t instanceof Vn)) { let i = s ? Ln.INDEX : Ln.VERTEX; t instanceof Array && (s ? (t = new Uint32Array(t), i = Ln.INDEX | Ln.COPY_DST) : (t = new Float32Array(t), i = Ln.VERTEX | Ln.COPY_DST)), t = new Vn({ data: t, label: s ? "index-mesh-buffer" : "vertex-mesh-buffer", usage: i }) } return t } class Wn extends m { constructor(t = {}) { super(), this.uid = I("geometry"), this.Se = 0, this.instanceCount = 1, this.gs = new tt, this.vs = !0; const { attributes: s, indexBuffer: i, topology: e } = t; if (this.buffers = [], this.attributes = {}, s) for (const n in s) this.addAttribute(n, s[n]); this.instanceCount = t.instanceCount ?? 1, i && this.addIndex(i), this.topology = e || "triangle-list" } onBufferUpdate() { this.vs = !0, this.emit("update", this) } getAttribute(t) { return this.attributes[t] } getIndex() { return this.indexBuffer } getBuffer(t) { return this.getAttribute(t).buffer } getSize() { for (const t in this.attributes) { const s = this.attributes[t]; return s.buffer.data.length / (s.stride / 4 || s.size) } return 0 } addAttribute(t, s) { const i = function (t) { return (t instanceof Vn || Array.isArray(t) || t.BYTES_PER_ELEMENT) && (t = { buffer: t }), t.buffer = Nn(t.buffer, !1), t }(s); -1 === this.buffers.indexOf(i.buffer) && (this.buffers.push(i.buffer), i.buffer.on("update", this.onBufferUpdate, this), i.buffer.on("change", this.onBufferUpdate, this)), this.attributes[t] = i } addIndex(t) { this.indexBuffer = Nn(t, !0), this.buffers.push(this.indexBuffer) } get bounds() { return this.vs ? (this.vs = !1, function (t, s, i) { const e = t.getAttribute("aPosition"); if (!e) return i.minX = 0, i.minY = 0, i.maxX = 0, i.maxY = 0, i; const n = e.buffer.data; let r = 1 / 0, o = 1 / 0, h = -1 / 0, a = -1 / 0; const u = n.BYTES_PER_ELEMENT, l = (e.offset || 0) / u, c = (e.stride || 8) / u; for (let f = l; f < n.length; f += c) { const t = n[f], s = n[f + 1]; t > h && (h = t), s > a && (a = s), t < r && (r = t), s < o && (o = s) } return i.minX = r, i.minY = o, i.maxX = h, i.maxY = a, i }(this, 0, this.gs)) : this.gs } destroy(t = !1) { this.emit("destroy", this), this.removeAllListeners(), t && this.buffers.forEach(t => t.destroy()), this.indexBuffer?.destroy(), this.attributes = null, this.buffers = null, this.indexBuffer = null, this.gs = null } } const Hn = new Float32Array(1), qn = new Uint32Array(1); class Xn extends Wn { constructor() { const t = new Vn({ data: Hn, label: "attribute-batch-buffer", usage: Ln.VERTEX | Ln.COPY_DST, shrinkToFit: !1 }); super({ attributes: { aPosition: { buffer: t, format: "float32x2", stride: 24, offset: 0 }, aUV: { buffer: t, format: "float32x2", stride: 24, offset: 8 }, aColor: { buffer: t, format: "unorm8x4", stride: 24, offset: 16 }, aTextureIdAndRound: { buffer: t, format: "uint16x2", stride: 24, offset: 20 } }, indexBuffer: new Vn({ data: qn, label: "index-batch-buffer", usage: Ln.INDEX | Ln.COPY_DST, shrinkToFit: !1 }) }) } } function Yn(t, s, i) { if (t) for (const e in t) { const n = s[e.toLocaleLowerCase()]; if (n) { let s = t[e]; "header" === e && (s = s.replace(/@in\s+[^;]+;\s*/g, "").replace(/@out\s+[^;]+;\s*/g, "")), i && n.push(`//----${i}----//`), n.push(s) } else Et() } } const Kn = /\{\{(.*?)\}\}/g; function Zn(t) { const s = {}; return (t.match(Kn)?.map(t => t.replace(/[{()}]/g, "")) ?? []).forEach(t => { s[t] = [] }), s } function Qn(t, s) { let i; const e = /@in\s+([^;]+);/g; for (; null !== (i = e.exec(t));)s.push(i[1]) } function Jn(t, s, i = !1) { const e = []; Qn(s, e), t.forEach(t => { t.header && Qn(t.header, e) }); const n = e; i && n.sort(); const r = n.map((t, s) => `       @location(${s}) ${t},`).join("\n"); let o = s.replace(/@in\s+[^;]+;\s*/g, ""); return o = o.replace("{{in}}", `\n${r}\n`), o } function tr(t, s) { let i; const e = /@out\s+([^;]+);/g; for (; null !== (i = e.exec(t));)s.push(i[1]) } function sr(t, s) { let i = t; for (const e in s) { const t = s[e]; i = t.join("\n").length ? i.replace(`{{${e}}}`, `//-----${e} START-----//\n${t.join("\n")}\n//----${e} FINISH----//`) : i.replace(`{{${e}}}`, "") } return i } const ir = Object.create(null), er = new Map; let nr = 0; function rr({ template: t, bits: s }) { const i = or(t, s); return ir[i] || (ir[i] = hr(t.vertex, t.fragment, s)), ir[i] } function or(t, s) { return s.map(t => (er.has(t) || er.set(t, nr++), er.get(t))).sort((t, s) => t - s).join("-") + t.vertex + t.fragment } function hr(t, s, i) { const e = Zn(t), n = Zn(s); return i.forEach(t => { Yn(t.vertex, e, t.name), Yn(t.fragment, n, t.name) }), { vertex: sr(t, e), fragment: sr(s, n) } } const ar = { name: "global-uniforms-bit", vertex: { header: "\n        struct GlobalUniforms {\n            uProjectionMatrix:mat3x3<f32>,\n            uWorldTransformMatrix:mat3x3<f32>,\n            uWorldColorAlpha: vec4<f32>,\n            uResolution: vec2<f32>,\n        }\n\n        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;\n        " } }, ur = { name: "global-uniforms-bit", vertex: { header: "\n          uniform mat3 uProjectionMatrix;\n          uniform mat3 uWorldTransformMatrix;\n          uniform vec4 uWorldColorAlpha;\n          uniform vec2 uResolution;\n        " } }; function lr({ bits: t, name: s }) { const i = function ({ template: t, bits: s }) { const i = or(t, s); if (ir[i]) return ir[i]; const { vertex: e, fragment: n } = function (t, s) { const i = s.map(t => t.vertex).filter(t => !!t), e = s.map(t => t.fragment).filter(t => !!t); let n = Jn(i, t.vertex, !0); return n = function (t, s) { const i = []; tr(s, i), t.forEach(t => { t.header && tr(t.header, i) }); let e = 0; const n = i.sort().map(t => t.indexOf("builtin") > -1 ? t : `@location(${e++}) ${t}`).join(",\n"), r = i.sort().map(t => { return `       var ${s = t, s.replace(/@.*?\s+/g, "")};`; var s }).join("\n"), o = `return VSOutput(\n            ${i.sort().map(t => ` ${function (t) { const s = /\b(\w+)\s*:/g.exec(t); return s ? s[1] : "" }(t)}`).join(",\n")});`; let h = s.replace(/@out\s+[^;]+;\s*/g, ""); return h = h.replace("{{struct}}", `\n${n}\n`), h = h.replace("{{start}}", `\n${r}\n`), h = h.replace("{{return}}", `\n${o}\n`), h }(i, n), { vertex: n, fragment: Jn(e, t.fragment, !0) } }(t, s); return ir[i] = hr(e, n, s), ir[i] }({ template: { fragment: "\n    @in vUV : vec2<f32>;\n    @in vColor : vec4<f32>;\n\n    {{header}}\n\n    @fragment\n    fn main(\n        {{in}}\n      ) -> @location(0) vec4<f32> {\n\n        {{start}}\n\n        var outColor:vec4<f32>;\n\n        {{main}}\n\n        var finalColor:vec4<f32> = outColor * vColor;\n\n        {{end}}\n\n        return finalColor;\n      };\n", vertex: "\n    @in aPosition: vec2<f32>;\n    @in aUV: vec2<f32>;\n\n    @out @builtin(position) vPosition: vec4<f32>;\n    @out vUV : vec2<f32>;\n    @out vColor : vec4<f32>;\n\n    {{header}}\n\n    struct VSOutput {\n        {{struct}}\n    };\n\n    @vertex\n    fn main( {{in}} ) -> VSOutput {\n\n        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;\n        var modelMatrix = mat3x3<f32>(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        var position = aPosition;\n        var uv = aUV;\n\n        {{start}}\n\n        vColor = vec4<f32>(1., 1., 1., 1.);\n\n        {{main}}\n\n        vUV = uv;\n\n        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);\n\n        vColor *= globalUniforms.uWorldColorAlpha;\n\n        {{end}}\n\n        {{return}}\n    };\n" }, bits: [ar, ...t] }); return Ni.from({ name: s, vertex: { source: i.vertex, entryPoint: "main" }, fragment: { source: i.fragment, entryPoint: "main" } }) } function cr({ bits: t, name: s }) { return new Gi({ name: s, ...rr({ template: { vertex: "\n    in vec2 aPosition;\n    in vec2 aUV;\n\n    out vec4 vColor;\n    out vec2 vUV;\n\n    {{header}}\n\n    void main(void){\n\n        mat3 worldTransformMatrix = uWorldTransformMatrix;\n        mat3 modelMatrix = mat3(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        vec2 position = aPosition;\n        vec2 uv = aUV;\n\n        {{start}}\n\n        vColor = vec4(1.);\n\n        {{main}}\n\n        vUV = uv;\n\n        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n\n        vColor *= uWorldColorAlpha;\n\n        {{end}}\n    }\n", fragment: "\n\n    in vec4 vColor;\n    in vec2 vUV;\n\n    out vec4 finalColor;\n\n    {{header}}\n\n    void main(void) {\n\n        {{start}}\n\n        vec4 outColor;\n\n        {{main}}\n\n        finalColor = outColor * vColor;\n\n        {{end}}\n    }\n" }, bits: [ur, ...t] }) }) } const fr = { name: "color-bit", vertex: { header: "\n            @in aColor: vec4<f32>;\n        ", main: "\n            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);\n        " } }, dr = { name: "color-bit", vertex: { header: "\n            in vec4 aColor;\n        ", main: "\n            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);\n        " } }, pr = {}; function mr(t) { const s = []; if (1 === t) s.push("@group(1) @binding(0) var textureSource1: texture_2d<f32>;"), s.push("@group(1) @binding(1) var textureSampler1: sampler;"); else { let i = 0; for (let e = 0; e < t; e++)s.push(`@group(1) @binding(${i++}) var textureSource${e + 1}: texture_2d<f32>;`), s.push(`@group(1) @binding(${i++}) var textureSampler${e + 1}: sampler;`) } return s.join("\n") } function gr(t) { const s = []; if (1 === t) s.push("outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);"); else { s.push("switch vTextureId {"); for (let i = 0; i < t; i++)i === t - 1 ? s.push("  default:{") : s.push(`  case ${i}:{`), s.push(`      outColor = textureSampleGrad(textureSource${i + 1}, textureSampler${i + 1}, vUV, uvDx, uvDy);`), s.push("      break;}"); s.push("}") } return s.join("\n") } function vr(t) { return pr[t] || (pr[t] = { name: "texture-batch-bit", vertex: { header: "\n                @in aTextureIdAndRound: vec2<u32>;\n                @out @interpolate(flat) vTextureId : u32;\n            ", main: "\n                vTextureId = aTextureIdAndRound.y;\n            ", end: "\n                if(aTextureIdAndRound.x == 1)\n                {\n                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n                }\n            " }, fragment: { header: `\n                @in @interpolate(flat) vTextureId: u32;\n\n                ${mr(t)}\n            `, main: `\n                var uvDx = dpdx(vUV);\n                var uvDy = dpdy(vUV);\n\n                ${gr(t)}\n            ` } }), pr[t] } const br = {}; function xr(t) { const s = []; for (let i = 0; i < t; i++)i > 0 && s.push("else"), i < t - 1 && s.push(`if(vTextureId < ${i}.5)`), s.push("{"), s.push(`\toutColor = texture(uTextures[${i}], vUV);`), s.push("}"); return s.join("\n") } function yr(t) { return br[t] || (br[t] = { name: "texture-batch-bit", vertex: { header: "\n                in vec2 aTextureIdAndRound;\n                out float vTextureId;\n\n            ", main: "\n                vTextureId = aTextureIdAndRound.y;\n            ", end: "\n                if(aTextureIdAndRound.x == 1.)\n                {\n                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n                }\n            " }, fragment: { header: `\n                in float vTextureId;\n\n                uniform sampler2D uTextures[${t}];\n\n            `, main: `\n\n                ${xr(t)}\n            ` } }), br[t] } const wr = { name: "round-pixels-bit", vertex: { header: "\n            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32>\n            {\n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        " } }, Mr = { name: "round-pixels-bit", vertex: { header: "\n            vec2 roundPixels(vec2 position, vec2 targetSize)\n            {\n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        " } }, Tr = {}; function Ar(t) { let s = Tr[t]; if (s) return s; const i = new Int32Array(t); for (let e = 0; e < t; e++)i[e] = e; return s = Tr[t] = new Yi({ uTextures: { value: i, type: "i32", size: t } }, { isStatic: !0 }), s } class Cr extends Qi { constructor(t) { super({ glProgram: cr({ name: "batch", bits: [dr, yr(t), Mr] }), gpuProgram: lr({ name: "batch", bits: [fr, vr(t), wr] }), resources: { batchSamplers: Ar(t) } }), this.maxTextures = t } } let _r = null; const Sr = class t extends jn { constructor(s) { super(s), this.geometry = new Xn, this.name = t.extension.name, this.vertexSize = 6, _r ?? (_r = new Cr(s.maxTextures)), this.shader = _r } packAttributes(t, s, i, e, n) { const r = n << 16 | 65535 & t.roundPixels, o = t.transform, h = o.a, a = o.b, u = o.c, l = o.d, c = o.tx, f = o.ty, { positions: d, uvs: p } = t, m = t.color, g = t.attributeOffset, v = g + t.attributeSize; for (let b = g; b < v; b++) { const t = 2 * b, n = d[t], o = d[t + 1]; s[e++] = h * n + u * o + c, s[e++] = l * o + a * n + f, s[e++] = p[t], s[e++] = p[t + 1], i[e++] = m, i[e++] = r } } packQuadAttributes(t, s, i, e, n) { const r = t.texture, o = t.transform, h = o.a, a = o.b, u = o.c, l = o.d, c = o.tx, f = o.ty, d = t.bounds, p = d.maxX, m = d.minX, g = d.maxY, v = d.minY, b = r.uvs, x = t.color, y = n << 16 | 65535 & t.roundPixels; s[e + 0] = h * m + u * v + c, s[e + 1] = l * v + a * m + f, s[e + 2] = b.x0, s[e + 3] = b.y0, i[e + 4] = x, i[e + 5] = y, s[e + 6] = h * p + u * v + c, s[e + 7] = l * v + a * p + f, s[e + 8] = b.x1, s[e + 9] = b.y1, i[e + 10] = x, i[e + 11] = y, s[e + 12] = h * p + u * g + c, s[e + 13] = l * g + a * p + f, s[e + 14] = b.x2, s[e + 15] = b.y2, i[e + 16] = x, i[e + 17] = y, s[e + 18] = h * m + u * g + c, s[e + 19] = l * g + a * m + f, s[e + 20] = b.x3, s[e + 21] = b.y3, i[e + 22] = x, i[e + 23] = y } Nn(t) { this.shader.maxTextures !== t && (_r = new Cr(t), this.shader = _r) } destroy() { this.shader = null, super.destroy() } }; Sr.extension = { type: [r.Batcher], name: "default" }; let Pr = Sr; function kr(t, s, i, e, n) { const r = s.a, o = s.b, h = s.c, a = s.d, u = s.tx, l = s.ty; i || (i = 0), e || (e = 2), n || (n = t.length / e - i); let c = i * e; for (let f = 0; f < n; f++) { const s = t[c], i = t[c + 1]; t[c] = r * s + h * i + u, t[c + 1] = o * s + a * i + l, c += e } } const Fr = new w; class Er { constructor() { this.packAsQuad = !1, this.batcherName = "default", this.topology = "triangle-list", this.applyTransform = !0, this.roundPixels = 0, this.In = null, this.Bn = null } get uvs() { return this.geometryData.uvs } get positions() { return this.geometryData.vertices } get indices() { return this.geometryData.indices } get blendMode() { return this.renderable && this.applyTransform ? this.renderable.groupBlendMode : "normal" } get color() { const t = this.baseColor, s = t >> 16 | 65280 & t | (255 & t) << 16, i = this.renderable; return i ? Kt(s, i.groupColor) + (this.alpha * i.groupAlpha * 255 << 24) : s + (255 * this.alpha << 24) } get transform() { return this.renderable?.groupTransform || Fr } copyTo(t) { t.indexOffset = this.indexOffset, t.indexSize = this.indexSize, t.attributeOffset = this.attributeOffset, t.attributeSize = this.attributeSize, t.baseColor = this.baseColor, t.alpha = this.alpha, t.texture = this.texture, t.geometryData = this.geometryData, t.topology = this.topology } reset() { this.applyTransform = !0, this.renderable = null, this.topology = "triangle-list" } destroy() { this.renderable = null, this.texture = null, this.geometryData = null, this.In = null, this.Bn = null } } const Rr = { extension: { type: r.ShapeBuilder, name: "circle" }, build(t, s) { let i, e, n, r, o, h; if ("circle" === t.type) { const s = t; if (o = h = s.radius, o <= 0) return !1; i = s.x, e = s.y, n = r = 0 } else if ("ellipse" === t.type) { const s = t; if (o = s.halfWidth, h = s.halfHeight, o <= 0 || h <= 0) return !1; i = s.x, e = s.y, n = r = 0 } else { const s = t, a = s.width / 2, u = s.height / 2; i = s.x + a, e = s.y + u, o = h = Math.max(0, Math.min(s.radius, Math.min(a, u))), n = a - o, r = u - h } if (n < 0 || r < 0) return !1; const a = Math.ceil(2.3 * Math.sqrt(o + h)), u = 8 * a + (n ? 4 : 0) + (r ? 4 : 0); if (0 === u) return !1; if (0 === a) return s[0] = s[6] = i + n, s[1] = s[3] = e + r, s[2] = s[4] = i - n, s[5] = s[7] = e - r, !0; let l = 0, c = 4 * a + (n ? 2 : 0) + 2, f = c, d = u, p = n + o, m = r, g = i + p, v = i - p, b = e + m; if (s[l++] = g, s[l++] = b, s[--c] = b, s[--c] = v, r) { const t = e - m; s[f++] = v, s[f++] = t, s[--d] = t, s[--d] = g } for (let y = 1; y < a; y++) { const t = Math.PI / 2 * (y / a), u = n + Math.cos(t) * o, p = r + Math.sin(t) * h, m = i + u, g = i - u, v = e + p, b = e - p; s[l++] = m, s[l++] = v, s[--c] = v, s[--c] = g, s[f++] = g, s[f++] = b, s[--d] = b, s[--d] = m } p = n, m = r + h, g = i + p, v = i - p, b = e + m; const x = e - m; return s[l++] = g, s[l++] = b, s[--d] = x, s[--d] = g, n && (s[l++] = v, s[l++] = b, s[--d] = x, s[--d] = v), !0 }, triangulate(t, s, i, e, n, r) { if (0 === t.length) return; let o = 0, h = 0; for (let l = 0; l < t.length; l += 2)o += t[l], h += t[l + 1]; o /= t.length / 2, h /= t.length / 2; let a = e; s[a * i] = o, s[a * i + 1] = h; const u = a++; for (let l = 0; l < t.length; l += 2)s[a * i] = t[l], s[a * i + 1] = t[l + 1], l > 0 && (n[r++] = a, n[r++] = u, n[r++] = a - 1), a++; n[r++] = u + 1, n[r++] = u, n[r++] = a - 1 } }, Or = { ...Rr, extension: { ...Rr.extension, name: "ellipse" } }, Ur = { ...Rr, extension: { ...Rr.extension, name: "roundedRectangle" } }, Ir = 1e-4; function Br(t, s, i, e, n, r, o, h) { let a, u; o ? (a = e, u = -i) : (a = -e, u = i); const l = t - i * n + a, c = s - e * n + u, f = t + i * r + a, d = s + e * r + u; return h.push(l, c), h.push(f, d), 2 } function Gr(t, s, i, e, n, r, o, h) { const a = i - t, u = e - s; let l = Math.atan2(a, u), c = Math.atan2(n - t, r - s); h && l < c ? l += 2 * Math.PI : !h && l > c && (c += 2 * Math.PI); let f = l; const d = c - l, p = Math.abs(d), m = Math.sqrt(a * a + u * u), g = 1 + (15 * p * Math.sqrt(m) / Math.PI | 0), v = d / g; if (f += v, h) { o.push(t, s), o.push(i, e); for (let i = 1, e = f; i < g; i++, e += v)o.push(t, s), o.push(t + Math.sin(e) * m, s + Math.cos(e) * m); o.push(t, s), o.push(n, r) } else { o.push(i, e), o.push(t, s); for (let i = 1, e = f; i < g; i++, e += v)o.push(t + Math.sin(e) * m, s + Math.cos(e) * m), o.push(t, s); o.push(n, r), o.push(t, s) } return 2 * g } function $r(t, s, i, e, n, r, o) { const h = Oe(t, s, 2); if (!h) return; for (let u = 0; u < h.length; u += 3)r[o++] = h[u] + n, r[o++] = h[u + 1] + n, r[o++] = h[u + 2] + n; let a = n * e; for (let u = 0; u < t.length; u += 2)i[a] = t[u], i[a + 1] = t[u + 1], a += e } const zr = [], Dr = { extension: { type: r.ShapeBuilder, name: "polygon" }, build(t, s) { for (let i = 0; i < t.points.length; i++)s[i] = t.points[i]; return !0 }, triangulate(t, s, i, e, n, r) { $r(t, zr, s, i, e, n, r) } }, jr = { extension: { type: r.ShapeBuilder, name: "rectangle" }, build(t, s) { const i = t, e = i.x, n = i.y, r = i.width, o = i.height; return r > 0 && o > 0 && (s[0] = e, s[1] = n, s[2] = e + r, s[3] = n, s[4] = e + r, s[5] = n + o, s[6] = e, s[7] = n + o, !0) }, triangulate(t, s, i, e, n, r) { let o = 0; s[(e *= i) + o] = t[0], s[e + o + 1] = t[1], o += i, s[e + o] = t[2], s[e + o + 1] = t[3], o += i, s[e + o] = t[6], s[e + o + 1] = t[7], o += i, s[e + o] = t[4], s[e + o + 1] = t[5], o += i; const h = e / i; n[r++] = h, n[r++] = h + 1, n[r++] = h + 2, n[r++] = h + 1, n[r++] = h + 3, n[r++] = h + 2 } }, Lr = { extension: { type: r.ShapeBuilder, name: "triangle" }, build: (t, s) => (s[0] = t.x, s[1] = t.y, s[2] = t.x2, s[3] = t.y2, s[4] = t.x3, s[5] = t.y3, !0), triangulate(t, s, i, e, n, r) { let o = 0; s[(e *= i) + o] = t[0], s[e + o + 1] = t[1], o += i, s[e + o] = t[2], s[e + o + 1] = t[3], o += i, s[e + o] = t[4], s[e + o + 1] = t[5]; const h = e / i; n[r++] = h, n[r++] = h + 1, n[r++] = h + 2 } }, Vr = new w, Nr = new O, Wr = {}; a.handleByMap(r.ShapeBuilder, Wr), a.add(jr, Dr, Lr, Rr, Or, Ur); const Hr = new O, qr = new w; function Xr(t, s, i) { const e = [], n = Wr.rectangle, r = Hr; r.x = t.dx, r.y = t.dy, r.width = t.dw, r.height = t.dh; const o = t.transform; if (!n.build(r, e)) return; const { vertices: h, uvs: a, indices: u } = i, l = u.length, c = h.length / 2; o && kr(e, o), n.triangulate(e, h, 2, c, u, l); const f = t.image, d = f.uvs; a.push(d.x0, d.y0, d.x1, d.y1, d.x3, d.y3, d.x2, d.y2); const p = Ut.get(Er); p.indexOffset = l, p.indexSize = u.length - l, p.attributeOffset = c, p.attributeSize = h.length / 2 - c, p.baseColor = t.style, p.alpha = t.alpha, p.texture = f, p.geometryData = i, s.push(p) } function Yr(t, s, i, e, n) { const { vertices: r, uvs: o, indices: h } = n; t.shapePrimitives.forEach(({ shape: t, transform: a, holes: u }) => { const l = [], c = Wr[t.type]; if (!c.build(t, l)) return; const f = h.length, d = r.length / 2; let p = "triangle-list"; if (a && kr(l, a), i) { const i = t.closePath ?? !0, e = s; e.pixelLine ? (function (t, s, i, e) { const n = Ir; if (0 === t.length) return; const r = t[0], o = t[1], h = t[t.length - 2], a = t[t.length - 1], u = s || Math.abs(r - h) < n && Math.abs(o - a) < n, l = i, c = t.length / 2, f = l.length / 2; for (let d = 0; d < c; d++)l.push(t[2 * d]), l.push(t[2 * d + 1]); for (let d = 0; d < c - 1; d++)e.push(f + d, f + d + 1); u && e.push(f + c - 1, f) }(l, i, r, h), p = "line-list") : function (t, s, i, e, n, r) { const o = Ir; if (0 === t.length) return; const h = s; let a = h.alignment; if (.5 !== s.alignment) { let s = function (t) { const s = t.length; if (s < 6) return 1; let i = 0; for (let e = 0, n = t[s - 2], r = t[s - 1]; e < s; e += 2) { const s = t[e], o = t[e + 1]; i += (s - n) * (o + r), n = s, r = o } return i < 0 ? -1 : 1 }(t); a = (a - .5) * s + .5 } const u = new x(t[0], t[1]), l = new x(t[t.length - 2], t[t.length - 1]), c = e, f = Math.abs(u.x - l.x) < o && Math.abs(u.y - l.y) < o; if (c) { t = t.slice(), f && (t.pop(), t.pop(), l.set(t[t.length - 2], t[t.length - 1])); const s = .5 * (u.x + l.x), i = .5 * (l.y + u.y); t.unshift(s, i), t.push(s, i) } const d = n, p = t.length / 2; let m = t.length; const g = d.length / 2, v = h.width / 2, b = v * v, y = h.miterLimit * h.miterLimit; let w = t[0], M = t[1], T = t[2], A = t[3], C = 0, _ = 0, S = -(M - A), P = w - T, k = 0, F = 0, E = Math.sqrt(S * S + P * P); S /= E, P /= E, S *= v, P *= v; const R = 2 * (1 - a), O = 2 * a; c || ("round" === h.cap ? m += Gr(w - S * (R - O) * .5, M - P * (R - O) * .5, w - S * R, M - P * R, w + S * O, M + P * O, d, !0) + 2 : "square" === h.cap && (m += Br(w, M, S, P, R, O, !0, d))), d.push(w - S * R, M - P * R), d.push(w + S * O, M + P * O); for (let x = 1; x < p - 1; ++x) { w = t[2 * (x - 1)], M = t[2 * (x - 1) + 1], T = t[2 * x], A = t[2 * x + 1], C = t[2 * (x + 1)], _ = t[2 * (x + 1) + 1], S = -(M - A), P = w - T, E = Math.sqrt(S * S + P * P), S /= E, P /= E, S *= v, P *= v, k = -(A - _), F = T - C, E = Math.sqrt(k * k + F * F), k /= E, F /= E, k *= v, F *= v; const s = T - w, i = M - A, e = T - C, n = _ - A, r = s * e + i * n, o = i * e - n * s, a = o < 0; if (Math.abs(o) < .001 * Math.abs(r)) { d.push(T - S * R, A - P * R), d.push(T + S * O, A + P * O), r >= 0 && ("round" === h.join ? m += Gr(T, A, T - S * R, A - P * R, T - k * R, A - F * R, d, !1) + 4 : m += 2, d.push(T - k * O, A - F * O), d.push(T + k * R, A + F * R)); continue } const u = (-S + w) * (-P + A) - (-S + T) * (-P + M), l = (-k + C) * (-F + A) - (-k + T) * (-F + _), c = (s * l - e * u) / o, f = (n * u - i * l) / o, p = (c - T) * (c - T) + (f - A) * (f - A), g = T + (c - T) * R, U = A + (f - A) * R, I = T - (c - T) * O, B = A - (f - A) * O, G = a ? R : O; p <= Math.min(s * s + i * i, e * e + n * n) + G * G * b ? "bevel" === h.join || p / b > y ? (a ? (d.push(g, U), d.push(T + S * O, A + P * O), d.push(g, U), d.push(T + k * O, A + F * O)) : (d.push(T - S * R, A - P * R), d.push(I, B), d.push(T - k * R, A - F * R), d.push(I, B)), m += 2) : "round" === h.join ? a ? (d.push(g, U), d.push(T + S * O, A + P * O), m += Gr(T, A, T + S * O, A + P * O, T + k * O, A + F * O, d, !0) + 4, d.push(g, U), d.push(T + k * O, A + F * O)) : (d.push(T - S * R, A - P * R), d.push(I, B), m += Gr(T, A, T - S * R, A - P * R, T - k * R, A - F * R, d, !1) + 4, d.push(T - k * R, A - F * R), d.push(I, B)) : (d.push(g, U), d.push(I, B)) : (d.push(T - S * R, A - P * R), d.push(T + S * O, A + P * O), "round" === h.join ? m += a ? Gr(T, A, T + S * O, A + P * O, T + k * O, A + F * O, d, !0) + 2 : Gr(T, A, T - S * R, A - P * R, T - k * R, A - F * R, d, !1) + 2 : "miter" === h.join && p / b <= y && (a ? (d.push(I, B), d.push(I, B)) : (d.push(g, U), d.push(g, U)), m += 2), d.push(T - k * R, A - F * R), d.push(T + k * O, A + F * O), m += 2) } w = t[2 * (p - 2)], M = t[2 * (p - 2) + 1], T = t[2 * (p - 1)], A = t[2 * (p - 1) + 1], S = -(M - A), P = w - T, E = Math.sqrt(S * S + P * P), S /= E, P /= E, S *= v, P *= v, d.push(T - S * R, A - P * R), d.push(T + S * O, A + P * O), c || ("round" === h.cap ? m += Gr(T - S * (R - O) * .5, A - P * (R - O) * .5, T - S * R, A - P * R, T + S * O, A + P * O, d, !1) + 2 : "square" === h.cap && (m += Br(T, A, S, P, R, O, !1, d))); for (let x = g; x < m + g - 2; ++x)w = d[2 * x], M = d[2 * x + 1], T = d[2 * (x + 1)], A = d[2 * (x + 1) + 1], C = d[2 * (x + 2)], _ = d[2 * (x + 2) + 1], Math.abs(w * (A - _) + T * (_ - M) + C * (M - A)) < 1e-8 || r.push(x, x + 1, x + 2) }(l, e, 0, i, r, h) } else if (u) { const t = [], s = l.slice(); (function (t) { const s = []; for (let i = 0; i < t.length; i++) { const e = t[i].shape, n = []; Wr[e.type].build(e, n) && s.push(n) } return s })(u).forEach(i => { t.push(s.length / 2), s.push(...i) }), $r(s, t, r, 2, d, h, f) } else c.triangulate(l, r, 2, d, h, f); const m = o.length / 2, g = s.texture; if (g !== Z.WHITE) { const i = function (t, s, i, e) { const n = s.matrix ? t.copyFrom(s.matrix).invert() : t.identity(); if ("local" === s.textureSpace) { const t = i.getBounds(Nr); s.width && t.pad(s.width); const { x: e, y: r } = t, o = 1 / t.width, h = 1 / t.height, a = -e * o, u = -r * h, l = n.a, c = n.b, f = n.c, d = n.d; n.a *= o, n.b *= o, n.c *= h, n.d *= h, n.tx = a * l + u * f + n.tx, n.ty = a * c + u * d + n.ty } else n.translate(s.texture.frame.x, s.texture.frame.y), n.scale(1 / s.texture.source.width, 1 / s.texture.source.height); const r = s.texture.source.style; return s.fill instanceof an || "clamp-to-edge" !== r.addressMode || (r.addressMode = "repeat", r.update()), e && n.append(Vr.copyFrom(e).invert()), n }(qr, s, t, a); !function (t, s, i, e, n, r, o, h = null) { let a = 0; i *= s, n *= r; const u = h.a, l = h.b, c = h.c, f = h.d, d = h.tx, p = h.ty; for (; a < o;) { const o = t[i], h = t[i + 1]; e[n] = u * o + c * h + d, e[n + 1] = l * o + f * h + p, n += r, i += s, a++ } }(r, 2, d, o, m, 2, r.length / 2 - d, i) } else !function (t, s, i, e) { let n = 0; for (s *= 2; n < e;)t[s] = 0, t[s + 1] = 0, s += 2, n++ }(o, m, 0, r.length / 2 - d); const v = Ut.get(Er); v.indexOffset = f, v.indexSize = h.length - f, v.attributeOffset = d, v.attributeSize = r.length / 2 - d, v.baseColor = s.color, v.alpha = s.alpha, v.texture = g, v.geometryData = n, v.topology = p, e.push(v) }) } class Kr { constructor() { this.batches = [], this.geometryData = { vertices: [], uvs: [], indices: [] } } } class Zr { constructor() { this.instructions = new ls } init(t) { const s = t.maxTextures; this.batcher ? this.batcher.Nn(s) : this.batcher = new Pr({ maxTextures: s }), this.instructions.reset() } get geometry() { return $(0, "GraphicsContextRenderData#geometry is deprecated, please use batcher.geometry instead."), this.batcher.geometry } destroy() { this.batcher.destroy(), this.instructions.destroy(), this.batcher = null, this.instructions = null } } const Qr = class t { constructor(t) { this.Wn = {}, this.Hn = Object.create(null), this.Gi = t, t.renderableGC.addManagedHash(this, "_gpuContextHash"), t.renderableGC.addManagedHash(this, "_graphicsDataContextHash") } init(s) { t.defaultOptions.bezierSmoothness = s?.bezierSmoothness ?? t.defaultOptions.bezierSmoothness } getContextRenderData(t) { return this.Hn[t.uid] || this.qn(t) } updateGpuContext(t) { let s = this.Wn[t.uid] || this.Xn(t); if (t.dirty) { s ? this.Yn(t) : s = this.Xn(t), function (t, s) { const { geometryData: i, batches: e } = s; e.length = 0, i.indices.length = 0, i.vertices.length = 0, i.uvs.length = 0; for (let n = 0; n < t.instructions.length; n++) { const s = t.instructions[n]; if ("texture" === s.action) Xr(s.data, e, i); else if ("fill" === s.action || "stroke" === s.action) { const t = "stroke" === s.action, n = s.data.path.shapePath, r = s.data.style, o = s.data.hole; t && o && Yr(o.shapePath, r, !0, e, i), o && (n.shapePrimitives[n.shapePrimitives.length - 1].holes = o.shapePath.shapePrimitives), Yr(n, r, t, e, i) } } }(t, s); const i = t.batchMode; t.customShader || "no-batch" === i ? s.isBatchable = !1 : s.isBatchable = "auto" !== i || s.geometryData.vertices.length < 400, t.dirty = !1 } return s } getGpuContext(t) { return this.Wn[t.uid] || this.Xn(t) } qn(t) { const s = Ut.get(Zr, { maxTextures: this.Gi.limits.maxBatchableTextures }), { batches: i, geometryData: e } = this.Wn[t.uid], n = e.vertices.length, r = e.indices.length; for (let u = 0; u < i.length; u++)i[u].applyTransform = !1; const o = s.batcher; o.ensureAttributeBuffer(n), o.ensureIndexBuffer(r), o.begin(); for (let u = 0; u < i.length; u++) { const t = i[u]; o.add(t) } o.finish(s.instructions); const h = o.geometry; h.indexBuffer.setDataWithSize(o.indexBuffer, o.indexSize, !0), h.buffers[0].setDataWithSize(o.attributeBuffer.float32View, o.attributeSize, !0); const a = o.batches; for (let u = 0; u < a.length; u++) { const t = a[u]; t.bindGroup = Tn(t.textures.textures, t.textures.count, this.Gi.limits.maxBatchableTextures) } return this.Hn[t.uid] = s, s } Xn(t) { const s = new Kr; return s.context = t, this.Wn[t.uid] = s, t.on("destroy", this.onGraphicsContextDestroy, this), this.Wn[t.uid] } onGraphicsContextDestroy(t) { this.Yn(t), t.off("destroy", this.onGraphicsContextDestroy, this), this.Wn[t.uid] = null } Yn(t) { const s = this.Wn[t.uid]; s.isBatchable || this.Hn[t.uid] && (Ut.return(this.getContextRenderData(t)), this.Hn[t.uid] = null), s.batches && s.batches.forEach(t => { Ut.return(t) }) } destroy() { for (const t in this.Wn) this.Wn[t] && this.onGraphicsContextDestroy(this.Wn[t].context); this.Wn = {}, this.Hn = {}, this.Gi = null } }; Qr.extension = { type: [r.WebGLSystem, r.WebGPUSystem, r.CanvasSystem], name: "graphicsContext" }, Qr.defaultOptions = { bezierSmoothness: .5 }; let Jr = Qr; const to = 1.1920929e-7; function so(t, s, i, e, n, r, o, h, a, u) { let l = (1 - Math.min(.99, Math.max(0, u ?? Jr.defaultOptions.bezierSmoothness))) / 1; return l *= l, function (t, s, i, e, n, r, o, h, a, u) { io(t, s, i, e, n, r, o, h, a, u, 0), a.push(o, h) }(s, i, e, n, r, o, h, a, t, l), t } function io(t, s, i, e, n, r, o, h, a, u, l) { if (l > 8) return; const c = (t + i) / 2, f = (s + e) / 2, d = (i + n) / 2, p = (e + r) / 2, m = (n + o) / 2, g = (r + h) / 2, v = (c + d) / 2, b = (f + p) / 2, x = (d + m) / 2, y = (p + g) / 2, w = (v + x) / 2, M = (b + y) / 2; if (l > 0) { let l = o - t, c = h - s; const f = Math.abs((i - o) * c - (e - h) * l), d = Math.abs((n - o) * c - (r - h) * l); if (f > to && d > to) { if ((f + d) * (f + d) <= u * (l * l + c * c)) return void a.push(w, M) } else if (f > to) { if (f * f <= u * (l * l + c * c)) return void a.push(w, M) } else if (d > to) { if (d * d <= u * (l * l + c * c)) return void a.push(w, M) } else if (l = w - (t + o) / 2, c = M - (s + h) / 2, l * l + c * c <= u) return void a.push(w, M) } io(t, s, c, f, v, b, w, M, a, u, l + 1), io(w, M, x, y, m, g, o, h, a, u, l + 1) } function eo(t, s, i, e, n, r, o, h) { let a = (1 - Math.min(.99, Math.max(0, h ?? Jr.defaultOptions.bezierSmoothness))) / 1; return a *= a, function (t, s, i, e, n, r, o, h) { no(o, t, s, i, e, n, r, h, 0), o.push(n, r) }(s, i, e, n, r, o, t, a), t } function no(t, s, i, e, n, r, o, h, a) { if (a > 8) return; const u = (s + e) / 2, l = (i + n) / 2, c = (e + r) / 2, f = (n + o) / 2, d = (u + c) / 2, p = (l + f) / 2; let m = r - s, g = o - i; const v = Math.abs((e - r) * g - (n - o) * m); if (v > 1.1920929e-7) { if (v * v <= h * (m * m + g * g)) return void t.push(d, p) } else if (m = d - (s + r) / 2, g = p - (i + o) / 2, m * m + g * g <= h) return void t.push(d, p); no(t, s, i, u, l, d, p, h, a + 1), no(t, d, p, c, f, r, o, h, a + 1) } function ro(t, s, i, e, n, r, o, h) { let a = Math.abs(n - r); (!o && n > r || o && r > n) && (a = 2 * Math.PI - a), h || (h = Math.max(6, Math.floor(6 * Math.pow(e, 1 / 3) * (a / Math.PI)))); let u = a / (h = Math.max(h, 3)), l = n; u *= o ? -1 : 1; for (let c = 0; c < h + 1; c++) { const n = s + Math.cos(l) * e, r = i + Math.sin(l) * e; t.push(n, r), l += u } } const oo = 2 * Math.PI, ho = { centerX: 0, centerY: 0, ang1: 0, ang2: 0 }, ao = ({ x: t, y: s }, i, e, n, r, o, h, a) => { const u = n * (t *= i) - r * (s *= e), l = r * t + n * s; return a.x = u + o, a.y = l + h, a }; function uo(t, s) { const i = -1.5707963267948966 === s ? -.551915024494 : 4 / 3 * Math.tan(s / 4), e = 1.5707963267948966 === s ? .551915024494 : i, n = Math.cos(t), r = Math.sin(t), o = Math.cos(t + s), h = Math.sin(t + s); return [{ x: n - r * e, y: r + n * e }, { x: o + h * e, y: h - o * e }, { x: o, y: h }] } const lo = (t, s, i, e) => { let n = t * i + s * e; return n > 1 && (n = 1), n < -1 && (n = -1), (t * e - s * i < 0 ? -1 : 1) * Math.acos(n) }, co = new O; class fo { constructor(t) { this.shapePrimitives = [], this.Kn = null, this.gs = new tt, this.Zn = t, this.signed = t.checkForHoles } moveTo(t, s) { return this.startPoly(t, s), this } lineTo(t, s) { this.Qn(); const i = this.Kn.points, e = i[i.length - 2], n = i[i.length - 1]; return e === t && n === s || i.push(t, s), this } arc(t, s, i, e, n, r) { return this.Qn(!1), ro(this.Kn.points, t, s, i, e, n, r), this } arcTo(t, s, i, e, n) { return this.Qn(), function (t, s, i, e, n, r) { const o = t[t.length - 2], h = t[t.length - 1] - i, a = o - s, u = n - i, l = e - s, c = Math.abs(h * l - a * u); if (c < 1e-8 || 0 === r) return void (t[t.length - 2] === s && t[t.length - 1] === i || t.push(s, i)); const f = h * h + a * a, d = u * u + l * l, p = h * u + a * l, m = r * Math.sqrt(f) / c, g = r * Math.sqrt(d) / c, v = m * p / f, b = g * p / d, x = m * l + g * a, y = m * u + g * h, w = a * (g + v), M = h * (g + v), T = l * (m + b), A = u * (m + b); ro(t, x + s, y + i, r, Math.atan2(M - y, w - x), Math.atan2(A - y, T - x), a * u > l * h) }(this.Kn.points, t, s, i, e, n), this } arcToSvg(t, s, i, e, n, r, o) { return function (t, s, i, e, n, r, o, h = 0, a = 0, u = 0) { if (0 === r || 0 === o) return; const l = Math.sin(h * oo / 360), c = Math.cos(h * oo / 360), f = c * (s - e) / 2 + l * (i - n) / 2, d = -l * (s - e) / 2 + c * (i - n) / 2; if (0 === f && 0 === d) return; r = Math.abs(r), o = Math.abs(o); const p = Math.pow(f, 2) / Math.pow(r, 2) + Math.pow(d, 2) / Math.pow(o, 2); p > 1 && (r *= Math.sqrt(p), o *= Math.sqrt(p)), ((t, s, i, e, n, r, o, h, a, u, l, c, f) => { const d = Math.pow(n, 2), p = Math.pow(r, 2), m = Math.pow(l, 2), g = Math.pow(c, 2); let v = d * p - d * g - p * m; v < 0 && (v = 0), v /= d * g + p * m, v = Math.sqrt(v) * (o === h ? -1 : 1); const b = v * n / r * c, x = v * -r / n * l, y = u * b - a * x + (t + i) / 2, w = a * b + u * x + (s + e) / 2, M = (l - b) / n, T = (c - x) / r, A = (-l - b) / n, C = (-c - x) / r, _ = lo(1, 0, M, T); let S = lo(M, T, A, C); 0 === h && S > 0 && (S -= oo), 1 === h && S < 0 && (S += oo), f.centerX = y, f.centerY = w, f.ang1 = _, f.ang2 = S })(s, i, e, n, r, o, a, u, l, c, f, d, ho); let { ang1: m, ang2: g } = ho; const { centerX: v, centerY: b } = ho; let x = Math.abs(g) / (oo / 4); Math.abs(1 - x) < 1e-7 && (x = 1); const y = Math.max(Math.ceil(x), 1); g /= y; let w = t[t.length - 2], M = t[t.length - 1]; const T = { x: 0, y: 0 }; for (let A = 0; A < y; A++) { const s = uo(m, g), { x: i, y: e } = ao(s[0], r, o, c, l, v, b, T), { x: n, y: h } = ao(s[1], r, o, c, l, v, b, T), { x: a, y: u } = ao(s[2], r, o, c, l, v, b, T); so(t, w, M, i, e, n, h, a, u), w = a, M = u, m += g } }(this.Kn.points, this.Kn.lastX, this.Kn.lastY, r, o, t, s, i, e, n), this } bezierCurveTo(t, s, i, e, n, r, o) { this.Qn(); const h = this.Kn; return so(this.Kn.points, h.lastX, h.lastY, t, s, i, e, n, r, o), this } quadraticCurveTo(t, s, i, e, n) { this.Qn(); const r = this.Kn; return eo(this.Kn.points, r.lastX, r.lastY, t, s, i, e, n), this } closePath() { return this.endPoly(!0), this } addPath(t, s) { this.endPoly(), s && !s.isIdentity() && (t = t.clone(!0)).transform(s); const i = this.shapePrimitives, e = i.length; for (let n = 0; n < t.instructions.length; n++) { const s = t.instructions[n]; this[s.action](...s.data) } if (t.checkForHoles && i.length - e > 1) { let t = null; for (let s = e; s < i.length; s++) { const e = i[s]; if ("polygon" === e.shape.type) { const n = e.shape, r = t?.shape; r && r.containsPolygon(n) ? (t.holes || (t.holes = []), t.holes.push(e), i.copyWithin(s, s + 1), i.length--, s--) : t = e } } } return this } finish(t = !1) { this.endPoly(t) } rect(t, s, i, e, n) { return this.drawShape(new O(t, s, i, e), n), this } circle(t, s, i, e) { return this.drawShape(new gn(t, s, i), e), this } poly(t, s, i) { const e = new xn(t); return e.closePath = s, this.drawShape(e, i), this } regularPoly(t, s, i, e, n = 0, r) { e = Math.max(0 | e, 3); const o = -1 * Math.PI / 2 + n, h = 2 * Math.PI / e, a = []; for (let u = 0; u < e; u++) { const e = o - u * h; a.push(t + i * Math.cos(e), s + i * Math.sin(e)) } return this.poly(a, !0, r), this } roundPoly(t, s, i, e, n, r = 0, o) { if (e = Math.max(0 | e, 3), n <= 0) return this.regularPoly(t, s, i, e, r); const h = i * Math.sin(Math.PI / e) - .001; n = Math.min(n, h); const a = -1 * Math.PI / 2 + r, u = 2 * Math.PI / e, l = (e - 2) * Math.PI / e / 2; for (let c = 0; c < e; c++) { const e = c * u + a, r = t + i * Math.cos(e), h = s + i * Math.sin(e), f = e + Math.PI + l, d = e - Math.PI - l, p = r + n * Math.cos(f), m = h + n * Math.sin(f), g = r + n * Math.cos(d), v = h + n * Math.sin(d); 0 === c ? this.moveTo(p, m) : this.lineTo(p, m), this.quadraticCurveTo(r, h, g, v, o) } return this.closePath() } roundShape(t, s, i = !1, e) { return t.length < 3 ? this : (i ? function (t, s, i, e) { const n = (t, s) => Math.sqrt((t.x - s.x) ** 2 + (t.y - s.y) ** 2), r = (t, s, i) => ({ x: t.x + (s.x - t.x) * i, y: t.y + (s.y - t.y) * i }), o = s.length; for (let h = 0; h < o; h++) { const a = s[(h + 1) % o], u = a.radius ?? i; if (u <= 0) { 0 === h ? t.moveTo(a.x, a.y) : t.lineTo(a.x, a.y); continue } const l = s[h], c = s[(h + 2) % o], f = n(l, a); let d; d = f < 1e-4 ? a : r(a, l, Math.min(f / 2, u) / f); const p = n(c, a); let m; m = p < 1e-4 ? a : r(a, c, Math.min(p / 2, u) / p), 0 === h ? t.moveTo(d.x, d.y) : t.lineTo(d.x, d.y), t.quadraticCurveTo(a.x, a.y, m.x, m.y, e) } }(this, t, s, e) : function (t, s, i) { const e = (t, s) => { const i = s.x - t.x, e = s.y - t.y, n = Math.sqrt(i * i + e * e); return { len: n, nx: i / n, ny: e / n } }, n = (s, i) => { 0 === s ? t.moveTo(i.x, i.y) : t.lineTo(i.x, i.y) }; let r = s[s.length - 1]; for (let o = 0; o < s.length; o++) { const h = s[o % s.length], a = h.radius ?? i; if (a <= 0) { n(o, h), r = h; continue } const u = s[(o + 1) % s.length], l = e(h, r), c = e(h, u); if (l.len < 1e-4 || c.len < 1e-4) { n(o, h), r = h; continue } let f = Math.asin(l.nx * c.ny - l.ny * c.nx), d = 1, p = !1; l.nx * c.nx - l.ny * -c.ny < 0 ? f < 0 ? f = Math.PI + f : (f = Math.PI - f, d = -1, p = !0) : f > 0 && (d = -1, p = !0); const m = f / 2; let g, v = Math.abs(Math.cos(m) * a / Math.sin(m)); v > Math.min(l.len / 2, c.len / 2) ? (v = Math.min(l.len / 2, c.len / 2), g = Math.abs(v * Math.sin(m) / Math.cos(m))) : g = a; const b = h.x + c.nx * v + -c.ny * g * d, x = h.y + c.ny * v + c.nx * g * d, y = Math.atan2(l.ny, l.nx) + Math.PI / 2 * d, w = Math.atan2(c.ny, c.nx) - Math.PI / 2 * d; 0 === o && t.moveTo(b + Math.cos(y) * g, x + Math.sin(y) * g), t.arc(b, x, g, y, w, p), r = h } }(this, t, s), this.closePath()) } filletRect(t, s, i, e, n) { if (0 === n) return this.rect(t, s, i, e); const r = Math.min(i, e) / 2, o = Math.min(r, Math.max(-r, n)), h = t + i, a = s + e, u = o < 0 ? -o : 0, l = Math.abs(o); return this.moveTo(t, s + l).arcTo(t + u, s + u, t + l, s, l).lineTo(h - l, s).arcTo(h - u, s + u, h, s + l, l).lineTo(h, a - l).arcTo(h - u, a - u, t + i - l, a, l).lineTo(t + l, a).arcTo(t + u, a - u, t, a - l, l).closePath() } chamferRect(t, s, i, e, n, r) { if (n <= 0) return this.rect(t, s, i, e); const o = Math.min(n, Math.min(i, e) / 2), h = t + i, a = s + e, u = [t + o, s, h - o, s, h, s + o, h, a - o, h - o, a, t + o, a, t, a - o, t, s + o]; for (let l = u.length - 1; l >= 2; l -= 2)u[l] === u[l - 2] && u[l - 1] === u[l - 3] && u.splice(l - 1, 2); return this.poly(u, !0, r) } ellipse(t, s, i, e, n) { return this.drawShape(new vn(t, s, i, e), n), this } roundRect(t, s, i, e, n, r) { return this.drawShape(new wn(t, s, i, e, n), r), this } drawShape(t, s) { return this.endPoly(), this.shapePrimitives.push({ shape: t, transform: s }), this } startPoly(t, s) { let i = this.Kn; return i && this.endPoly(), i = new xn, i.points.push(t, s), this.Kn = i, this } endPoly(t = !1) { const s = this.Kn; return s && s.points.length > 2 && (s.closePath = t, this.shapePrimitives.push({ shape: s })), this.Kn = null, this } Qn(t = !0) { if (!this.Kn && (this.Kn = new xn, t)) { const t = this.shapePrimitives[this.shapePrimitives.length - 1]; if (t) { let s = t.shape.x, i = t.shape.y; if (t.transform && !t.transform.isIdentity()) { const e = t.transform, n = s; s = e.a * s + e.c * i + e.tx, i = e.b * n + e.d * i + e.ty } this.Kn.points.push(s, i) } else this.Kn.points.push(0, 0) } } buildPath() { const t = this.Zn; this.shapePrimitives.length = 0, this.Kn = null; for (let s = 0; s < t.instructions.length; s++) { const i = t.instructions[s]; this[i.action](...i.data) } this.finish() } get bounds() { const t = this.gs; t.clear(); const s = this.shapePrimitives; for (let i = 0; i < s.length; i++) { const e = s[i], n = e.shape.getBounds(co); e.transform ? t.addRect(n, e.transform) : t.addRect(n) } return t } } class po { constructor(t, s = !1) { this.instructions = [], this.uid = I("graphicsPath"), this.Re = !0, this.checkForHoles = s, "string" == typeof t ? function (t, s) { const i = mn(t), e = []; let n = null, r = 0, o = 0; for (let h = 0; h < i.length; h++) { const t = i[h], a = t[0], u = t; switch (a) { case "M": r = u[1], o = u[2], s.moveTo(r, o); break; case "m": r += u[1], o += u[2], s.moveTo(r, o); break; case "H": r = u[1], s.lineTo(r, o); break; case "h": r += u[1], s.lineTo(r, o); break; case "V": o = u[1], s.lineTo(r, o); break; case "v": o += u[1], s.lineTo(r, o); break; case "L": r = u[1], o = u[2], s.lineTo(r, o); break; case "l": r += u[1], o += u[2], s.lineTo(r, o); break; case "C": r = u[5], o = u[6], s.bezierCurveTo(u[1], u[2], u[3], u[4], r, o); break; case "c": s.bezierCurveTo(r + u[1], o + u[2], r + u[3], o + u[4], r + u[5], o + u[6]), r += u[5], o += u[6]; break; case "S": r = u[3], o = u[4], s.bezierCurveToShort(u[1], u[2], r, o); break; case "s": s.bezierCurveToShort(r + u[1], o + u[2], r + u[3], o + u[4]), r += u[3], o += u[4]; break; case "Q": r = u[3], o = u[4], s.quadraticCurveTo(u[1], u[2], r, o); break; case "q": s.quadraticCurveTo(r + u[1], o + u[2], r + u[3], o + u[4]), r += u[3], o += u[4]; break; case "T": r = u[1], o = u[2], s.quadraticCurveToShort(r, o); break; case "t": r += u[1], o += u[2], s.quadraticCurveToShort(r, o); break; case "A": r = u[6], o = u[7], s.arcToSvg(u[1], u[2], u[3], u[4], u[5], r, o); break; case "a": r += u[6], o += u[7], s.arcToSvg(u[1], u[2], u[3], u[4], u[5], r, o); break; case "Z": case "z": s.closePath(), e.length > 0 && (n = e.pop(), n ? (r = n.startX, o = n.startY) : (r = 0, o = 0)), n = null; break; default: Et() }"Z" !== a && "z" !== a && null === n && (n = { startX: r, startY: o }, e.push(n)) } }(t, this) : this.instructions = t?.slice() ?? [] } get shapePath() { return this.Jn || (this.Jn = new fo(this)), this.Re && (this.Re = !1, this.Jn.buildPath()), this.Jn } addPath(t, s) { return t = t.clone(), this.instructions.push({ action: "addPath", data: [t, s] }), this.Re = !0, this } arc(...t) { return this.instructions.push({ action: "arc", data: t }), this.Re = !0, this } arcTo(...t) { return this.instructions.push({ action: "arcTo", data: t }), this.Re = !0, this } arcToSvg(...t) { return this.instructions.push({ action: "arcToSvg", data: t }), this.Re = !0, this } bezierCurveTo(...t) { return this.instructions.push({ action: "bezierCurveTo", data: t }), this.Re = !0, this } bezierCurveToShort(t, s, i, e, n) { const r = this.instructions[this.instructions.length - 1], o = this.getLastPoint(x.shared); let h = 0, a = 0; if (r && "bezierCurveTo" === r.action) { h = r.data[2], a = r.data[3]; const t = o.x, s = o.y; h = t + (t - h), a = s + (s - a) } else h = o.x, a = o.y; return this.instructions.push({ action: "bezierCurveTo", data: [h, a, t, s, i, e, n] }), this.Re = !0, this } closePath() { return this.instructions.push({ action: "closePath", data: [] }), this.Re = !0, this } ellipse(...t) { return this.instructions.push({ action: "ellipse", data: t }), this.Re = !0, this } lineTo(...t) { return this.instructions.push({ action: "lineTo", data: t }), this.Re = !0, this } moveTo(...t) { return this.instructions.push({ action: "moveTo", data: t }), this } quadraticCurveTo(...t) { return this.instructions.push({ action: "quadraticCurveTo", data: t }), this.Re = !0, this } quadraticCurveToShort(t, s, i) { const e = this.instructions[this.instructions.length - 1], n = this.getLastPoint(x.shared); let r = 0, o = 0; if (e && "quadraticCurveTo" === e.action) { r = e.data[0], o = e.data[1]; const t = n.x, s = n.y; r = t + (t - r), o = s + (s - o) } else r = n.x, o = n.y; return this.instructions.push({ action: "quadraticCurveTo", data: [r, o, t, s, i] }), this.Re = !0, this } rect(t, s, i, e, n) { return this.instructions.push({ action: "rect", data: [t, s, i, e, n] }), this.Re = !0, this } circle(t, s, i, e) { return this.instructions.push({ action: "circle", data: [t, s, i, e] }), this.Re = !0, this } roundRect(...t) { return this.instructions.push({ action: "roundRect", data: t }), this.Re = !0, this } poly(...t) { return this.instructions.push({ action: "poly", data: t }), this.Re = !0, this } regularPoly(...t) { return this.instructions.push({ action: "regularPoly", data: t }), this.Re = !0, this } roundPoly(...t) { return this.instructions.push({ action: "roundPoly", data: t }), this.Re = !0, this } roundShape(...t) { return this.instructions.push({ action: "roundShape", data: t }), this.Re = !0, this } filletRect(...t) { return this.instructions.push({ action: "filletRect", data: t }), this.Re = !0, this } chamferRect(...t) { return this.instructions.push({ action: "chamferRect", data: t }), this.Re = !0, this } star(t, s, i, e, n, r, o) { n || (n = e / 2); const h = -1 * Math.PI / 2 + r, a = 2 * i, u = 2 * Math.PI / a, l = []; for (let c = 0; c < a; c++) { const i = c % 2 ? n : e, r = c * u + h; l.push(t + i * Math.cos(r), s + i * Math.sin(r)) } return this.poly(l, !0, o), this } clone(t = !1) { const s = new po; if (s.checkForHoles = this.checkForHoles, t) for (let i = 0; i < this.instructions.length; i++) { const t = this.instructions[i]; s.instructions.push({ action: t.action, data: t.data.slice() }) } else s.instructions = this.instructions.slice(); return s } clear() { return this.instructions.length = 0, this.Re = !0, this } transform(t) { if (t.isIdentity()) return this; const s = t.a, i = t.b, e = t.c, n = t.d, r = t.tx, o = t.ty; let h = 0, a = 0, u = 0, l = 0, c = 0, f = 0, d = 0, p = 0; for (let m = 0; m < this.instructions.length; m++) { const g = this.instructions[m], v = g.data; switch (g.action) { case "moveTo": case "lineTo": h = v[0], a = v[1], v[0] = s * h + e * a + r, v[1] = i * h + n * a + o; break; case "bezierCurveTo": u = v[0], l = v[1], c = v[2], f = v[3], h = v[4], a = v[5], v[0] = s * u + e * l + r, v[1] = i * u + n * l + o, v[2] = s * c + e * f + r, v[3] = i * c + n * f + o, v[4] = s * h + e * a + r, v[5] = i * h + n * a + o; break; case "quadraticCurveTo": u = v[0], l = v[1], h = v[2], a = v[3], v[0] = s * u + e * l + r, v[1] = i * u + n * l + o, v[2] = s * h + e * a + r, v[3] = i * h + n * a + o; break; case "arcToSvg": h = v[5], a = v[6], d = v[0], p = v[1], v[0] = s * d + e * p, v[1] = i * d + n * p, v[5] = s * h + e * a + r, v[6] = i * h + n * a + o; break; case "circle": v[4] = mo(v[3], t); break; case "rect": v[4] = mo(v[4], t); break; case "ellipse": v[8] = mo(v[8], t); break; case "roundRect": v[5] = mo(v[5], t); break; case "addPath": v[0].transform(t); break; case "poly": v[2] = mo(v[2], t); break; default: Et(g.action) } } return this.Re = !0, this } get bounds() { return this.shapePath.bounds } getLastPoint(t) { let s = this.instructions.length - 1, i = this.instructions[s]; if (!i) return t.x = 0, t.y = 0, t; for (; "closePath" === i.action;) { if (s--, s < 0) return t.x = 0, t.y = 0, t; i = this.instructions[s] } switch (i.action) { case "moveTo": case "lineTo": t.x = i.data[0], t.y = i.data[1]; break; case "quadraticCurveTo": t.x = i.data[2], t.y = i.data[3]; break; case "bezierCurveTo": t.x = i.data[4], t.y = i.data[5]; break; case "arc": case "arcToSvg": t.x = i.data[5], t.y = i.data[6]; break; case "addPath": i.data[0].getLastPoint(t) }return t } } function mo(t, s) { return t ? t.prepend(s) : s.clone() } function go(t, s, i) { const e = t.getAttribute(s); return e ? Number(e) : i } function vo(t) { const s = go(t, "x1", 0), i = go(t, "y1", 0), e = go(t, "x2", 1), n = go(t, "y2", 0), r = t.getAttribute("gradientUnits") || "objectBoundingBox", o = new an(s, i, e, n, "objectBoundingBox" === r ? "local" : "global"); for (let h = 0; h < t.children.length; h++) { const s = t.children[h], i = go(s, "offset", 0), e = kt.shared.setValue(s.getAttribute("stop-color")).toNumber(); o.addColorStop(i, e) } return o } function bo(t) { return Et(), new an(0, 0, 1, 0) } function xo(t) { const s = t.match(/url\s*\(\s*['"]?\s*#([^'"\s)]+)\s*['"]?\s*\)/i); return s ? s[1] : "" } const yo = { fill: { type: "paint", default: 0 }, "fill-opacity": { type: "number", default: 1 }, stroke: { type: "paint", default: 0 }, "stroke-width": { type: "number", default: 1 }, "stroke-opacity": { type: "number", default: 1 }, "stroke-linecap": { type: "string", default: "butt" }, "stroke-linejoin": { type: "string", default: "miter" }, "stroke-miterlimit": { type: "number", default: 10 }, "stroke-dasharray": { type: "string", default: "none" }, "stroke-dashoffset": { type: "number", default: 0 }, opacity: { type: "number", default: 1 } }; function wo(t, s) { const i = t.getAttribute("style"), e = {}, n = {}, r = { strokeStyle: e, fillStyle: n, useFill: !1, useStroke: !1 }; for (const o in yo) { const i = t.getAttribute(o); i && Mo(s, r, o, i.trim()) } if (i) { const t = i.split(";"); for (let i = 0; i < t.length; i++) { const e = t[i].trim(), [n, o] = e.split(":"); yo[n] && Mo(s, r, n, o.trim()) } } return { strokeStyle: r.useStroke ? e : null, fillStyle: r.useFill ? n : null, useFill: r.useFill, useStroke: r.useStroke } } function Mo(t, s, i, e) { switch (i) { case "stroke": if ("none" !== e) { if (e.startsWith("url(")) { const i = xo(e); s.strokeStyle.fill = t.defs[i] } else s.strokeStyle.color = kt.shared.setValue(e).toNumber(); s.useStroke = !0 } break; case "stroke-width": s.strokeStyle.width = Number(e); break; case "fill": if ("none" !== e) { if (e.startsWith("url(")) { const i = xo(e); s.fillStyle.fill = t.defs[i] } else s.fillStyle.color = kt.shared.setValue(e).toNumber(); s.useFill = !0 } break; case "fill-opacity": s.fillStyle.alpha = Number(e); break; case "stroke-opacity": s.strokeStyle.alpha = Number(e); break; case "opacity": s.fillStyle.alpha = Number(e), s.strokeStyle.alpha = Number(e) } } function To(t) { const s = t.match(/[-+]?[0-9]*\.?[0-9]+/g); if (!s || s.length < 4) return 0; const i = s.map(Number), e = [], n = []; for (let a = 0; a < i.length; a += 2)a + 1 < i.length && (e.push(i[a]), n.push(i[a + 1])); if (0 === e.length || 0 === n.length) return 0; const r = Math.min(...e), o = Math.max(...e), h = Math.min(...n); return (o - r) * (Math.max(...n) - h) } function Ao(t, s) { const i = new po(t, !1); for (const e of i.instructions) s.instructions.push(e) } function Co(t, s, i, e) { const n = t.children, { fillStyle: r, strokeStyle: o } = wo(t, s); r && i ? i = { ...i, ...r } : r && (i = r), o && e ? e = { ...e, ...o } : o && (e = o); const h = !i && !e; let a, u, l, c, f, d, p, m, g, v, b, x, y, w, M, T, A; switch (h && (i = { color: 0 }), t.nodeName.toLowerCase()) { case "path": { w = t.getAttribute("d"); const n = t.getAttribute("fill-rule"), r = w.split(/(?=[Mm])/).filter(t => t.trim().length > 0), o = "evenodd" === n, h = r.length > 1; if (o && h) { const t = r.map(t => ({ path: t, area: To(t) })); t.sort((t, s) => s.area - t.area); const n = r.length > 3 || !function (t) { if (t.length <= 2) return !0; const s = t.map(t => t.area).sort((t, s) => s - t), [i, e] = s, n = s[s.length - 1]; return !(i / e > 3 && e / n < 2) }(t); if (n) for (let r = 0; r < t.length; r++) { const n = t[r], o = 0 === r; s.context.beginPath(); const h = new po(void 0, !0); Ao(n.path, h), s.context.path(h), o ? (i && s.context.fill(i), e && s.context.stroke(e)) : s.context.cut() } else for (let r = 0; r < t.length; r++) { const n = t[r], o = r % 2 == 1; s.context.beginPath(); const h = new po(void 0, !0); Ao(n.path, h), s.context.path(h), o ? s.context.cut() : (i && s.context.fill(i), e && s.context.stroke(e)) } } else M = new po(w, !n || "evenodd" === n), s.context.path(M), i && s.context.fill(i), e && s.context.stroke(e); break } case "circle": p = go(t, "cx", 0), m = go(t, "cy", 0), g = go(t, "r", 0), s.context.ellipse(p, m, g, g), i && s.context.fill(i), e && s.context.stroke(e); break; case "rect": a = go(t, "x", 0), u = go(t, "y", 0), T = go(t, "width", 0), A = go(t, "height", 0), v = go(t, "rx", 0), b = go(t, "ry", 0), v || b ? s.context.roundRect(a, u, T, A, v || b) : s.context.rect(a, u, T, A), i && s.context.fill(i), e && s.context.stroke(e); break; case "ellipse": p = go(t, "cx", 0), m = go(t, "cy", 0), v = go(t, "rx", 0), b = go(t, "ry", 0), s.context.beginPath(), s.context.ellipse(p, m, v, b), i && s.context.fill(i), e && s.context.stroke(e); break; case "line": l = go(t, "x1", 0), c = go(t, "y1", 0), f = go(t, "x2", 0), d = go(t, "y2", 0), s.context.beginPath(), s.context.moveTo(l, c), s.context.lineTo(f, d), e && s.context.stroke(e); break; case "polygon": y = t.getAttribute("points"), x = y.match(/\d+/g).map(t => parseInt(t, 10)), s.context.poly(x, !0), i && s.context.fill(i), e && s.context.stroke(e); break; case "polyline": y = t.getAttribute("points"), x = y.match(/\d+/g).map(t => parseInt(t, 10)), s.context.poly(x, !1), e && s.context.stroke(e); break; case "g": case "svg": break; default: Et(t.nodeName) }h && (i = null); for (let C = 0; C < n.length; C++)Co(n[C], s, i, e) } function _o(t) { return t instanceof fn } function So(t) { return t instanceof an } function Po(t, s, i) { return t.fill = s, t.color = 16777215, t.texture = s.texture, t.matrix = s.transform, { ...i, ...t } } function ko(t, s, i) { return s.buildGradient(), t.fill = s, t.color = 16777215, t.texture = s.texture, t.matrix = s.transform, t.textureSpace = s.textureSpace, { ...i, ...t } } function Fo(t, s) { if (null == t) return null; const i = {}, e = t; return function (t) { return kt.isColorLike(t) }(t) ? function (t, s, i) { const e = kt.shared.setValue(s ?? 0); return t.color = e.toNumber(), t.alpha = 1 === e.alpha ? i.alpha : e.alpha, t.texture = Z.WHITE, { ...i, ...t } }(i, t, s) : function (t) { return t instanceof Z }(t) ? function (t, s, i) { return t.texture = s, { ...i, ...t } }(i, t, s) : _o(t) ? Po(i, t, s) : So(t) ? ko(i, t, s) : e.fill && _o(e.fill) ? Po(e, e.fill, s) : e.fill && So(e.fill) ? ko(e, e.fill, s) : function (t, s) { const i = { ...s, ...t }, e = kt.shared.setValue(i.color); return i.alpha *= e.alpha, i.color = e.toNumber(), i }(e, s) } function Eo(t, s) { const { width: i, alignment: e, miterLimit: n, cap: r, join: o, pixelLine: h, ...a } = s, u = Fo(t, a); return u ? { width: i, alignment: e, miterLimit: n, cap: r, join: o, pixelLine: h, ...u } : null } const Ro = new x, Oo = new w, Uo = class t extends m { constructor() { super(...arguments), this.uid = I("graphicsContext"), this.dirty = !0, this.batchMode = "auto", this.instructions = [], this.tr = new po, this.sr = new w, this.ir = { ...t.defaultFillStyle }, this.er = { ...t.defaultStrokeStyle }, this.nr = [], this.Os = 0, this.gs = new tt, this.vs = !0 } clone() { const s = new t; return s.batchMode = this.batchMode, s.instructions = this.instructions.slice(), s.tr = this.tr.clone(), s.sr = this.sr.clone(), s.ir = { ...this.ir }, s.er = { ...this.er }, s.nr = this.nr.slice(), s.gs = this.gs.clone(), s.vs = !0, s } get fillStyle() { return this.ir } set fillStyle(s) { this.ir = Fo(s, t.defaultFillStyle) } get strokeStyle() { return this.er } set strokeStyle(s) { this.er = Eo(s, t.defaultStrokeStyle) } setFillStyle(s) { return this.ir = Fo(s, t.defaultFillStyle), this } setStrokeStyle(s) { return this.er = Fo(s, t.defaultStrokeStyle), this } texture(t, s, i, e, n, r) { return this.instructions.push({ action: "texture", data: { image: t, dx: i || 0, dy: e || 0, dw: n || t.frame.width, dh: r || t.frame.height, transform: this.sr.clone(), alpha: this.ir.alpha, style: s ? kt.shared.setValue(s).toNumber() : 16777215 } }), this.onUpdate(), this } beginPath() { return this.tr = new po, this } fill(s, i) { let e; const n = this.instructions[this.instructions.length - 1]; return e = 0 === this.Os && "stroke" === n?.action ? n.data.path : this.tr.clone(), e ? (null != s && (void 0 !== i && "number" == typeof s && ($(0, "GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead"), s = { color: s, alpha: i }), this.ir = Fo(s, t.defaultFillStyle)), this.instructions.push({ action: "fill", data: { style: this.fillStyle, path: e } }), this.onUpdate(), this.rr(), this.Os = 0, this) : this } rr() { const { x: t, y: s } = this.tr.getLastPoint(x.shared); this.tr.clear(), this.tr.moveTo(t, s) } stroke(s) { let i; const e = this.instructions[this.instructions.length - 1]; return i = 0 === this.Os && "fill" === e?.action ? e.data.path : this.tr.clone(), i ? (null != s && (this.er = Eo(s, t.defaultStrokeStyle)), this.instructions.push({ action: "stroke", data: { style: this.strokeStyle, path: i } }), this.onUpdate(), this.rr(), this.Os = 0, this) : this } cut() { for (let t = 0; t < 2; t++) { const s = this.instructions[this.instructions.length - 1 - t], i = this.tr.clone(); if (s && ("stroke" === s.action || "fill" === s.action)) { if (!s.data.hole) { s.data.hole = i; break } s.data.hole.addPath(i) } } return this.rr(), this } arc(t, s, i, e, n, r) { this.Os++; const o = this.sr; return this.tr.arc(o.a * t + o.c * s + o.tx, o.b * t + o.d * s + o.ty, i, e, n, r), this } arcTo(t, s, i, e, n) { this.Os++; const r = this.sr; return this.tr.arcTo(r.a * t + r.c * s + r.tx, r.b * t + r.d * s + r.ty, r.a * i + r.c * e + r.tx, r.b * i + r.d * e + r.ty, n), this } arcToSvg(t, s, i, e, n, r, o) { this.Os++; const h = this.sr; return this.tr.arcToSvg(t, s, i, e, n, h.a * r + h.c * o + h.tx, h.b * r + h.d * o + h.ty), this } bezierCurveTo(t, s, i, e, n, r, o) { this.Os++; const h = this.sr; return this.tr.bezierCurveTo(h.a * t + h.c * s + h.tx, h.b * t + h.d * s + h.ty, h.a * i + h.c * e + h.tx, h.b * i + h.d * e + h.ty, h.a * n + h.c * r + h.tx, h.b * n + h.d * r + h.ty, o), this } closePath() { return this.Os++, this.tr?.closePath(), this } ellipse(t, s, i, e) { return this.Os++, this.tr.ellipse(t, s, i, e, this.sr.clone()), this } circle(t, s, i) { return this.Os++, this.tr.circle(t, s, i, this.sr.clone()), this } path(t) { return this.Os++, this.tr.addPath(t, this.sr.clone()), this } lineTo(t, s) { this.Os++; const i = this.sr; return this.tr.lineTo(i.a * t + i.c * s + i.tx, i.b * t + i.d * s + i.ty), this } moveTo(t, s) { this.Os++; const i = this.sr, e = this.tr.instructions, n = i.a * t + i.c * s + i.tx, r = i.b * t + i.d * s + i.ty; return 1 === e.length && "moveTo" === e[0].action ? (e[0].data[0] = n, e[0].data[1] = r, this) : (this.tr.moveTo(n, r), this) } quadraticCurveTo(t, s, i, e, n) { this.Os++; const r = this.sr; return this.tr.quadraticCurveTo(r.a * t + r.c * s + r.tx, r.b * t + r.d * s + r.ty, r.a * i + r.c * e + r.tx, r.b * i + r.d * e + r.ty, n), this } rect(t, s, i, e) { return this.Os++, this.tr.rect(t, s, i, e, this.sr.clone()), this } roundRect(t, s, i, e, n) { return this.Os++, this.tr.roundRect(t, s, i, e, n, this.sr.clone()), this } poly(t, s) { return this.Os++, this.tr.poly(t, s, this.sr.clone()), this } regularPoly(t, s, i, e, n = 0, r) { return this.Os++, this.tr.regularPoly(t, s, i, e, n, r), this } roundPoly(t, s, i, e, n, r) { return this.Os++, this.tr.roundPoly(t, s, i, e, n, r), this } roundShape(t, s, i, e) { return this.Os++, this.tr.roundShape(t, s, i, e), this } filletRect(t, s, i, e, n) { return this.Os++, this.tr.filletRect(t, s, i, e, n), this } chamferRect(t, s, i, e, n, r) { return this.Os++, this.tr.chamferRect(t, s, i, e, n, r), this } star(t, s, i, e, n = 0, r = 0) { return this.Os++, this.tr.star(t, s, i, e, n, r, this.sr.clone()), this } svg(t) { return this.Os++, function (t, s) { if ("string" == typeof t) { const s = document.createElement("div"); s.innerHTML = t.trim(), t = s.querySelector("svg") } const i = { context: s, defs: {}, path: new po }; !function (t, s) { const i = t.querySelectorAll("defs"); for (let e = 0; e < i.length; e++) { const t = i[e]; for (let i = 0; i < t.children.length; i++) { const e = t.children[i]; switch (e.nodeName.toLowerCase()) { case "lineargradient": s.defs[e.id] = vo(e); break; case "radialgradient": s.defs[e.id] = bo() } } } }(t, i); const e = t.children, { fillStyle: n, strokeStyle: r } = wo(t, i); for (let o = 0; o < e.length; o++) { const t = e[o]; "defs" !== t.nodeName.toLowerCase() && Co(t, i, n, r) } }(t, this), this } restore() { const t = this.nr.pop(); return t && (this.sr = t.transform, this.ir = t.fillStyle, this.er = t.strokeStyle), this } save() { return this.nr.push({ transform: this.sr.clone(), fillStyle: { ...this.ir }, strokeStyle: { ...this.er } }), this } getTransform() { return this.sr } resetTransform() { return this.sr.identity(), this } rotate(t) { return this.sr.rotate(t), this } scale(t, s = t) { return this.sr.scale(t, s), this } setTransform(t, s, i, e, n, r) { return t instanceof w ? (this.sr.set(t.a, t.b, t.c, t.d, t.tx, t.ty), this) : (this.sr.set(t, s, i, e, n, r), this) } transform(t, s, i, e, n, r) { return t instanceof w ? (this.sr.append(t), this) : (Oo.set(t, s, i, e, n, r), this.sr.append(Oo), this) } translate(t, s = t) { return this.sr.translate(t, s), this } clear() { return this.tr.clear(), this.instructions.length = 0, this.resetTransform(), this.onUpdate(), this } onUpdate() { this.vs = !0, this.dirty || (this.emit("update", this, 16), this.dirty = !0) } get bounds() { if (!this.vs) return this.gs; this.vs = !1; const t = this.gs; t.clear(); for (let s = 0; s < this.instructions.length; s++) { const i = this.instructions[s], e = i.action; if ("fill" === e) { const s = i.data; t.addBounds(s.path.bounds) } else if ("texture" === e) { const s = i.data; t.addFrame(s.dx, s.dy, s.dx + s.dw, s.dy + s.dh, s.transform) } if ("stroke" === e) { const s = i.data, e = s.style.alignment, n = s.style.width * (1 - e), r = s.path.bounds; t.addFrame(r.minX - n, r.minY - n, r.maxX + n, r.maxY + n) } } return t } containsPoint(t) { if (!this.bounds.containsPoint(t.x, t.y)) return !1; const s = this.instructions; let i = !1; for (let e = 0; e < s.length; e++) { const n = s[e], r = n.data, o = r.path; if (!n.action || !o) continue; const h = r.style, a = o.shapePath.shapePrimitives; for (let s = 0; s < a.length; s++) { const e = a[s].shape; if (!h || !e) continue; const o = a[s].transform, u = o ? o.applyInverse(t, Ro) : t; if ("fill" === n.action) i = e.contains(u.x, u.y); else { const t = h; i = e.strokeContains(u.x, u.y, t.width, t.alignment) } const l = r.hole; if (l) { const t = l.shapePath?.shapePrimitives; if (t) for (let s = 0; s < t.length; s++)t[s].shape.contains(u.x, u.y) && (i = !1) } if (i) return !0 } } return i } destroy(t = !1) { if (this.nr.length = 0, this.sr = null, this.emit("destroy", this), this.removeAllListeners(), "boolean" == typeof t ? t : t?.texture) { const s = "boolean" == typeof t ? t : t?.textureSource; this.ir.texture && (this.ir.fill && "uid" in this.ir.fill ? this.ir.fill.destroy() : this.ir.texture.destroy(s)), this.er.texture && (this.er.fill && "uid" in this.er.fill ? this.er.fill.destroy() : this.er.texture.destroy(s)) } this.ir = null, this.er = null, this.instructions = null, this.tr = null, this.gs = null, this.nr = null, this.customShader = null, this.sr = null } }; Uo.defaultFillStyle = { color: 16777215, alpha: 1, texture: Z.WHITE, matrix: null, fill: null, textureSpace: "local" }, Uo.defaultStrokeStyle = { width: 1, color: 16777215, alpha: 1, alignment: .5, miterLimit: 10, cap: "butt", join: "miter", texture: Z.WHITE, matrix: null, fill: null, textureSpace: "local", pixelLine: !1 }; let Io = Uo; const Bo = class t extends m { constructor(s = {}) { super(), this.uid = I("textStyle"), this.Os = 0, function (t) { const s = t; if ("boolean" == typeof s.dropShadow && s.dropShadow) { const i = Go.defaultDropShadow; t.dropShadow = { alpha: s.dropShadowAlpha ?? i.alpha, angle: s.dropShadowAngle ?? i.angle, blur: s.dropShadowBlur ?? i.blur, color: s.dropShadowColor ?? i.color, distance: s.dropShadowDistance ?? i.distance } } if (void 0 !== s.strokeThickness) { $(0, "strokeThickness is now a part of stroke"); const i = s.stroke; let e = {}; if (kt.isColorLike(i)) e.color = i; else if (i instanceof an || i instanceof fn) e.fill = i; else { if (!Object.hasOwnProperty.call(i, "color") && !Object.hasOwnProperty.call(i, "fill")) throw new Error("Invalid stroke value."); e = i } t.stroke = { ...e, width: s.strokeThickness } } if (Array.isArray(s.fillGradientStops)) { if ($(0, "gradient fill is now a fill pattern: `new FillGradient(...)`"), !Array.isArray(s.fill) || 0 === s.fill.length) throw new Error("Invalid fill value. Expected an array of colors for gradient fill."); s.fill.length !== s.fillGradientStops.length && Et(); const i = new an({ start: { x: 0, y: 0 }, end: { x: 0, y: 1 }, textureSpace: "local" }), e = s.fillGradientStops.slice(), n = s.fill.map(t => kt.shared.setValue(t).toNumber()); e.forEach((t, s) => { i.addColorStop(t, n[s]) }), t.fill = { fill: i } } }(s); const i = { ...t.defaultTextStyle, ...s }; for (const t in i) this[t] = i[t]; this.update(), this.Os = 0 } get align() { return this.hr } set align(t) { this.hr !== t && (this.hr = t, this.update()) } get breakWords() { return this.ar } set breakWords(t) { this.ar !== t && (this.ar = t, this.update()) } get dropShadow() { return this.ur } set dropShadow(s) { this.ur !== s && (this.ur = null !== s && "object" == typeof s ? this.lr({ ...t.defaultDropShadow, ...s }) : s ? this.lr({ ...t.defaultDropShadow }) : null, this.update()) } get fontFamily() { return this.cr } set fontFamily(t) { this.cr !== t && (this.cr = t, this.update()) } get fontSize() { return this.dr } set fontSize(t) { this.dr !== t && (this.dr = "string" == typeof t ? parseInt(t, 10) : t, this.update()) } get fontStyle() { return this.pr } set fontStyle(t) { this.pr !== t && (this.pr = t.toLowerCase(), this.update()) } get fontVariant() { return this.mr } set fontVariant(t) { this.mr !== t && (this.mr = t, this.update()) } get fontWeight() { return this.gr } set fontWeight(t) { this.gr !== t && (this.gr = t, this.update()) } get leading() { return this.vr } set leading(t) { this.vr !== t && (this.vr = t, this.update()) } get letterSpacing() { return this.br } set letterSpacing(t) { this.br !== t && (this.br = t, this.update()) } get lineHeight() { return this.yr } set lineHeight(t) { this.yr !== t && (this.yr = t, this.update()) } get padding() { return this.wr } set padding(t) { this.wr !== t && (this.wr = t, this.update()) } get filters() { return this.Mr } set filters(t) { this.Mr !== t && (this.Mr = Object.freeze(t), this.update()) } get trim() { return this.Tr } set trim(t) { this.Tr !== t && (this.Tr = t, this.update()) } get textBaseline() { return this.Ar } set textBaseline(t) { this.Ar !== t && (this.Ar = t, this.update()) } get whiteSpace() { return this.Cr } set whiteSpace(t) { this.Cr !== t && (this.Cr = t, this.update()) } get wordWrap() { return this.hn } set wordWrap(t) { this.hn !== t && (this.hn = t, this.update()) } get wordWrapWidth() { return this._r } set wordWrapWidth(t) { this._r !== t && (this._r = t, this.update()) } get fill() { return this.Sr } set fill(t) { t !== this.Sr && (this.Sr = t, this.Pr(t) && (this.Sr = this.lr({ ...Io.defaultFillStyle, ...t }, () => { this.kr = Fo({ ...this.Sr }, Io.defaultFillStyle) })), this.kr = Fo(0 === t ? "black" : t, Io.defaultFillStyle), this.update()) } get stroke() { return this.Fr } set stroke(t) { t !== this.Fr && (this.Fr = t, this.Pr(t) && (this.Fr = this.lr({ ...Io.defaultStrokeStyle, ...t }, () => { this.un = Eo({ ...this.Fr }, Io.defaultStrokeStyle) })), this.un = Eo(t, Io.defaultStrokeStyle), this.update()) } update() { this.Os++, this.emit("update", this) } reset() { const s = t.defaultTextStyle; for (const t in s) this[t] = s[t] } get styleKey() { return `${this.uid}-${this.Os}` } clone() { return new t({ align: this.align, breakWords: this.breakWords, dropShadow: this.ur ? { ...this.ur } : null, fill: this.kr, fontFamily: this.fontFamily, fontSize: this.fontSize, fontStyle: this.fontStyle, fontVariant: this.fontVariant, fontWeight: this.fontWeight, leading: this.leading, letterSpacing: this.letterSpacing, lineHeight: this.lineHeight, padding: this.padding, stroke: this.un, textBaseline: this.textBaseline, whiteSpace: this.whiteSpace, wordWrap: this.wordWrap, wordWrapWidth: this.wordWrapWidth, filters: this.Mr ? [...this.Mr] : void 0 }) } Er() { let t = 0; if (this.Mr) for (let s = 0; s < this.Mr.length; s++)t += this.Mr[s].padding; return Math.max(this.wr, t) } destroy(t = !1) { if (this.removeAllListeners(), "boolean" == typeof t ? t : t?.texture) { const s = "boolean" == typeof t ? t : t?.textureSource; this.kr?.texture && this.kr.texture.destroy(s), this.Sr?.texture && this.Sr.texture.destroy(s), this.un?.texture && this.un.texture.destroy(s), this.Fr?.texture && this.Fr.texture.destroy(s) } this.kr = null, this.un = null, this.dropShadow = null, this.Fr = null, this.Sr = null } lr(t, s) { return new Proxy(t, { set: (t, i, e) => (t[i] === e || (t[i] = e, s?.(i, e), this.update()), !0) }) } Pr(t) { return null !== (t ?? null) && !(kt.isColorLike(t) || t instanceof an || t instanceof fn) } }; Bo.defaultDropShadow = { alpha: 1, angle: Math.PI / 6, blur: 0, color: "black", distance: 5 }, Bo.defaultTextStyle = { align: "left", breakWords: !1, dropShadow: null, fill: "black", fontFamily: "Arial", fontSize: 26, fontStyle: "normal", fontVariant: "normal", fontWeight: "normal", leading: 0, letterSpacing: 0, lineHeight: 0, padding: 0, stroke: null, textBaseline: "alphabetic", trim: !1, whiteSpace: "pre", wordWrap: !1, wordWrapWidth: 100 }; let Go = Bo; const $o = new class { constructor(t) { this.Rr = Object.create(null), this.canvasOptions = t || {}, this.enableFullScreen = !1 } Or(t, s) { const i = ks.get().createCanvas(); i.width = t, i.height = s; const e = i.getContext("2d"); return { canvas: i, context: e } } getOptimalCanvasAndContext(t, s, i = 1) { t = Math.ceil(t * i - 1e-6), s = Math.ceil(s * i - 1e-6); const e = ((t = D(t)) << 17) + ((s = D(s)) << 1); this.Rr[e] || (this.Rr[e] = []); let n = this.Rr[e].pop(); return n || (n = this.Or(t, s)), n } returnCanvasAndContext(t) { const s = t.canvas, { width: i, height: e } = s, n = (i << 17) + (e << 1); t.context.resetTransform(), t.context.clearRect(0, 0, i, e), this.Rr[n].push(t) } clear() { this.Rr = {} } }; Rt.register($o); const zo = 1e5; function Do(t, s, i, e = 0) { if (t.texture === Z.WHITE && !t.fill) return kt.shared.setValue(t.color).setAlpha(t.alpha ?? 1).toHexa(); if (!t.fill) { const i = s.createPattern(t.texture.source.resource, "repeat"), e = t.matrix.copyTo(w.shared); return e.scale(t.texture.frame.width, t.texture.frame.height), i.setTransform(e), i } if (t.fill instanceof fn) { const i = t.fill, e = s.createPattern(i.texture.source.resource, "repeat"), n = i.transform.copyTo(w.shared); return n.scale(i.texture.frame.width, i.texture.frame.height), e.setTransform(n), e } if (t.fill instanceof an) { const n = t.fill, r = "linear" === n.type, o = "local" === n.textureSpace; let h, a = 1, u = 1; o && i && (a = i.width + e, u = i.height + e); let l = !1; if (r) { const { start: t, end: i } = n; h = s.createLinearGradient(t.x * a, t.y * u, i.x * a, i.y * u), l = Math.abs(i.x - t.x) < Math.abs(.1 * (i.y - t.y)) } else { const { center: t, innerRadius: i, outerCenter: e, outerRadius: r } = n; h = s.createRadialGradient(t.x * a, t.y * u, i * a, e.x * a, e.y * u, r * a) } if (l && o && i) { const t = i.lineHeight / u; for (let s = 0; s < i.lines.length; s++) { const r = (s * i.lineHeight + e / 2) / u; n.colorStops.forEach(s => { const i = r + s.offset * t; h.addColorStop(Math.floor(i * zo) / zo, kt.shared.setValue(s.color).toHex()) }) } } else n.colorStops.forEach(t => { h.addColorStop(t.offset, kt.shared.setValue(t.color).toHex()) }); return h } return Et(), "red" } const jo = class t extends Ze { constructor(s) { super(), this.resolution = 1, this.pages = [], this.wr = 0, this.Ur = Object.create(null), this.Ir = [], this.Br = 0, this.Gr = 0, this.$r = 0, this.zr = -1, this.Dr = !1; const i = { ...t.defaultOptions, ...s }; this.Mn = i.textureSize, this.jr = i.mipmap; const e = i.style.clone(); i.overrideFill && (e.kr.color = 16777215, e.kr.alpha = 1, e.kr.texture = Z.WHITE, e.kr.fill = null), this.applyFillAsTint = i.overrideFill; const n = e.fontSize; e.fontSize = this.baseMeasurementFontSize; const r = sn(e); i.overrideSize ? e.un && (e.un.width *= this.baseRenderedFontSize / n) : e.fontSize = this.baseRenderedFontSize = n, this.L = e, this.Dr = i.skipKerning ?? !1, this.resolution = i.resolution ?? 1, this.wr = i.padding ?? 4, i.textureStyle && (this.Lr = i.textureStyle instanceof W ? i.textureStyle : new W(i.textureStyle)), this.fontMetrics = rn.measureFont(r), this.lineHeight = e.lineHeight || this.fontMetrics.fontSize || e.fontSize } ensureCharacters(t) { const s = rn.graphemeSegmenter(t).filter(t => !this.Ir.includes(t)).filter((t, s, i) => i.indexOf(t) === s); if (!s.length) return; let i; this.Ir = [...this.Ir, ...s], i = -1 === this.zr ? this.Vr() : this.pages[this.zr]; let { canvas: e, context: n } = i.canvasAndContext, r = i.texture.source; const o = this.L; let h = this.Br, a = this.Gr, u = this.$r; const l = this.baseRenderedFontSize / this.baseMeasurementFontSize, c = this.wr * l; let f = !1; const d = e.width / this.resolution, p = e.height / this.resolution; for (let m = 0; m < s.length; m++) { const t = s[m], i = rn.measureText(t, o, e, !1); i.lineHeight = i.height; const g = i.width * l, v = Math.ceil(("italic" === o.fontStyle ? 2 : 1) * g) + 2 * c, b = i.height * l + 2 * c; if (f = !1, "\n" !== t && "\r" !== t && "\t" !== t && " " !== t && (f = !0, u = Math.ceil(Math.max(b, u))), h + v > d && (a += u, u = b, h = 0, a + u > p)) { r.update(); const t = this.Vr(); e = t.canvasAndContext.canvas, n = t.canvasAndContext.context, r = t.texture.source, h = 0, a = 0, u = 0 } const x = g / l - (o.dropShadow?.distance ?? 0) - (o.un?.width ?? 0); if (this.chars[t] = { id: t.codePointAt(0), xOffset: -this.wr, yOffset: -this.wr, xAdvance: x, kerning: {} }, f) { this.Nr(n, i, h + c, a + c, l, o); const s = r.width * l, e = r.height * l, u = new O(h / s * r.width, a / e * r.height, v / s * r.width, b / e * r.height); this.chars[t].texture = new Z({ source: r, frame: u }), h += Math.ceil(v) } } r.update(), this.Br = h, this.Gr = a, this.$r = u, this.Dr && this.Wr(s, n) } get pageTextures() { return $(0, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."), this.pages } Wr(t, s) { const i = this.Ur; for (let e = 0; e < t.length; e++) { const n = t[e]; for (let t = 0; t < this.Ir.length; t++) { const e = this.Ir[t]; let r = i[n]; r || (r = i[n] = s.measureText(n).width); let o = i[e]; o || (o = i[e] = s.measureText(e).width); let h = s.measureText(n + e).width, a = h - (r + o); a && (this.chars[n].kerning[e] = a), h = s.measureText(n + e).width, a = h - (r + o), a && (this.chars[e].kerning[n] = a) } } } Vr() { this.zr++; const t = this.resolution, s = $o.getOptimalCanvasAndContext(this.Mn, this.Mn, t); this.Hr(s.context, this.L, t); const i = t * (this.baseRenderedFontSize / this.baseMeasurementFontSize), e = new Z({ source: new Es({ resource: s.canvas, resolution: i, alphaMode: "premultiply-alpha-on-upload", autoGenerateMipmaps: this.jr }) }); this.Lr && (e.source.style = this.Lr); const n = { canvasAndContext: s, texture: e }; return this.pages[this.zr] = n, n } Hr(t, s, i) { s.fontSize = this.baseRenderedFontSize, t.scale(i, i), t.font = sn(s), s.fontSize = this.baseMeasurementFontSize, t.textBaseline = s.textBaseline; const e = s.un, n = e?.width ?? 0; if (e && (t.lineWidth = n, t.lineJoin = e.join, t.miterLimit = e.miterLimit, t.strokeStyle = Do(e, t)), s.kr && (t.fillStyle = Do(s.kr, t)), s.dropShadow) { const e = s.dropShadow, n = kt.shared.setValue(e.color).toArray(), r = e.blur * i, o = e.distance * i; t.shadowColor = `rgba(${255 * n[0]},${255 * n[1]},${255 * n[2]},${e.alpha})`, t.shadowBlur = r, t.shadowOffsetX = Math.cos(e.angle) * o, t.shadowOffsetY = Math.sin(e.angle) * o } else t.shadowColor = "black", t.shadowBlur = 0, t.shadowOffsetX = 0, t.shadowOffsetY = 0 } Nr(t, s, i, e, n, r) { const o = s.text, h = s.fontProperties, a = r.un, u = (a?.width ?? 0) * n, l = i + u / 2, c = e - u / 2, f = h.descent * n, d = s.lineHeight * n; let p = !1; r.stroke && u && (p = !0, t.strokeText(o, l, c + d - f)); const { shadowBlur: m, shadowOffsetX: g, shadowOffsetY: v } = t; r.kr && (p && (t.shadowBlur = 0, t.shadowOffsetX = 0, t.shadowOffsetY = 0), t.fillText(o, l, c + d - f)), p && (t.shadowBlur = m, t.shadowOffsetX = g, t.shadowOffsetY = v) } destroy() { super.destroy(); for (let t = 0; t < this.pages.length; t++) { const { canvasAndContext: s, texture: i } = this.pages[t]; $o.returnCanvasAndContext(s), i.destroy(!0) } this.pages = null } }; jo.defaultOptions = { textureSize: 512, style: new Go, mipmap: !0 }; let Lo = jo; function Vo(t, s, i, e) { const n = { width: 0, height: 0, offsetY: 0, scale: s.fontSize / i.baseMeasurementFontSize, lines: [{ width: 0, charPositions: [], spaceWidth: 0, spacesIndex: [], chars: [] }] }; n.offsetY = i.baseLineOffset; let r = n.lines[0], o = null, h = !0; const a = { width: 0, start: 0, index: 0, positions: [], chars: [] }, u = i.baseMeasurementFontSize / s.fontSize, l = s.letterSpacing * u, c = s.wordWrapWidth * u, f = s.lineHeight ? s.lineHeight * u : i.lineHeight, d = s.wordWrap && s.breakWords, p = t => { const s = r.width; for (let i = 0; i < a.index; i++) { const e = t.positions[i]; r.chars.push(t.chars[i]), r.charPositions.push(e + s) } r.width += t.width, h = !1, a.width = 0, a.index = 0, a.chars.length = 0 }, m = () => { let t = r.chars.length - 1; if (e) { let s = r.chars[t]; for (; " " === s;)r.width -= i.chars[s].xAdvance, s = r.chars[--t] } n.width = Math.max(n.width, r.width), r = { width: 0, charPositions: [], chars: [], spaceWidth: 0, spacesIndex: [] }, h = !0, n.lines.push(r), n.height += f }, g = t => t - l > c; for (let v = 0; v < t.length + 1; v++) { let e; const n = v === t.length; n || (e = t[v]); const u = i.chars[e] || i.chars[" "]; if (/(?:\s)/.test(e) || "\r" === e || "\n" === e || n) { if (!h && s.wordWrap && g(r.width + a.width) ? (m(), p(a), n || r.charPositions.push(0)) : (a.start = r.width, p(a), n || r.charPositions.push(0)), "\r" === e || "\n" === e) m(); else if (!n) { const t = u.xAdvance + (u.kerning[o] || 0) + l; r.width += t, r.spaceWidth = t, r.spacesIndex.push(r.charPositions.length), r.chars.push(e) } } else { const t = u.kerning[o] || 0, s = u.xAdvance + t + l; d && g(r.width + a.width + s) && (p(a), m()), a.positions[a.index++] = a.width + t, a.chars.push(e), a.width += s } o = e } return m(), "center" === s.align ? function (t) { for (let s = 0; s < t.lines.length; s++) { const i = t.lines[s], e = t.width / 2 - i.width / 2; for (let t = 0; t < i.charPositions.length; t++)i.charPositions[t] += e } }(n) : "right" === s.align ? function (t) { for (let s = 0; s < t.lines.length; s++) { const i = t.lines[s], e = t.width - i.width; for (let t = 0; t < i.charPositions.length; t++)i.charPositions[t] += e } }(n) : "justify" === s.align && function (t) { const s = t.width; for (let i = 0; i < t.lines.length; i++) { const e = t.lines[i]; let n = 0, r = e.spacesIndex[n++], o = 0; const h = e.spacesIndex.length, a = (s - e.width) / h; for (let t = 0; t < e.charPositions.length; t++)t === r && (r = e.spacesIndex[n++], o += a), e.charPositions[t] += o } }(n), n } let No = 0; const Wo = new class { constructor() { this.ALPHA = [["a", "z"], ["A", "Z"], " "], this.NUMERIC = [["0", "9"]], this.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "], this.ASCII = [[" ", "~"]], this.defaultOptions = { chars: this.ALPHANUMERIC, resolution: 1, padding: 4, skipKerning: !1, textureStyle: null }, this.measureCache = Je(1e3) } getFont(t, s) { let i = `${s.fontFamily}-bitmap`, e = !0; if (s.kr.fill && !s.un ? (i += s.kr.fill.styleKey, e = !1) : (s.un || s.dropShadow) && (i = `${s.styleKey}-bitmap`, e = !1), !Ds.has(i)) { const t = Object.create(s); t.lineHeight = 0; const n = new Lo({ style: t, overrideFill: e, overrideSize: !0, ...this.defaultOptions }); No++, No > 50 && Et(), n.once("destroy", () => { No--, Ds.remove(i) }), Ds.set(i, n) } const n = Ds.get(i); return n.ensureCharacters?.(t), n } getLayout(t, s, i = !0) { const e = this.getFont(t, s), n = `${t}-${s.styleKey}-${i}`; if (this.measureCache.has(n)) return this.measureCache.get(n); const r = Vo(rn.graphemeSegmenter(t), s, e, i); return this.measureCache.set(n, r), r } measureText(t, s, i = !0) { return this.getLayout(t, s, i) } install(...t) { let s = t[0]; "string" == typeof s && (s = { name: s, style: t[1], chars: t[2]?.chars, resolution: t[2]?.resolution, padding: t[2]?.padding, skipKerning: t[2]?.skipKerning }, $(0, "BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})")); const i = s?.name; if (!i) throw new Error("[BitmapFontManager] Property `name` is required."); s = { ...this.defaultOptions, ...s }; const e = s.style, n = e instanceof Go ? e : new Go(e), r = s.dynamicFill ?? this.qr(n), o = new Lo({ style: n, overrideFill: r, skipKerning: s.skipKerning, padding: s.padding, resolution: s.resolution, overrideSize: !1, textureStyle: s.textureStyle }), h = function (t) { if ("" === t) return []; "string" == typeof t && (t = [t]); const s = []; for (let i = 0, e = t.length; i < e; i++) { const e = t[i]; if (Array.isArray(e)) { if (2 !== e.length) throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${e.length}.`); if (0 === e[0].length || 0 === e[1].length) throw new Error("[BitmapFont]: Invalid character delimiter."); const t = e[0].charCodeAt(0), i = e[1].charCodeAt(0); if (i < t) throw new Error("[BitmapFont]: Invalid character range."); for (let e = t, n = i; e <= n; e++)s.push(String.fromCharCode(e)) } else s.push(...Array.from(e)) } if (0 === s.length) throw new Error("[BitmapFont]: Empty set when resolving characters."); return s }(s.chars); return o.ensureCharacters(h.join("")), Ds.set(`${i}-bitmap`, o), o.once("destroy", () => Ds.remove(`${i}-bitmap`)), o } uninstall(t) { const s = `${t}-bitmap`, i = Ds.get(s); i && i.destroy() } qr(t) { return !(t.un || t.dropShadow && 0 !== t.dropShadow.color || t.kr.fill || 16777215 !== t.kr.color) } }; class Ho { constructor(t) { this.Xr = [], this.Gi = t, this.Gi.runners.postrender.add(this), this.Gi.runners.init.add(this), this.$i = document.createElement("div"), this.$i.style.position = "absolute", this.$i.style.top = "0", this.$i.style.left = "0", this.$i.style.pointerEvents = "none", this.$i.style.zIndex = "1000" } init() { this.ae = new ei({ domElement: this.$i, renderer: this.Gi }) } addRenderable(t, s) { this.Xr.includes(t) || this.Xr.push(t) } updateRenderable(t) { } validateRenderable(t) { return !0 } postrender() { const t = this.Xr; if (0 !== t.length) { this.ae.ensureAttached(); for (let s = 0; s < t.length; s++) { const i = t[s], e = i.element; if (!i.parent || i.globalDisplayStatus < 7) e?.remove(), t.splice(s, 1), s--; else { this.$i.contains(e) || (e.style.position = "absolute", e.style.pointerEvents = "auto", this.$i.appendChild(e)); const t = i.worldTransform, s = i.xs, n = i.width * s.x, r = i.height * s.y; e.style.transformOrigin = `${n}px ${r}px`, e.style.transform = `matrix(${t.a}, ${t.b}, ${t.c}, ${t.d}, ${t.tx - n}, ${t.ty - r})`, e.style.opacity = i.groupAlpha.toString() } } } else this.$i.remove() } destroy() { this.Gi.runners.postrender.remove(this); for (let t = 0; t < this.Xr.length; t++) { const s = this.Xr[t]; s.element?.remove() } this.Xr.length = 0, this.$i.remove(), this.ae.destroy(), this.Gi = null } } Ho.extension = { type: [r.WebGLPipes, r.WebGPUPipes, r.CanvasPipes], name: "dom" }; const qo = new class { constructor() { this.interactionFrequency = 10, this.Yr = 0, this.Kr = !1, this.Zr = !1, this.Qr = !0 } init(t) { this.removeTickerListener(), this.events = t, this.interactionFrequency = 10, this.Yr = 0, this.Kr = !1, this.Zr = !1, this.Qr = !0 } get pauseUpdate() { return this.Qr } set pauseUpdate(t) { this.Qr = t } addTickerListener() { !this.Zr && this.domElement && (Bs.system.add(this.Jr, this, Rs.INTERACTION), this.Zr = !0) } removeTickerListener() { this.Zr && (Bs.system.remove(this.Jr, this), this.Zr = !1) } pointerMoved() { this.Kr = !0 } so() { if (!this.domElement || this.Qr) return; if (this.Kr) return void (this.Kr = !1); const t = this.events.io; this.events.supportsTouchEvents && "touch" === t.pointerType || globalThis.document.dispatchEvent(this.events.supportsPointerEvents ? new PointerEvent("pointermove", { clientX: t.clientX, clientY: t.clientY, pointerType: t.pointerType, pointerId: t.pointerId }) : new MouseEvent("mousemove", { clientX: t.clientX, clientY: t.clientY })) } Jr(t) { this.Yr += t.deltaTime, this.Yr < this.interactionFrequency || (this.Yr = 0, this.so()) } destroy() { this.removeTickerListener(), this.events = null, this.domElement = null, this.Yr = 0, this.Kr = !1, this.Zr = !1, this.Qr = !0 } }; class Xo extends ni { constructor() { super(...arguments), this.client = new x, this.movement = new x, this.offset = new x, this.global = new x, this.screen = new x } get clientX() { return this.client.x } get clientY() { return this.client.y } get x() { return this.clientX } get y() { return this.clientY } get movementX() { return this.movement.x } get movementY() { return this.movement.y } get offsetX() { return this.offset.x } get offsetY() { return this.offset.y } get globalX() { return this.global.x } get globalY() { return this.global.y } get screenX() { return this.screen.x } get screenY() { return this.screen.y } getLocalPosition(t, s, i) { return t.worldTransform.applyInverse(i || this.global, s) } getModifierState(t) { return "getModifierState" in this.nativeEvent && this.nativeEvent.getModifierState(t) } initMouseEvent(t, s, i, e, n, r, o, h, a, u, l, c, f, d, p) { throw new Error("Method not implemented.") } } class Yo extends Xo { constructor() { super(...arguments), this.width = 0, this.height = 0, this.isPrimary = !1 } getCoalescedEvents() { return "pointermove" === this.type || "mousemove" === this.type || "touchmove" === this.type ? [this] : [] } getPredictedEvents() { throw new Error("getPredictedEvents is not supported!") } } class Ko extends Xo { constructor() { super(...arguments), this.DOM_DELTA_PIXEL = 0, this.DOM_DELTA_LINE = 1, this.DOM_DELTA_PAGE = 2 } } Ko.DOM_DELTA_PIXEL = 0, Ko.DOM_DELTA_LINE = 1, Ko.DOM_DELTA_PAGE = 2; const Zo = new x, Qo = new x; class Jo { constructor(t) { this.dispatch = new m, this.moveOnAll = !1, this.enableGlobalMoveEvents = !0, this.mappingState = { trackingData: {} }, this.eventPool = new Map, this.eo = [], this.no = [], this.ro = !1, this.rootTarget = t, this.hitPruneFn = this.hitPruneFn.bind(this), this.hitTestFn = this.hitTestFn.bind(this), this.mapPointerDown = this.mapPointerDown.bind(this), this.mapPointerMove = this.mapPointerMove.bind(this), this.mapPointerOut = this.mapPointerOut.bind(this), this.mapPointerOver = this.mapPointerOver.bind(this), this.mapPointerUp = this.mapPointerUp.bind(this), this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this), this.mapWheel = this.mapWheel.bind(this), this.mappingTable = {}, this.addEventMapping("pointerdown", this.mapPointerDown), this.addEventMapping("pointermove", this.mapPointerMove), this.addEventMapping("pointerout", this.mapPointerOut), this.addEventMapping("pointerleave", this.mapPointerOut), this.addEventMapping("pointerover", this.mapPointerOver), this.addEventMapping("pointerup", this.mapPointerUp), this.addEventMapping("pointerupoutside", this.mapPointerUpOutside), this.addEventMapping("wheel", this.mapWheel) } addEventMapping(t, s) { this.mappingTable[t] || (this.mappingTable[t] = []), this.mappingTable[t].push({ fn: s, priority: 0 }), this.mappingTable[t].sort((t, s) => t.priority - s.priority) } dispatchEvent(t, s) { t.propagationStopped = !1, t.propagationImmediatelyStopped = !1, this.propagate(t, s), this.dispatch.emit(s || t.type, t) } mapEvent(t) { if (!this.rootTarget) return; const s = this.mappingTable[t.type]; if (s) for (let i = 0, e = s.length; i < e; i++)s[i].fn(t); else Et(t.type) } hitTest(t, s) { qo.pauseUpdate = !0; const i = this[this.ro && this.enableGlobalMoveEvents ? "hitTestMoveRecursive" : "hitTestRecursive"](this.rootTarget, this.rootTarget.eventMode, Zo.set(t, s), this.hitTestFn, this.hitPruneFn); return i && i[0] } propagate(t, s) { if (!t.target) return; const i = t.composedPath(); t.eventPhase = t.CAPTURING_PHASE; for (let e = 0, n = i.length - 1; e < n; e++)if (t.currentTarget = i[e], this.notifyTarget(t, s), t.propagationStopped || t.propagationImmediatelyStopped) return; if (t.eventPhase = t.AT_TARGET, t.currentTarget = t.target, this.notifyTarget(t, s), !t.propagationStopped && !t.propagationImmediatelyStopped) { t.eventPhase = t.BUBBLING_PHASE; for (let e = i.length - 2; e >= 0; e--)if (t.currentTarget = i[e], this.notifyTarget(t, s), t.propagationStopped || t.propagationImmediatelyStopped) return } } all(t, s, i = this.eo) { if (0 === i.length) return; t.eventPhase = t.BUBBLING_PHASE; const e = Array.isArray(s) ? s : [s]; for (let n = i.length - 1; n >= 0; n--)e.forEach(s => { t.currentTarget = i[n], this.notifyTarget(t, s) }) } propagationPath(t) { const s = [t]; for (let i = 0; i < 2048 && t !== this.rootTarget && t.parent; i++) { if (!t.parent) throw new Error("Cannot find propagation path to disconnected target"); s.push(t.parent), t = t.parent } return s.reverse(), s } hitTestMoveRecursive(t, s, i, e, n, r = !1) { let o = !1; if (this.oo(t)) return null; if ("dynamic" !== t.eventMode && "dynamic" !== s || (qo.pauseUpdate = !1), t.interactiveChildren && t.children) { const h = t.children; for (let a = h.length - 1; a >= 0; a--) { const u = h[a], l = this.hitTestMoveRecursive(u, this.ho(s) ? s : u.eventMode, i, e, n, r || n(t, i)); if (l) { if (l.length > 0 && !l[l.length - 1].parent) continue; const s = t.isInteractive(); (l.length > 0 || s) && (s && this.eo.push(t), l.push(t)), 0 === this.no.length && (this.no = l), o = !0 } } } const h = this.ho(s), a = t.isInteractive(); return a && a && this.eo.push(t), r || this.no.length > 0 ? null : o ? this.no : h && !n(t, i) && e(t, i) ? a ? [t] : [] : null } hitTestRecursive(t, s, i, e, n) { if (this.oo(t) || n(t, i)) return null; if ("dynamic" !== t.eventMode && "dynamic" !== s || (qo.pauseUpdate = !1), t.interactiveChildren && t.children) { const r = t.children, o = i; for (let i = r.length - 1; i >= 0; i--) { const h = r[i], a = this.hitTestRecursive(h, this.ho(s) ? s : h.eventMode, o, e, n); if (a) { if (a.length > 0 && !a[a.length - 1].parent) continue; const s = t.isInteractive(); return (a.length > 0 || s) && a.push(t), a } } } const r = this.ho(s), o = t.isInteractive(); return r && e(t, i) ? o ? [t] : [] : null } ho(t) { return "static" === t || "dynamic" === t } oo(t) { return !(t && t.visible && t.renderable && t.measurable) || "none" === t.eventMode || "passive" === t.eventMode && !t.interactiveChildren } hitPruneFn(t, s) { if (t.hitArea && (t.worldTransform.applyInverse(s, Qo), !t.hitArea.contains(Qo.x, Qo.y))) return !0; if (t.effects && t.effects.length) for (let i = 0; i < t.effects.length; i++) { const e = t.effects[i]; if (e.containsPoint && !e.containsPoint(s, this.hitTestFn)) return !0 } return !1 } hitTestFn(t, s) { return !!t.hitArea || !!t?.containsPoint && (t.worldTransform.applyInverse(s, Qo), t.containsPoint(Qo)) } notifyTarget(t, s) { if (!t.currentTarget.isInteractive()) return; s ?? (s = t.type); const i = `on${s}`; t.currentTarget[i]?.(t); const e = t.eventPhase === t.CAPTURING_PHASE || t.eventPhase === t.AT_TARGET ? `${s}capture` : s; this.ao(t, e), t.eventPhase === t.AT_TARGET && this.ao(t, s) } mapPointerDown(t) { if (!(t instanceof Yo)) return void Et(); const s = this.createPointerEvent(t); if (this.dispatchEvent(s, "pointerdown"), "touch" === s.pointerType) this.dispatchEvent(s, "touchstart"); else if ("mouse" === s.pointerType || "pen" === s.pointerType) { const t = 2 === s.button; this.dispatchEvent(s, t ? "rightdown" : "mousedown") } this.trackingData(t.pointerId).pressTargetsByButton[t.button] = s.composedPath(), this.freeEvent(s) } mapPointerMove(t) { if (!(t instanceof Yo)) return void Et(); this.eo.length = 0, this.no.length = 0, this.ro = !0; const s = this.createPointerEvent(t); this.ro = !1; const i = "mouse" === s.pointerType || "pen" === s.pointerType, e = this.trackingData(t.pointerId), n = this.findMountedTarget(e.overTargets); if (e.overTargets?.length > 0 && n !== s.target) { const e = "mousemove" === t.type ? "mouseout" : "pointerout", r = this.createPointerEvent(t, e, n); if (this.dispatchEvent(r, "pointerout"), i && this.dispatchEvent(r, "mouseout"), !s.composedPath().includes(n)) { const e = this.createPointerEvent(t, "pointerleave", n); for (e.eventPhase = e.AT_TARGET; e.target && !s.composedPath().includes(e.target);)e.currentTarget = e.target, this.notifyTarget(e), i && this.notifyTarget(e, "mouseleave"), e.target = e.target.parent; this.freeEvent(e) } this.freeEvent(r) } if (n !== s.target) { const e = "mousemove" === t.type ? "mouseover" : "pointerover", r = this.clonePointerEvent(s, e); this.dispatchEvent(r, "pointerover"), i && this.dispatchEvent(r, "mouseover"); let o = n?.parent; for (; o && o !== this.rootTarget.parent && o !== s.target;)o = o.parent; if (!o || o === this.rootTarget.parent) { const t = this.clonePointerEvent(s, "pointerenter"); for (t.eventPhase = t.AT_TARGET; t.target && t.target !== n && t.target !== this.rootTarget.parent;)t.currentTarget = t.target, this.notifyTarget(t), i && this.notifyTarget(t, "mouseenter"), t.target = t.target.parent; this.freeEvent(t) } this.freeEvent(r) } const r = [], o = this.enableGlobalMoveEvents ?? !0; this.moveOnAll ? r.push("pointermove") : this.dispatchEvent(s, "pointermove"), o && r.push("globalpointermove"), "touch" === s.pointerType && (this.moveOnAll ? r.splice(1, 0, "touchmove") : this.dispatchEvent(s, "touchmove"), o && r.push("globaltouchmove")), i && (this.moveOnAll ? r.splice(1, 0, "mousemove") : this.dispatchEvent(s, "mousemove"), o && r.push("globalmousemove"), this.cursor = s.target?.cursor), r.length > 0 && this.all(s, r), this.eo.length = 0, this.no.length = 0, e.overTargets = s.composedPath(), this.freeEvent(s) } mapPointerOver(t) { if (!(t instanceof Yo)) return void Et(); const s = this.trackingData(t.pointerId), i = this.createPointerEvent(t), e = "mouse" === i.pointerType || "pen" === i.pointerType; this.dispatchEvent(i, "pointerover"), e && this.dispatchEvent(i, "mouseover"), "mouse" === i.pointerType && (this.cursor = i.target?.cursor); const n = this.clonePointerEvent(i, "pointerenter"); for (n.eventPhase = n.AT_TARGET; n.target && n.target !== this.rootTarget.parent;)n.currentTarget = n.target, this.notifyTarget(n), e && this.notifyTarget(n, "mouseenter"), n.target = n.target.parent; s.overTargets = i.composedPath(), this.freeEvent(i), this.freeEvent(n) } mapPointerOut(t) { if (!(t instanceof Yo)) return void Et(); const s = this.trackingData(t.pointerId); if (s.overTargets) { const i = "mouse" === t.pointerType || "pen" === t.pointerType, e = this.findMountedTarget(s.overTargets), n = this.createPointerEvent(t, "pointerout", e); this.dispatchEvent(n), i && this.dispatchEvent(n, "mouseout"); const r = this.createPointerEvent(t, "pointerleave", e); for (r.eventPhase = r.AT_TARGET; r.target && r.target !== this.rootTarget.parent;)r.currentTarget = r.target, this.notifyTarget(r), i && this.notifyTarget(r, "mouseleave"), r.target = r.target.parent; s.overTargets = null, this.freeEvent(n), this.freeEvent(r) } this.cursor = null } mapPointerUp(t) { if (!(t instanceof Yo)) return void Et(); const s = performance.now(), i = this.createPointerEvent(t); if (this.dispatchEvent(i, "pointerup"), "touch" === i.pointerType) this.dispatchEvent(i, "touchend"); else if ("mouse" === i.pointerType || "pen" === i.pointerType) { const t = 2 === i.button; this.dispatchEvent(i, t ? "rightup" : "mouseup") } const e = this.trackingData(t.pointerId), n = this.findMountedTarget(e.pressTargetsByButton[t.button]); let r = n; if (n && !i.composedPath().includes(n)) { let s = n; for (; s && !i.composedPath().includes(s);) { if (i.currentTarget = s, this.notifyTarget(i, "pointerupoutside"), "touch" === i.pointerType) this.notifyTarget(i, "touchendoutside"); else if ("mouse" === i.pointerType || "pen" === i.pointerType) { const t = 2 === i.button; this.notifyTarget(i, t ? "rightupoutside" : "mouseupoutside") } s = s.parent } delete e.pressTargetsByButton[t.button], r = s } if (r) { const n = this.clonePointerEvent(i, "click"); n.target = r, n.path = null, e.clicksByButton[t.button] || (e.clicksByButton[t.button] = { clickCount: 0, target: n.target, timeStamp: s }); const o = e.clicksByButton[t.button]; if (o.target === n.target && s - o.timeStamp < 200 ? ++o.clickCount : o.clickCount = 1, o.target = n.target, o.timeStamp = s, n.detail = o.clickCount, "mouse" === n.pointerType) { const t = 2 === n.button; this.dispatchEvent(n, t ? "rightclick" : "click") } else "touch" === n.pointerType && this.dispatchEvent(n, "tap"); this.dispatchEvent(n, "pointertap"), this.freeEvent(n) } this.freeEvent(i) } mapPointerUpOutside(t) { if (!(t instanceof Yo)) return void Et(); const s = this.trackingData(t.pointerId), i = this.findMountedTarget(s.pressTargetsByButton[t.button]), e = this.createPointerEvent(t); if (i) { let n = i; for (; n;)e.currentTarget = n, this.notifyTarget(e, "pointerupoutside"), "touch" === e.pointerType ? this.notifyTarget(e, "touchendoutside") : "mouse" !== e.pointerType && "pen" !== e.pointerType || this.notifyTarget(e, 2 === e.button ? "rightupoutside" : "mouseupoutside"), n = n.parent; delete s.pressTargetsByButton[t.button] } this.freeEvent(e) } mapWheel(t) { if (!(t instanceof Ko)) return void Et(); const s = this.createWheelEvent(t); this.dispatchEvent(s), this.freeEvent(s) } findMountedTarget(t) { if (!t) return null; let s = t[0]; for (let i = 1; i < t.length && t[i].parent === s; i++)s = t[i]; return s } createPointerEvent(t, s, i) { const e = this.allocateEvent(Yo); return this.copyPointerData(t, e), this.copyMouseData(t, e), this.copyData(t, e), e.nativeEvent = t.nativeEvent, e.originalEvent = t, e.target = i ?? this.hitTest(e.global.x, e.global.y) ?? this.no[0], "string" == typeof s && (e.type = s), e } createWheelEvent(t) { const s = this.allocateEvent(Ko); return this.copyWheelData(t, s), this.copyMouseData(t, s), this.copyData(t, s), s.nativeEvent = t.nativeEvent, s.originalEvent = t, s.target = this.hitTest(s.global.x, s.global.y), s } clonePointerEvent(t, s) { const i = this.allocateEvent(Yo); return i.nativeEvent = t.nativeEvent, i.originalEvent = t.originalEvent, this.copyPointerData(t, i), this.copyMouseData(t, i), this.copyData(t, i), i.target = t.target, i.path = t.composedPath().slice(), i.type = s ?? i.type, i } copyWheelData(t, s) { s.deltaMode = t.deltaMode, s.deltaX = t.deltaX, s.deltaY = t.deltaY, s.deltaZ = t.deltaZ } copyPointerData(t, s) { t instanceof Yo && s instanceof Yo && (s.pointerId = t.pointerId, s.width = t.width, s.height = t.height, s.isPrimary = t.isPrimary, s.pointerType = t.pointerType, s.pressure = t.pressure, s.tangentialPressure = t.tangentialPressure, s.tiltX = t.tiltX, s.tiltY = t.tiltY, s.twist = t.twist) } copyMouseData(t, s) { t instanceof Xo && s instanceof Xo && (s.altKey = t.altKey, s.button = t.button, s.buttons = t.buttons, s.client.copyFrom(t.client), s.ctrlKey = t.ctrlKey, s.metaKey = t.metaKey, s.movement.copyFrom(t.movement), s.screen.copyFrom(t.screen), s.shiftKey = t.shiftKey, s.global.copyFrom(t.global)) } copyData(t, s) { s.isTrusted = t.isTrusted, s.srcElement = t.srcElement, s.timeStamp = performance.now(), s.type = t.type, s.detail = t.detail, s.view = t.view, s.which = t.which, s.layer.copyFrom(t.layer), s.page.copyFrom(t.page) } trackingData(t) { return this.mappingState.trackingData[t] || (this.mappingState.trackingData[t] = { pressTargetsByButton: {}, clicksByButton: {}, overTarget: null }), this.mappingState.trackingData[t] } allocateEvent(t) { this.eventPool.has(t) || this.eventPool.set(t, []); const s = this.eventPool.get(t).pop() || new t(this); return s.eventPhase = s.NONE, s.currentTarget = null, s.defaultPrevented = !1, s.path = null, s.target = null, s } freeEvent(t) { if (t.manager !== this) throw new Error("It is illegal to free an event not managed by this EventBoundary!"); const s = t.constructor; this.eventPool.has(s) || this.eventPool.set(s, []), this.eventPool.get(s).push(t) } ao(t, s) { const i = t.currentTarget.P[s]; if (i) if ("fn" in i) i.once && t.currentTarget.removeListener(s, i.fn, void 0, !0), i.fn.call(i.context, t); else for (let e = 0, n = i.length; e < n && !t.propagationImmediatelyStopped; e++)i[e].once && t.currentTarget.removeListener(s, i[e].fn, void 0, !0), i[e].fn.call(i[e].context, t) } } const th = { touchstart: "pointerdown", touchend: "pointerup", touchendoutside: "pointerupoutside", touchmove: "pointermove", touchcancel: "pointercancel" }, sh = class t { constructor(s) { this.supportsTouchEvents = "ontouchstart" in globalThis, this.supportsPointerEvents = !!globalThis.PointerEvent, this.domElement = null, this.resolution = 1, this.renderer = s, this.rootBoundary = new Jo(null), qo.init(this), this.autoPreventDefault = !0, this.uo = !1, this.io = new Yo(null), this.lo = new Ko(null), this.cursorStyles = { default: "inherit", pointer: "pointer" }, this.features = new Proxy({ ...t.defaultEventFeatures }, { set: (t, s, i) => ("globalMove" === s && (this.rootBoundary.enableGlobalMoveEvents = i), t[s] = i, !0) }), this.co = this.co.bind(this), this.fo = this.fo.bind(this), this.do = this.do.bind(this), this.po = this.po.bind(this), this.onWheel = this.onWheel.bind(this) } static get defaultEventMode() { return this.mo } init(s) { const { canvas: i, resolution: e } = this.renderer; this.setTargetElement(i), this.resolution = e, t.mo = s.eventMode ?? "passive", Object.assign(this.features, s.eventFeatures ?? {}), this.rootBoundary.enableGlobalMoveEvents = this.features.globalMove } resolutionChange(t) { this.resolution = t } destroy() { qo.destroy(), this.setTargetElement(null), this.renderer = null, this.vo = null } setCursor(t) { t || (t = "default"); let s = !0; if (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas && (s = !1), this.vo === t) return; this.vo = t; const i = this.cursorStyles[t]; if (i) switch (typeof i) { case "string": s && (this.domElement.style.cursor = i); break; case "function": i(t); break; case "object": s && Object.assign(this.domElement.style, i) } else s && "string" == typeof t && !Object.prototype.hasOwnProperty.call(this.cursorStyles, t) && (this.domElement.style.cursor = t) } get pointer() { return this.io } co(t) { if (!this.features.click) return; this.rootBoundary.rootTarget = this.renderer.lastObjectRendered; const s = this.bo(t); this.autoPreventDefault && s[0].isNormalized && (t.cancelable || !("cancelable" in t)) && t.preventDefault(); for (let i = 0, e = s.length; i < e; i++) { const t = s[i], e = this.xo(this.io, t); this.rootBoundary.mapEvent(e) } this.setCursor(this.rootBoundary.cursor) } fo(t) { if (!this.features.move) return; this.rootBoundary.rootTarget = this.renderer.lastObjectRendered, qo.pointerMoved(); const s = this.bo(t); for (let i = 0, e = s.length; i < e; i++) { const t = this.xo(this.io, s[i]); this.rootBoundary.mapEvent(t) } this.setCursor(this.rootBoundary.cursor) } do(t) { if (!this.features.click) return; this.rootBoundary.rootTarget = this.renderer.lastObjectRendered; let s = t.target; t.composedPath && t.composedPath().length > 0 && (s = t.composedPath()[0]); const i = s !== this.domElement ? "outside" : "", e = this.bo(t); for (let n = 0, r = e.length; n < r; n++) { const t = this.xo(this.io, e[n]); t.type += i, this.rootBoundary.mapEvent(t) } this.setCursor(this.rootBoundary.cursor) } po(t) { if (!this.features.click) return; this.rootBoundary.rootTarget = this.renderer.lastObjectRendered; const s = this.bo(t); for (let i = 0, e = s.length; i < e; i++) { const t = this.xo(this.io, s[i]); this.rootBoundary.mapEvent(t) } this.setCursor(this.rootBoundary.cursor) } onWheel(t) { if (!this.features.wheel) return; const s = this.normalizeWheelEvent(t); this.rootBoundary.rootTarget = this.renderer.lastObjectRendered, this.rootBoundary.mapEvent(s) } setTargetElement(t) { this.yo(), this.domElement = t, qo.domElement = t, this.wo() } wo() { if (this.uo || !this.domElement) return; qo.addTickerListener(); const t = this.domElement.style; t && (globalThis.navigator.msPointerEnabled ? (t.msContentZooming = "none", t.msTouchAction = "none") : this.supportsPointerEvents && (t.touchAction = "none")), this.supportsPointerEvents ? (globalThis.document.addEventListener("pointermove", this.fo, !0), this.domElement.addEventListener("pointerdown", this.co, !0), this.domElement.addEventListener("pointerleave", this.po, !0), this.domElement.addEventListener("pointerover", this.po, !0), globalThis.addEventListener("pointerup", this.do, !0)) : (globalThis.document.addEventListener("mousemove", this.fo, !0), this.domElement.addEventListener("mousedown", this.co, !0), this.domElement.addEventListener("mouseout", this.po, !0), this.domElement.addEventListener("mouseover", this.po, !0), globalThis.addEventListener("mouseup", this.do, !0), this.supportsTouchEvents && (this.domElement.addEventListener("touchstart", this.co, !0), this.domElement.addEventListener("touchend", this.do, !0), this.domElement.addEventListener("touchmove", this.fo, !0))), this.domElement.addEventListener("wheel", this.onWheel, { passive: !0, capture: !0 }), this.uo = !0 } yo() { if (!this.uo || !this.domElement) return; qo.removeTickerListener(); const t = this.domElement.style; t && (globalThis.navigator.msPointerEnabled ? (t.msContentZooming = "", t.msTouchAction = "") : this.supportsPointerEvents && (t.touchAction = "")), this.supportsPointerEvents ? (globalThis.document.removeEventListener("pointermove", this.fo, !0), this.domElement.removeEventListener("pointerdown", this.co, !0), this.domElement.removeEventListener("pointerleave", this.po, !0), this.domElement.removeEventListener("pointerover", this.po, !0), globalThis.removeEventListener("pointerup", this.do, !0)) : (globalThis.document.removeEventListener("mousemove", this.fo, !0), this.domElement.removeEventListener("mousedown", this.co, !0), this.domElement.removeEventListener("mouseout", this.po, !0), this.domElement.removeEventListener("mouseover", this.po, !0), globalThis.removeEventListener("mouseup", this.do, !0), this.supportsTouchEvents && (this.domElement.removeEventListener("touchstart", this.co, !0), this.domElement.removeEventListener("touchend", this.do, !0), this.domElement.removeEventListener("touchmove", this.fo, !0))), this.domElement.removeEventListener("wheel", this.onWheel, !0), this.domElement = null, this.uo = !1 } mapPositionToPoint(t, s, i) { const e = this.domElement.isConnected ? this.domElement.getBoundingClientRect() : { width: this.domElement.width, height: this.domElement.height, left: 0, top: 0 }, n = 1 / this.resolution; t.x = (s - e.left) * (this.domElement.width / e.width) * n, t.y = (i - e.top) * (this.domElement.height / e.height) * n } bo(t) { const s = []; if (this.supportsTouchEvents && t instanceof TouchEvent) for (let i = 0, e = t.changedTouches.length; i < e; i++) { const e = t.changedTouches[i]; void 0 === e.button && (e.button = 0), void 0 === e.buttons && (e.buttons = 1), void 0 === e.isPrimary && (e.isPrimary = 1 === t.touches.length && "touchstart" === t.type), void 0 === e.width && (e.width = e.radiusX || 1), void 0 === e.height && (e.height = e.radiusY || 1), void 0 === e.tiltX && (e.tiltX = 0), void 0 === e.tiltY && (e.tiltY = 0), void 0 === e.pointerType && (e.pointerType = "touch"), void 0 === e.pointerId && (e.pointerId = e.identifier || 0), void 0 === e.pressure && (e.pressure = e.force || .5), void 0 === e.twist && (e.twist = 0), void 0 === e.tangentialPressure && (e.tangentialPressure = 0), void 0 === e.layerX && (e.layerX = e.offsetX = e.clientX), void 0 === e.layerY && (e.layerY = e.offsetY = e.clientY), e.isNormalized = !0, e.type = t.type, s.push(e) } else if (!globalThis.MouseEvent || t instanceof MouseEvent && !(this.supportsPointerEvents && t instanceof globalThis.PointerEvent)) { const i = t; void 0 === i.isPrimary && (i.isPrimary = !0), void 0 === i.width && (i.width = 1), void 0 === i.height && (i.height = 1), void 0 === i.tiltX && (i.tiltX = 0), void 0 === i.tiltY && (i.tiltY = 0), void 0 === i.pointerType && (i.pointerType = "mouse"), void 0 === i.pointerId && (i.pointerId = 1), void 0 === i.pressure && (i.pressure = .5), void 0 === i.twist && (i.twist = 0), void 0 === i.tangentialPressure && (i.tangentialPressure = 0), i.isNormalized = !0, s.push(i) } else s.push(t); return s } normalizeWheelEvent(t) { const s = this.lo; return this.Mo(s, t), s.deltaX = t.deltaX, s.deltaY = t.deltaY, s.deltaZ = t.deltaZ, s.deltaMode = t.deltaMode, this.mapPositionToPoint(s.screen, t.clientX, t.clientY), s.global.copyFrom(s.screen), s.offset.copyFrom(s.screen), s.nativeEvent = t, s.type = t.type, s } xo(t, s) { return t.originalEvent = null, t.nativeEvent = s, t.pointerId = s.pointerId, t.width = s.width, t.height = s.height, t.isPrimary = s.isPrimary, t.pointerType = s.pointerType, t.pressure = s.pressure, t.tangentialPressure = s.tangentialPressure, t.tiltX = s.tiltX, t.tiltY = s.tiltY, t.twist = s.twist, this.Mo(t, s), this.mapPositionToPoint(t.screen, s.clientX, s.clientY), t.global.copyFrom(t.screen), t.offset.copyFrom(t.screen), t.isTrusted = s.isTrusted, "pointerleave" === t.type && (t.type = "pointerout"), t.type.startsWith("mouse") && (t.type = t.type.replace("mouse", "pointer")), t.type.startsWith("touch") && (t.type = th[t.type] || t.type), t } Mo(t, s) { t.isTrusted = s.isTrusted, t.srcElement = s.srcElement, t.timeStamp = performance.now(), t.type = s.type, t.altKey = s.altKey, t.button = s.button, t.buttons = s.buttons, t.client.x = s.clientX, t.client.y = s.clientY, t.ctrlKey = s.ctrlKey, t.metaKey = s.metaKey, t.movement.x = s.movementX, t.movement.y = s.movementY, t.page.x = s.pageX, t.page.y = s.pageY, t.relatedTarget = null, t.shiftKey = s.shiftKey } }; sh.extension = { name: "events", type: [r.WebGLSystem, r.CanvasSystem, r.WebGPUSystem], priority: -1 }, sh.defaultEventFeatures = { move: !0, globalMove: !0, click: !0, wheel: !0 }; let ih = sh; const eh = { onclick: null, onmousedown: null, onmouseenter: null, onmouseleave: null, onmousemove: null, onglobalmousemove: null, onmouseout: null, onmouseover: null, onmouseup: null, onmouseupoutside: null, onpointercancel: null, onpointerdown: null, onpointerenter: null, onpointerleave: null, onpointermove: null, onglobalpointermove: null, onpointerout: null, onpointerover: null, onpointertap: null, onpointerup: null, onpointerupoutside: null, onrightclick: null, onrightdown: null, onrightup: null, onrightupoutside: null, ontap: null, ontouchcancel: null, ontouchend: null, ontouchendoutside: null, ontouchmove: null, onglobaltouchmove: null, ontouchstart: null, onwheel: null, get interactive() { return "dynamic" === this.eventMode || "static" === this.eventMode }, set interactive(t) { this.eventMode = t ? "static" : "passive" }, To: void 0, get eventMode() { return this.To ?? ih.defaultEventMode }, set eventMode(t) { this.To = t }, isInteractive() { return "static" === this.eventMode || "dynamic" === this.eventMode }, interactiveChildren: !0, hitArea: null, addEventListener(t, s, i) { const e = "boolean" == typeof i && i || "object" == typeof i && i.capture, n = "object" == typeof i ? i.signal : void 0, r = "object" == typeof i && !0 === i.once, o = "function" == typeof s ? void 0 : s; t = e ? `${t}capture` : t; const h = "function" == typeof s ? s : s.handleEvent, a = this; n && n.addEventListener("abort", () => { a.off(t, h, o) }), r ? a.once(t, h, o) : a.on(t, h, o) }, removeEventListener(t, s, i) { const e = "function" == typeof s ? void 0 : s; t = "boolean" == typeof i && i || "object" == typeof i && i.capture ? `${t}capture` : t, s = "function" == typeof s ? s : s.handleEvent, this.off(t, s, e) }, dispatchEvent(t) { if (!(t instanceof ni)) throw new Error("Container cannot propagate events outside of the Federated Events API"); return t.defaultPrevented = !1, t.path = null, t.target = this, t.manager.dispatchEvent(t), !t.defaultPrevented } }; var nh = "struct GlobalFilterUniforms {\n  uInputSize: vec4<f32>,\n  uInputPixel: vec4<f32>,\n  uInputClamp: vec4<f32>,\n  uOutputFrame: vec4<f32>,\n  uGlobalFrame: vec4<f32>,\n  uOutputTexture: vec4<f32>,\n};\n\n@group(0) @binding(0) var <uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\n@group(0) @binding(2) var uSampler: sampler;\n\nstruct VSOutput {\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv: vec2<f32>\n};\n\nfn filterVertexPosition(aPosition: vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0 * gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord(aPosition: vec2<f32>) -> vec2<f32>\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\n@vertex\nfn mainVertex(\n  @location(0) aPosition: vec2<f32>,\n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition)\n  );\n}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n) -> @location(0) vec4<f32> {\n    return textureSample(uTexture, uSampler, uv);\n}\n"; class rh extends ee { constructor() { super({ gpuProgram: Ni.from({ vertex: { source: nh, entryPoint: "mainVertex" }, fragment: { source: nh, entryPoint: "mainFragment" }, name: "passthrough-filter" }), glProgram: Gi.from({ vertex: "in vec2 aPosition;\nout vec2 vTextureCoord;\n\nuniform vec4 uInputSize;\nuniform vec4 uOutputFrame;\nuniform vec4 uOutputTexture;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\n    \n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n", fragment: "in vec2 vTextureCoord;\nout vec4 finalColor;\nuniform sampler2D uTexture;\nvoid main() {\n    finalColor = texture(uTexture, vTextureCoord);\n}\n", name: "passthrough-filter" }) }) } } class oh { constructor(t) { this.Gi = t } push(t, s, i) { this.Gi.renderPipes.batch.break(i), i.add({ renderPipeId: "filter", canBundle: !1, action: "pushFilter", container: s, filterEffect: t }) } pop(t, s, i) { this.Gi.renderPipes.batch.break(i), i.add({ renderPipeId: "filter", action: "popFilter", canBundle: !1 }) } execute(t) { "pushFilter" === t.action ? this.Gi.filter.push(t) : "popFilter" === t.action && this.Gi.filter.pop() } destroy() { this.Gi = null } } oh.extension = { type: [r.WebGLPipes, r.WebGPUPipes, r.CanvasPipes], name: "filter" }; const hh = new w, ah = new Wn({ attributes: { aPosition: { buffer: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]), format: "float32x2", stride: 8, offset: 0 } }, indexBuffer: new Uint32Array([0, 1, 2, 0, 2, 3]) }); class uh { constructor() { this.skip = !1, this.inputTexture = null, this.backTexture = null, this.filters = null, this.bounds = new tt, this.container = null, this.blendRequired = !1, this.outputRenderSurface = null, this.globalFrame = { x: 0, y: 0, width: 0, height: 0 }, this.firstEnabledIndex = -1, this.lastEnabledIndex = -1 } } class lh { constructor(t) { this.Ao = 0, this.Co = [], this._o = new Yi({ uInputSize: { value: new Float32Array(4), type: "vec4<f32>" }, uInputPixel: { value: new Float32Array(4), type: "vec4<f32>" }, uInputClamp: { value: new Float32Array(4), type: "vec4<f32>" }, uOutputFrame: { value: new Float32Array(4), type: "vec4<f32>" }, uGlobalFrame: { value: new Float32Array(4), type: "vec4<f32>" }, uOutputTexture: { value: new Float32Array(4), type: "vec4<f32>" } }), this.So = new Ki({}), this.renderer = t } get activeBackTexture() { return this.Po?.backTexture } push(t) { const s = this.renderer, i = t.filterEffect.filters, e = this.ko(); e.skip = !1, e.filters = i, e.container = t.container, e.outputRenderSurface = s.renderTarget.renderSurface; const n = s.renderTarget.renderTarget.colorTexture.source, r = n.resolution, o = n.antialias; if (i.every(t => !t.enabled)) return void (e.skip = !0); const h = e.bounds; if (this.Fo(t, h), this.Eo(e, s.renderTarget.rootViewPort, o, r, 1), e.skip) return; const a = this.Ro(), u = this.Oo(r); let l = 0, c = 0; a && (l = a.bounds.minX, c = a.bounds.minY), this.Uo(e, l, c, u, n.width, n.height), this.Io(e, h, s, a) } generateFilteredTexture({ texture: t, filters: s }) { const i = this.ko(); this.Po = i, i.skip = !1, i.filters = s; const e = t.source, n = e.resolution, r = e.antialias; if (s.every(t => !t.enabled)) return i.skip = !0, t; const o = i.bounds; if (o.addRect(t.frame), this.Eo(i, o.rectangle, r, n, 0), i.skip) return t; const h = n; this.Uo(i, 0, 0, h, e.width, e.height), i.outputRenderSurface = fs.getOptimalTexture(o.width, o.height, i.resolution, i.antialias), i.backTexture = Z.EMPTY, i.inputTexture = t, this.renderer.renderTarget.finishRenderPass(), this.Bo(i, !0); const a = i.outputRenderSurface; return a.source.alphaMode = "premultiplied-alpha", a } pop() { const t = this.renderer, s = this.Go(); s.skip || (t.globalUniforms.pop(), t.renderTarget.finishRenderPass(), this.Po = s, this.Bo(s, !1), s.blendRequired && fs.returnTexture(s.backTexture), fs.returnTexture(s.inputTexture)) } getBackTexture(t, s, i) { const e = t.colorTexture.source.G, n = fs.getOptimalTexture(s.width, s.height, e, !1); let r = s.minX, o = s.minY; i && (r -= i.minX, o -= i.minY), r = Math.floor(r * e), o = Math.floor(o * e); const h = Math.ceil(s.width * e), a = Math.ceil(s.height * e); return this.renderer.renderTarget.copyToTexture(t, n, { x: r, y: o }, { width: h, height: a }, { x: 0, y: 0 }), n } applyFilter(t, s, i, e) { const n = this.renderer, r = this.Po, o = r.outputRenderSurface === i, h = n.renderTarget.rootRenderTarget.colorTexture.source.G, a = this.Oo(h); let u = 0, l = 0; if (o) { const t = this.$o(); u = t.x, l = t.y } this.zo(s, i, r, u, l, a, o, e); const c = t.enabled ? t : this.Do(); this.jo(c, s, n) } calculateSpriteMatrix(t, s) { const i = this.Po, e = t.set(i.inputTexture.K.width, 0, 0, i.inputTexture.K.height, i.bounds.minX, i.bounds.minY), n = s.worldTransform.copyTo(w.shared), r = s.renderGroup || s.parentRenderGroup; return r && r.cacheToLocalTransform && n.prepend(r.cacheToLocalTransform), n.invert(), e.prepend(n), e.scale(1 / s.texture.orig.width, 1 / s.texture.orig.height), e.translate(s.anchor.x, s.anchor.y), e } destroy() { this.Lo?.destroy(!0), this.Lo = null } Do() { return this.Lo ?? (this.Lo = new rh), this.Lo } jo(t, s, i) { if (i.renderPipes.uniformBatch) { const t = i.renderPipes.uniformBatch.getUboResource(this._o); this.So.setResource(t, 0) } else this.So.setResource(this._o, 0); this.So.setResource(s.source, 1), this.So.setResource(s.source.style, 2), t.groups[0] = this.So, i.encoder.draw({ geometry: ah, shader: t, state: t.je, topology: "triangle-list" }), i.type === Zi.WEBGL && i.renderTarget.finishRenderPass() } Io(t, s, i, e) { if (t.backTexture = Z.EMPTY, t.inputTexture = fs.getOptimalTexture(s.width, s.height, t.resolution, t.antialias), t.blendRequired) { i.renderTarget.finishRenderPass(); const n = i.renderTarget.getRenderTarget(t.outputRenderSurface); t.backTexture = this.getBackTexture(n, s, e?.bounds) } i.renderTarget.bind(t.inputTexture, !0), i.globalUniforms.push({ offset: s }) } Uo(t, s, i, e, n, r) { const o = t.globalFrame; o.x = s * e, o.y = i * e, o.width = n * e, o.height = r * e } zo(t, s, i, e, n, r, o, h) { const a = this._o.uniforms, u = a.uOutputFrame, l = a.uInputSize, c = a.uInputPixel, f = a.uInputClamp, d = a.uGlobalFrame, p = a.uOutputTexture; o ? (u[0] = i.bounds.minX - e, u[1] = i.bounds.minY - n) : (u[0] = 0, u[1] = 0), u[2] = t.frame.width, u[3] = t.frame.height, l[0] = t.source.width, l[1] = t.source.height, l[2] = 1 / l[0], l[3] = 1 / l[1], c[0] = t.source.pixelWidth, c[1] = t.source.pixelHeight, c[2] = 1 / c[0], c[3] = 1 / c[1], f[0] = .5 * c[2], f[1] = .5 * c[3], f[2] = t.frame.width * l[2] - .5 * c[2], f[3] = t.frame.height * l[3] - .5 * c[3]; const m = this.renderer.renderTarget.rootRenderTarget.colorTexture; d[0] = e * r, d[1] = n * r, d[2] = m.source.width * r, d[3] = m.source.height * r, s instanceof Z && (s.source.resource = null); const g = this.renderer.renderTarget.getRenderTarget(s); this.renderer.renderTarget.bind(s, !!h), s instanceof Z ? (p[0] = s.frame.width, p[1] = s.frame.height) : (p[0] = g.width, p[1] = g.height), p[2] = g.isRoot ? -1 : 1, this._o.update() } Oo(t) { let s = this.Ao - 1; for (; s > 0 && this.Co[s].skip;)--s; return s > 0 && this.Co[s].inputTexture ? this.Co[s].inputTexture.source.G : t } $o() { let t = 0, s = 0, i = this.Ao; for (; i > 0;) { i--; const e = this.Co[i]; if (!e.skip) { t = e.bounds.minX, s = e.bounds.minY; break } } return { x: t, y: s } } Fo(t, s) { if (t.renderables ? function (t, s) { s.clear(); const i = s.matrix; for (let e = 0; e < t.length; e++) { const i = t[e]; if (i.globalDisplayStatus < 7) continue; const n = i.renderGroup ?? i.parentRenderGroup; s.matrix = n?.isCachedAsTexture ? hh.copyFrom(n.textureOffsetInverseTransform).append(i.worldTransform) : n?.Vt ? hh.copyFrom(n.Vt.inverseWorldTransform).append(i.groupTransform) : i.worldTransform, s.addBounds(i.bounds) } s.matrix = i }(t.renderables, s) : t.filterEffect.filterArea ? (s.clear(), s.addRect(t.filterEffect.filterArea), s.applyMatrix(t.container.worldTransform)) : t.container.getFastGlobalBounds(!0, s), t.container) { const i = (t.container.renderGroup || t.container.parentRenderGroup).cacheToLocalTransform; i && s.applyMatrix(i) } } Bo(t, s) { const i = t.inputTexture, e = t.bounds, n = t.filters, r = t.firstEnabledIndex, o = t.lastEnabledIndex; if (this.So.setResource(i.source.style, 2), this.So.setResource(t.backTexture.source, 3), r === o) n[r].apply(this, i, t.outputRenderSurface, s); else { let i = t.inputTexture; const h = fs.getOptimalTexture(e.width, e.height, i.source.G, !1); let a = h; for (let t = r; t < o; t++) { const s = n[t]; if (!s.enabled) continue; s.apply(this, i, a, !0); const e = i; i = a, a = e } n[o].apply(this, i, t.outputRenderSurface, s), fs.returnTexture(h) } } Eo(t, s, i, e, n) { const r = this.renderer, o = t.bounds, h = t.filters; let a = 1 / 0, u = 0, l = !0, c = !1, f = !1, d = !0, p = -1, m = -1; for (let g = 0; g < h.length; g++) { const t = h[g]; if (t.enabled) { if (-1 === p && (p = g), m = g, a = Math.min(a, "inherit" === t.resolution ? e : t.resolution), u += t.padding, "off" === t.antialias ? l = !1 : "inherit" === t.antialias && l && (l = i), t.clipToViewport || (d = !1), !(t.compatibleRenderers & r.type)) { f = !1; break } if (t.blendRequired && !(r.backBuffer?.useBackBuffer ?? 1)) { Et(), f = !1; break } f = !0, c || (c = t.blendRequired) } } f ? (d && o.fitBounds(0, s.width / e, 0, s.height / e), o.scale(a).ceil().scale(1 / a).pad((0 | u) * n), o.isPositive ? (t.antialias = l, t.resolution = a, t.blendRequired = c, t.firstEnabledIndex = p, t.lastEnabledIndex = m) : t.skip = !0) : t.skip = !0 } Go() { return this.Ao--, this.Co[this.Ao] } Ro() { let t, s = this.Ao - 1; for (; s > 0 && (s--, t = this.Co[s], t.skip);); return t } ko() { let t = this.Co[this.Ao]; return t || (t = this.Co[this.Ao] = new uh), this.Ao++, t } } lh.extension = { type: [r.WebGLSystem, r.WebGPUSystem], name: "filter" }; var ch = "struct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\nstruct MaskUniforms {\n  uFilterMatrix:mat3x3<f32>,\n  uMaskClamp:vec4<f32>,\n  uAlpha:f32,\n  uInverse:f32,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\n@group(0) @binding(2) var uSampler : sampler;\n\n@group(1) @binding(0) var<uniform> filterUniforms : MaskUniforms;\n@group(1) @binding(1) var uMaskTexture: texture_2d<f32>;\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>,\n    @location(1) filterUv : vec2<f32>,\n};\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);\n}\n\nfn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return ( filterUniforms.uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\n}\n\nfn getSize() -> vec2<f32>\n{\n  return gfu.uGlobalFrame.zw;\n}\n\n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>,\n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition),\n   getFilterCoord(aPosition)\n  );\n}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @location(1) filterUv: vec2<f32>,\n  @builtin(position) position: vec4<f32>\n) -> @location(0) vec4<f32> {\n\n    var maskClamp = filterUniforms.uMaskClamp;\n    var uAlpha = filterUniforms.uAlpha;\n\n    var clip = step(3.5,\n      step(maskClamp.x, filterUv.x) +\n      step(maskClamp.y, filterUv.y) +\n      step(filterUv.x, maskClamp.z) +\n      step(filterUv.y, maskClamp.w));\n\n    var mask = textureSample(uMaskTexture, uSampler, filterUv);\n    var source = textureSample(uTexture, uSampler, uv);\n    var alphaMul = 1.0 - uAlpha * (1.0 - mask.a);\n\n    var a: f32 = alphaMul * mask.r * uAlpha * clip;\n\n    if (filterUniforms.uInverse == 1.0) {\n        a = 1.0 - a;\n    }\n\n    return source * a;\n}\n"; class fh extends ee { constructor(t) { const { sprite: s, ...i } = t, e = new K(s.texture), n = new Yi({ uFilterMatrix: { value: new w, type: "mat3x3<f32>" }, uMaskClamp: { value: e.uClampFrame, type: "vec4<f32>" }, uAlpha: { value: 1, type: "f32" }, uInverse: { value: t.inverse ? 1 : 0, type: "f32" } }); super({ ...i, gpuProgram: Ni.from({ vertex: { source: ch, entryPoint: "mainVertex" }, fragment: { source: ch, entryPoint: "mainFragment" } }), glProgram: Gi.from({ vertex: "in vec2 aPosition;\n\nout vec2 vTextureCoord;\nout vec2 vMaskCoord;\n\n\nuniform vec4 uInputSize;\nuniform vec4 uOutputFrame;\nuniform vec4 uOutputTexture;\nuniform mat3 uFilterMatrix;\n\nvec4 filterVertexPosition(  vec2 aPosition )\n{\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\n       \n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord(  vec2 aPosition )\n{\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\n}\n\nvec2 getFilterCoord( vec2 aPosition )\n{\n    return  ( uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\n}   \n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition(aPosition);\n    vTextureCoord = filterTextureCoord(aPosition);\n    vMaskCoord = getFilterCoord(aPosition);\n}\n", fragment: "in vec2 vMaskCoord;\nin vec2 vTextureCoord;\n\nuniform sampler2D uTexture;\nuniform sampler2D uMaskTexture;\n\nuniform float uAlpha;\nuniform vec4 uMaskClamp;\nuniform float uInverse;\n\nout vec4 finalColor;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(uMaskClamp.x, vMaskCoord.x) +\n        step(uMaskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, uMaskClamp.z) +\n        step(vMaskCoord.y, uMaskClamp.w));\n\n    // TODO look into why this is needed\n    float npmAlpha = uAlpha;\n    vec4 original = texture(uTexture, vTextureCoord);\n    vec4 masky = texture(uMaskTexture, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    float a = alphaMul * masky.r * npmAlpha * clip;\n\n    if (uInverse == 1.0) {\n        a = 1.0 - a;\n    }\n\n    finalColor = original * a;\n}\n", name: "mask-filter" }), clipToViewport: !1, resources: { filterUniforms: n, uMaskTexture: s.texture.source } }), this.sprite = s, this.Z = e } set inverse(t) { this.resources.filterUniforms.uniforms.uInverse = t ? 1 : 0 } get inverse() { return 1 === this.resources.filterUniforms.uniforms.uInverse } apply(t, s, i, e) { this.Z.texture = this.sprite.texture, t.calculateSpriteMatrix(this.resources.filterUniforms.uniforms.uFilterMatrix, this.sprite).prepend(this.Z.mapCoord), this.resources.uMaskTexture = this.sprite.texture.source, t.applyFilter(this, s, i, e) } } class dh extends xs { constructor(t) { t instanceof Io && (t = { context: t }); const { context: s, roundPixels: i, ...e } = t || {}; super({ label: "Graphics", ...e }), this.renderPipeId = "graphics", this.Cs = s || (this.Vo = new Io), this.Cs.on("update", this.onViewUpdate, this), this.didViewUpdate = !0, this.allowChildren = !1, this.roundPixels = i ?? !1 } set context(t) { t !== this.Cs && (this.Cs.off("update", this.onViewUpdate, this), this.Cs = t, this.Cs.on("update", this.onViewUpdate, this), this.onViewUpdate()) } get context() { return this.Cs } get bounds() { return this.Cs.bounds } updateBounds() { } containsPoint(t) { return this.Cs.containsPoint(t) } destroy(t) { this.Vo && !t ? this.Vo.destroy(t) : !0 !== t && !0 !== t?.context || this.Cs.destroy(t), this.Vo = null, this.Cs = null, super.destroy(t) } No(t, s) { return this.context[t](...s), this } setFillStyle(...t) { return this.No("setFillStyle", t) } setStrokeStyle(...t) { return this.No("setStrokeStyle", t) } fill(...t) { return this.No("fill", t) } stroke(...t) { return this.No("stroke", t) } texture(...t) { return this.No("texture", t) } beginPath() { return this.No("beginPath", []) } cut() { return this.No("cut", []) } arc(...t) { return this.No("arc", t) } arcTo(...t) { return this.No("arcTo", t) } arcToSvg(...t) { return this.No("arcToSvg", t) } bezierCurveTo(...t) { return this.No("bezierCurveTo", t) } closePath() { return this.No("closePath", []) } ellipse(...t) { return this.No("ellipse", t) } circle(...t) { return this.No("circle", t) } path(...t) { return this.No("path", t) } lineTo(...t) { return this.No("lineTo", t) } moveTo(...t) { return this.No("moveTo", t) } quadraticCurveTo(...t) { return this.No("quadraticCurveTo", t) } rect(...t) { return this.No("rect", t) } roundRect(...t) { return this.No("roundRect", t) } poly(...t) { return this.No("poly", t) } regularPoly(...t) { return this.No("regularPoly", t) } roundPoly(...t) { return this.No("roundPoly", t) } roundShape(...t) { return this.No("roundShape", t) } filletRect(...t) { return this.No("filletRect", t) } chamferRect(...t) { return this.No("chamferRect", t) } star(...t) { return this.No("star", t) } svg(...t) { return this.No("svg", t) } restore(...t) { return this.No("restore", t) } save() { return this.No("save", []) } getTransform() { return this.context.getTransform() } resetTransform() { return this.No("resetTransform", []) } rotateTransform(...t) { return this.No("rotate", t) } scaleTransform(...t) { return this.No("scale", t) } setTransform(...t) { return this.No("setTransform", t) } transform(...t) { return this.No("transform", t) } translateTransform(...t) { return this.No("translate", t) } clear() { return this.No("clear", []) } get fillStyle() { return this.Cs.fillStyle } set fillStyle(t) { this.Cs.fillStyle = t } get strokeStyle() { return this.Cs.strokeStyle } set strokeStyle(t) { this.Cs.strokeStyle = t } clone(t = !1) { return t ? new dh(this.Cs.clone()) : (this.Vo = null, new dh(this.Cs)) } lineStyle(t, s, i) { $(0, "Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style."); const e = {}; return t && (e.width = t), s && (e.color = s), i && (e.alpha = i), this.context.strokeStyle = e, this } beginFill(t, s) { $(0, "Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style."); const i = {}; return void 0 !== t && (i.color = t), void 0 !== s && (i.alpha = s), this.context.fillStyle = i, this } endFill() { $(0, "Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style."), this.context.fill(); const t = this.context.strokeStyle; return t.width === Io.defaultStrokeStyle.width && t.color === Io.defaultStrokeStyle.color && t.alpha === Io.defaultStrokeStyle.alpha || this.context.stroke(), this } drawCircle(...t) { return $(0, "Graphics#drawCircle has been renamed to Graphics#circle"), this.No("circle", t) } drawEllipse(...t) { return $(0, "Graphics#drawEllipse has been renamed to Graphics#ellipse"), this.No("ellipse", t) } drawPolygon(...t) { return $(0, "Graphics#drawPolygon has been renamed to Graphics#poly"), this.No("poly", t) } drawRect(...t) { return $(0, "Graphics#drawRect has been renamed to Graphics#rect"), this.No("rect", t) } drawRoundedRect(...t) { return $(0, "Graphics#drawRoundedRect has been renamed to Graphics#roundRect"), this.No("roundRect", t) } drawStar(...t) { return $(0, "Graphics#drawStar has been renamed to Graphics#star"), this.No("star", t) } } const ph = class t extends Wn { constructor(...s) { let i = s[0] ?? {}; i instanceof Float32Array && ($(0, "use new MeshGeometry({ positions, uvs, indices }) instead"), i = { positions: i, uvs: s[1], indices: s[2] }), i = { ...t.defaultOptions, ...i }; const e = i.positions || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]); let n = i.uvs; n || (n = i.positions ? new Float32Array(e.length) : new Float32Array([0, 0, 1, 0, 1, 1, 0, 1])); const r = i.indices || new Uint32Array([0, 1, 2, 0, 2, 3]), o = i.shrinkBuffersToFit; super({ attributes: { aPosition: { buffer: new Vn({ data: e, label: "attribute-mesh-positions", shrinkToFit: o, usage: Ln.VERTEX | Ln.COPY_DST }), format: "float32x2", stride: 8, offset: 0 }, aUV: { buffer: new Vn({ data: n, label: "attribute-mesh-uvs", shrinkToFit: o, usage: Ln.VERTEX | Ln.COPY_DST }), format: "float32x2", stride: 8, offset: 0 } }, indexBuffer: new Vn({ data: r, label: "index-mesh-buffer", shrinkToFit: o, usage: Ln.INDEX | Ln.COPY_DST }), topology: i.topology }), this.batchMode = "auto" } get positions() { return this.attributes.aPosition.buffer.data } set positions(t) { this.attributes.aPosition.buffer.data = t } get uvs() { return this.attributes.aUV.buffer.data } set uvs(t) { this.attributes.aUV.buffer.data = t } get indices() { return this.indexBuffer.data } set indices(t) { this.indexBuffer.data = t } }; ph.defaultOptions = { topology: "triangle-list", shrinkBuffersToFit: !1 }; let mh = ph; class gh extends xs { constructor(t, s) { const { text: i, resolution: e, style: n, anchor: r, width: o, height: h, roundPixels: a, ...u } = t; super({ ...u }), this.batched = !0, this.G = null, this.Wo = !0, this.Ho = !0, this.qo = s, this.text = i ?? "", this.style = n, this.resolution = e ?? null, this.allowChildren = !1, this.xs = new c({ C: () => { this.onViewUpdate() } }), r && (this.anchor = r), this.roundPixels = a ?? !1, void 0 !== o && (this.width = o), void 0 !== h && (this.height = h) } get anchor() { return this.xs } set anchor(t) { "number" == typeof t ? this.xs.set(t) : this.xs.copyFrom(t) } set text(t) { t = t.toString(), this.Xo !== t && (this.Xo = t, this.onViewUpdate()) } get text() { return this.Xo } set resolution(t) { this.Wo = null === t, this.G = t, this.onViewUpdate() } get resolution() { return this.G } get style() { return this.L } set style(t) { t || (t = {}), this.L?.off("update", this.onViewUpdate, this), t instanceof this.qo ? this.L = t : this.L = new this.qo(t), this.L.on("update", this.onViewUpdate, this), this.onViewUpdate() } get width() { return Math.abs(this.scale.x) * this.bounds.width } set width(t) { this.Ut(t, this.bounds.width) } get height() { return Math.abs(this.scale.y) * this.bounds.height } set height(t) { this.It(t, this.bounds.height) } getSize(t) { return t || (t = {}), t.width = Math.abs(this.scale.x) * this.bounds.width, t.height = Math.abs(this.scale.y) * this.bounds.height, t } setSize(t, s) { "object" == typeof t ? (s = t.height ?? t.width, t = t.width) : s ?? (s = t), void 0 !== t && this.Ut(t, this.bounds.width), void 0 !== s && this.It(s, this.bounds.height) } containsPoint(t) { const s = this.bounds.width, i = this.bounds.height, e = -s * this.anchor.x; let n = 0; return t.x >= e && t.x <= e + s && (n = -i * this.anchor.y, t.y >= n && t.y <= n + i) } onViewUpdate() { this.didViewUpdate || (this.Ho = !0), super.onViewUpdate() } destroy(t = !1) { super.destroy(t), this.owner = null, this.gs = null, this.xs = null, ("boolean" == typeof t ? t : t?.style) && this.L.destroy(t), this.L = null, this.Xo = null } get styleKey() { return `${this.Xo}:${this.L.styleKey}:${this.G}` } } let vh = null, bh = null; function xh(t, s, i) { for (let e = 0, n = 4 * i * s; e < s; ++e, n += 4)if (0 !== t[n + 3]) return !1; return !0 } function yh(t, s, i, e, n) { const r = 4 * s; for (let o = e, h = e * r + 4 * i; o <= n; ++o, h += r)if (0 !== t[h + 3]) return !1; return !0 } function wh(...t) { let s = t[0]; s.canvas || (s = { canvas: t[0], resolution: t[1] }); const { canvas: i } = s, e = Math.min(s.resolution ?? 1, 1), n = s.width ?? i.width, r = s.height ?? i.height; let o = s.output; if (function (t, s) { vh || (vh = ks.get().createCanvas(256, 128), bh = vh.getContext("2d", { willReadFrequently: !0 }), bh.globalCompositeOperation = "copy", bh.globalAlpha = 1), (vh.width < t || vh.height < s) && (vh.width = D(t), vh.height = D(s)) }(n, r), !bh) throw new TypeError("Failed to get canvas 2D context"); bh.drawImage(i, 0, 0, n, r, 0, 0, n * e, r * e); const h = bh.getImageData(0, 0, n, r).data; let a = 0, u = 0, l = n - 1, c = r - 1; for (; u < r && xh(h, n, u);)++u; if (u === r) return O.EMPTY; for (; xh(h, n, c);)--c; for (; yh(h, n, a, u, c);)++a; for (; yh(h, n, l, u, c);)--l; return ++l, ++c, bh.globalCompositeOperation = "source-over", bh.strokeRect(a, u, l - a, c - u), bh.globalCompositeOperation = "copy", o ?? (o = new O), o.set(a / e, u / e, (l - a) / e, (c - u) / e), o } const Mh = new O, Th = new class { getCanvasAndContext(t) { const { text: s, style: i, resolution: e = 1 } = t, n = i.Er(), r = rn.measureText(s || " ", i), o = Math.ceil(Math.ceil(Math.max(1, r.width) + 2 * n) * e), h = Math.ceil(Math.ceil(Math.max(1, r.height) + 2 * n) * e), a = $o.getOptimalCanvasAndContext(o, h); return this.Yo(s, i, n, e, a), { canvasAndContext: a, frame: i.trim ? wh({ canvas: a.canvas, width: o, height: h, resolution: 1, output: Mh }) : Mh.set(0, 0, o, h) } } returnCanvasAndContext(t) { $o.returnCanvasAndContext(t) } Yo(t, s, i, e, n) { const { canvas: r, context: o } = n, h = sn(s), a = rn.measureText(t || " ", s), u = a.lines, l = a.lineHeight, c = a.lineWidths, f = a.maxLineWidth, d = a.fontProperties, p = r.height; if (o.resetTransform(), o.scale(e, e), o.textBaseline = s.textBaseline, s.un?.width) { const t = s.un; o.lineWidth = t.width, o.miterLimit = t.miterLimit, o.lineJoin = t.join, o.lineCap = t.cap } let m, g; o.font = h; const v = s.dropShadow ? 2 : 1; for (let b = 0; b < v; ++b) { const t = s.dropShadow && 0 === b, r = t ? Math.ceil(Math.max(1, p) + 2 * i) : 0, h = r * e; if (t) { o.fillStyle = "black", o.strokeStyle = "black"; const t = s.dropShadow, i = t.color, n = t.alpha; o.shadowColor = kt.shared.setValue(i).setAlpha(n).toRgbaString(); const r = t.blur * e, a = t.distance * e; o.shadowBlur = r, o.shadowOffsetX = Math.cos(t.angle) * a, o.shadowOffsetY = Math.sin(t.angle) * a + h } else { if (o.fillStyle = s.kr ? Do(s.kr, o, a, 2 * i) : null, s.un?.width) { const t = .5 * s.un.width + 2 * i; o.strokeStyle = Do(s.un, o, a, t) } o.shadowColor = "black" } let v = (l - d.fontSize) / 2; l - d.fontSize < 0 && (v = 0); const x = s.un?.width ?? 0; for (let e = 0; e < u.length; e++)m = x / 2, g = x / 2 + e * l + d.ascent + v, "right" === s.align ? m += f - c[e] : "center" === s.align && (m += (f - c[e]) / 2), s.un?.width && this.Ko(u[e], s, n, m + i, g + i - r, !0), void 0 !== s.kr && this.Ko(u[e], s, n, m + i, g + i - r) } } Ko(t, s, i, e, n, r = !1) { const { context: o } = i, h = s.letterSpacing; let a = !1; if (rn.experimentalLetterSpacingSupported && (rn.experimentalLetterSpacing ? (o.letterSpacing = `${h}px`, o.textLetterSpacing = `${h}px`, a = !0) : (o.letterSpacing = "0px", o.textLetterSpacing = "0px")), 0 === h || a) return void (r ? o.strokeText(t, e, n) : o.fillText(t, e, n)); let u = e; const l = rn.graphemeSegmenter(t); let c = o.measureText(t).width, f = 0; for (let d = 0; d < l.length; ++d) { const t = l[d]; r ? o.strokeText(t, u, n) : o.fillText(t, u, n); let s = ""; for (let i = d + 1; i < l.length; ++i)s += l[i]; f = o.measureText(s).width, u += c - f + h, c = f } } }; class Ah extends gh { constructor(...t) { const s = function (t) { let s = t[0] ?? {}; return ("string" == typeof s || t[1]) && ($(0, 'use new Text({ text: "hi!", style }) instead'), s = { text: s, style: t[1] }), s }(t); super(s, Go), this.renderPipeId = "text", s.textureStyle && (this.textureStyle = s.textureStyle instanceof W ? s.textureStyle : new W(s.textureStyle)) } updateBounds() { const t = this.gs, s = this.xs; let i = 0, e = 0; if (this.L.trim) { const { frame: t, canvasAndContext: s } = Th.getCanvasAndContext({ text: this.text, style: this.L, resolution: 1 }); Th.returnCanvasAndContext(s), i = t.width, e = t.height } else { const t = rn.measureText(this.Xo, this.L); i = t.width, e = t.height } t.minX = -s.M * i, t.maxX = t.minX + i, t.minY = -s.T * e, t.maxY = t.minY + e } } const Ch = "http://www.w3.org/2000/svg", _h = "http://www.w3.org/1999/xhtml"; class Sh { constructor() { this.svgRoot = document.createElementNS(Ch, "svg"), this.foreignObject = document.createElementNS(Ch, "foreignObject"), this.domElement = document.createElementNS(_h, "div"), this.styleElement = document.createElementNS(_h, "style"); const { foreignObject: t, svgRoot: s, styleElement: i, domElement: e } = this; t.setAttribute("width", "10000"), t.setAttribute("height", "10000"), t.style.overflow = "hidden", s.appendChild(t), t.appendChild(i), t.appendChild(e), this.image = ks.get().createImage() } destroy() { this.svgRoot.remove(), this.foreignObject.remove(), this.styleElement.remove(), this.domElement.remove(), this.image.src = "", this.image.remove(), this.svgRoot = null, this.foreignObject = null, this.styleElement = null, this.domElement = null, this.image = null, this.canvasAndContext = null } } let Ph; class kh { constructor() { this.Zo = se.for2d(), this.Qo = {} } init(t) { t.renderer.runners.contextChange.add(this) } contextChange() { this.Qo = {} } start(t, s, i) { const e = t.renderer, n = this.Qo[i.uid]; e.shader.bind(i, n), n || (this.Qo[i.uid] = !0), e.shader.updateUniformGroup(e.globalUniforms.uniformGroup), e.geometry.bind(s, i.glProgram) } execute(t, s) { const i = t.renderer; this.Zo.blendMode = s.blendMode, i.state.set(this.Zo); const e = s.textures.textures; for (let n = 0; n < s.textures.count; n++)i.texture.bind(e[n], n); i.geometry.draw(s.topology, s.size, s.start) } } kh.extension = { type: [r.WebGLPipesAdaptor], name: "batch" }; const Fh = se.for2d(); class Eh { start(t, s, i) { const e = t.renderer, n = e.encoder, r = i.gpuProgram; this.Jo = i, this.th = s, n.setGeometry(s, r), Fh.blendMode = "normal", e.pipeline.getPipeline(s, r, Fh); const o = e.globalUniforms.bindGroup; n.resetBindGroup(1), n.setBindGroup(0, o, r) } execute(t, s) { const i = this.Jo.gpuProgram, e = t.renderer, n = e.encoder; if (!s.bindGroup) { const t = s.textures; s.bindGroup = Tn(t.textures, t.count, e.limits.maxBatchableTextures) } Fh.blendMode = s.blendMode; const r = e.bindGroup.getBindGroup(s.bindGroup, i, 1), o = e.pipeline.getPipeline(this.th, i, Fh, s.topology); s.bindGroup.Ue(e.textureGC.count), n.setPipeline(o), n.renderPassEncoder.setBindGroup(1, r), n.renderPassEncoder.drawIndexed(s.size, 1, s.start) } } Eh.extension = { type: [r.WebGPUPipesAdaptor], name: "batch" }; const Rh = class t { constructor(t, s) { this.state = se.for2d(), this.sh = Object.create(null), this.ih = Object.create(null), this.renderer = t, this.eh = s, this.eh.init?.(this) } static getBatcher(t) { return new this.nh[t] } buildStart(t) { let s = this.sh[t.uid]; s || (s = this.sh[t.uid] = Object.create(null), s.default || (s.default = new Pr({ maxTextures: this.renderer.limits.maxBatchableTextures }))), this.ih = s, this.rh = this.ih.default; for (const i in this.ih) this.ih[i].begin() } addToBatch(s, i) { if (this.rh.name !== s.batcherName) { this.rh.break(i); let e = this.ih[s.batcherName]; e || (e = this.ih[s.batcherName] = t.getBatcher(s.batcherName), e.begin()), this.rh = e } this.rh.add(s) } break(t) { this.rh.break(t) } buildEnd(t) { this.rh.break(t); const s = this.ih; for (const i in s) { const t = s[i], e = t.geometry; e.indexBuffer.setDataWithSize(t.indexBuffer, t.indexSize, !0), e.buffers[0].setDataWithSize(t.attributeBuffer.float32View, t.attributeSize, !1) } } upload(t) { const s = this.sh[t.uid]; for (const i in s) { const t = s[i], e = t.geometry; t.dirty && (t.dirty = !1, e.buffers[0].update(4 * t.attributeSize)) } } execute(t) { if ("startBatch" === t.action) { const s = t.batcher, i = s.geometry, e = s.shader; this.eh.start(this, i, e) } this.eh.execute(this, t) } destroy() { this.state = null, this.renderer = null, this.eh = null; for (const t in this.ih) this.ih[t].destroy(); this.ih = null } }; Rh.extension = { type: [r.WebGLPipes, r.WebGPUPipes, r.CanvasPipes], name: "batch" }, Rh.nh = Object.create(null); let Oh = Rh; a.handleByMap(r.Batcher, Oh.nh), a.add(Pr); const Uh = { name: "local-uniform-bit", vertex: { header: "\n\n            struct LocalUniforms {\n                uTransformMatrix:mat3x3<f32>,\n                uColor:vec4<f32>,\n                uRound:f32,\n            }\n\n            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        ", main: "\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        ", end: "\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        " } }, Ih = { ...Uh, vertex: { ...Uh.vertex, header: Uh.vertex.header.replace("group(1)", "group(2)") } }, Bh = { name: "local-uniform-bit", vertex: { header: "\n\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        ", main: "\n            vColor *= uColor;\n            modelMatrix = uTransformMatrix;\n        ", end: "\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        " } }, Gh = { name: "texture-bit", vertex: { header: "\n\n        struct TextureUniforms {\n            uTextureMatrix:mat3x3<f32>,\n        }\n\n        @group(2) @binding(2) var<uniform> textureUniforms : TextureUniforms;\n        ", main: "\n            uv = (textureUniforms.uTextureMatrix * vec3(uv, 1.0)).xy;\n        " }, fragment: { header: "\n            @group(2) @binding(0) var uTexture: texture_2d<f32>;\n            @group(2) @binding(1) var uSampler: sampler;\n\n\n        ", main: "\n            outColor = textureSample(uTexture, uSampler, vUV);\n        " } }, $h = { name: "texture-bit", vertex: { header: "\n            uniform mat3 uTextureMatrix;\n        ", main: "\n            uv = (uTextureMatrix * vec3(uv, 1.0)).xy;\n        " }, fragment: { header: "\n        uniform sampler2D uTexture;\n\n\n        ", main: "\n            outColor = texture(uTexture, vUV);\n        " } }, zh = new tt; class Dh extends zt { constructor() { super(), this.filters = [new fh({ sprite: new ys(Z.EMPTY), inverse: !1, resolution: "inherit", antialias: "inherit" })] } get sprite() { return this.filters[0].sprite } set sprite(t) { this.filters[0].sprite = t } get inverse() { return this.filters[0].inverse } set inverse(t) { this.filters[0].inverse = t } } class jh { constructor(t) { this.oh = [], this.Gi = t } push(t, s, i) { const e = this.Gi; if (e.renderPipes.batch.break(i), i.add({ renderPipeId: "alphaMask", action: "pushMaskBegin", mask: t, inverse: s.St.inverse, canBundle: !1, maskedContainer: s }), t.inverse = s.St.inverse, t.renderMaskToTexture) { const s = t.mask; s.includeInBuild = !0, s.collectRenderables(i, e, null), s.includeInBuild = !1 } e.renderPipes.batch.break(i), i.add({ renderPipeId: "alphaMask", action: "pushMaskEnd", mask: t, maskedContainer: s, inverse: s.St.inverse, canBundle: !1 }) } pop(t, s, i) { this.Gi.renderPipes.batch.break(i), i.add({ renderPipeId: "alphaMask", action: "popMaskEnd", mask: t, inverse: s.St.inverse, canBundle: !1 }) } execute(t) { const s = this.Gi, i = t.mask.renderMaskToTexture; if ("pushMaskBegin" === t.action) { const e = Ut.get(Dh); if (e.inverse = t.inverse, i) { t.mask.mask.measurable = !0; const i = qt(t.mask.mask, !0, zh); t.mask.mask.measurable = !1, i.ceil(); const n = s.renderTarget.renderTarget.colorTexture.source, r = fs.getOptimalTexture(i.width, i.height, n.G, n.antialias); s.renderTarget.push(r, !0), s.globalUniforms.push({ offset: i, worldColor: 4294967295 }); const o = e.sprite; o.texture = r, o.worldTransform.tx = i.minX, o.worldTransform.ty = i.minY, this.oh.push({ filterEffect: e, maskedContainer: t.maskedContainer, filterTexture: r }) } else e.sprite = t.mask.mask, this.oh.push({ filterEffect: e, maskedContainer: t.maskedContainer }) } else if ("pushMaskEnd" === t.action) { const t = this.oh[this.oh.length - 1]; i && (s.type === Zi.WEBGL && s.renderTarget.finishRenderPass(), s.renderTarget.pop(), s.globalUniforms.pop()), s.filter.push({ renderPipeId: "filter", action: "pushFilter", container: t.maskedContainer, filterEffect: t.filterEffect, canBundle: !1 }) } else if ("popMaskEnd" === t.action) { s.filter.pop(); const t = this.oh.pop(); i && fs.returnTexture(t.filterTexture), Ut.return(t.filterEffect) } } destroy() { this.Gi = null, this.oh = null } } jh.extension = { type: [r.WebGLPipes, r.WebGPUPipes, r.CanvasPipes], name: "alphaMask" }; class Lh { constructor(t) { this.hh = [], this.ah = 0, this.uh = 0, this.Gi = t } buildStart() { this.hh[0] = 15, this.ah = 1, this.uh = 15 } push(t, s, i) { this.Gi.renderPipes.batch.break(i); const e = this.hh; e[this.ah] = e[this.ah - 1] & t.mask; const n = this.hh[this.ah]; n !== this.uh && (this.uh = n, i.add({ renderPipeId: "colorMask", colorMask: n, canBundle: !1 })), this.ah++ } pop(t, s, i) { this.Gi.renderPipes.batch.break(i); const e = this.hh; this.ah--; const n = e[this.ah - 1]; n !== this.uh && (this.uh = n, i.add({ renderPipeId: "colorMask", colorMask: n, canBundle: !1 })) } execute(t) { this.Gi.colorMask.setMask(t.colorMask) } destroy() { this.Gi = null, this.hh = null } } Lh.extension = { type: [r.WebGLPipes, r.WebGPUPipes, r.CanvasPipes], name: "colorMask" }; class Vh { constructor(t) { this.fh = {}, this.ph = new WeakMap, this.Gi = t } push(t, s, i) { var e; const n = t, r = this.Gi; r.renderPipes.batch.break(i), r.renderPipes.blendMode.setBlendMode(n.mask, "none", i), i.add({ renderPipeId: "stencilMask", action: "pushMaskBegin", mask: t, inverse: s.St.inverse, canBundle: !1 }); const o = n.mask; o.includeInBuild = !0, this.ph.has(n) || this.ph.set(n, { instructionsStart: 0, instructionsLength: 0 }); const h = this.ph.get(n); h.instructionsStart = i.instructionSize, o.collectRenderables(i, r, null), o.includeInBuild = !1, r.renderPipes.batch.break(i), i.add({ renderPipeId: "stencilMask", action: "pushMaskEnd", mask: t, inverse: s.St.inverse, canBundle: !1 }); const a = i.instructionSize - h.instructionsStart - 1; h.instructionsLength = a; const u = r.renderTarget.renderTarget.uid; (e = this.fh)[u] ?? (e[u] = 0) } pop(t, s, i) { const e = t, n = this.Gi; n.renderPipes.batch.break(i), n.renderPipes.blendMode.setBlendMode(e.mask, "none", i), i.add({ renderPipeId: "stencilMask", action: "popMaskBegin", inverse: s.St.inverse, canBundle: !1 }); const r = this.ph.get(t); for (let o = 0; o < r.instructionsLength; o++)i.instructions[i.instructionSize++] = i.instructions[r.instructionsStart++]; i.add({ renderPipeId: "stencilMask", action: "popMaskEnd", canBundle: !1 }) } execute(t) { var s; const i = this.Gi, e = i.renderTarget.renderTarget.uid; let n = (s = this.fh)[e] ?? (s[e] = 0); "pushMaskBegin" === t.action ? (i.renderTarget.ensureDepthStencil(), i.stencil.setStencilMode(Sn.RENDERING_MASK_ADD, n), n++, i.colorMask.setMask(0)) : "pushMaskEnd" === t.action ? (t.inverse ? i.stencil.setStencilMode(Sn.INVERSE_MASK_ACTIVE, n) : i.stencil.setStencilMode(Sn.MASK_ACTIVE, n), i.colorMask.setMask(15)) : "popMaskBegin" === t.action ? (i.colorMask.setMask(0), 0 !== n ? i.stencil.setStencilMode(Sn.RENDERING_MASK_REMOVE, n) : (i.renderTarget.clear(null, Ue.STENCIL), i.stencil.setStencilMode(Sn.DISABLED, n)), n--) : "popMaskEnd" === t.action && (t.inverse ? i.stencil.setStencilMode(Sn.INVERSE_MASK_ACTIVE, n) : i.stencil.setStencilMode(Sn.MASK_ACTIVE, n), i.colorMask.setMask(15)), this.fh[e] = n } destroy() { this.Gi = null, this.fh = null, this.ph = null } } Vh.extension = { type: [r.WebGLPipes, r.WebGPUPipes, r.CanvasPipes], name: "stencilMask" }; var Nh = (t => (t[t.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", t[t.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", t[t.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER", t))(Nh || {}); class Wh { constructor(t, s) { this.mh = -1, this.gh = -1, this.buffer = t || null, this.updateID = -1, this.byteLength = -1, this.type = s } } class Hh { constructor(t) { this.bh = Object.create(null), this.xh = Object.create(null), this.yh = 0, this.wh = this.yh, this.Mh = 0, this.Gi = t, this.Gi.renderableGC.addManagedHash(this, "_gpuBuffers") } destroy() { this.destroyAll(), this.Gi = null, this.Th = null, this.bh = {}, this.xh = {} } contextChange() { this.Th = this.Gi.gl, this.bh = Object.create(null), this.Ah = this.Gi.limits.maxUniformBindings } getGlBuffer(t) { return this.bh[t.uid] || this.createGLBuffer(t) } bind(t) { const { Th: s } = this, i = this.getGlBuffer(t); s.bindBuffer(i.type, i.buffer) } bindBufferBase(t, s) { const { Th: i } = this; this.xh[s] !== t && (this.xh[s] = t, t.mh = s, i.bindBufferBase(i.UNIFORM_BUFFER, s, t.buffer)) } nextBindBase(t) { this.Mh++, this.yh = 0, t && (this.xh[0] = null, this.yh = 1, this.wh < 1 && (this.wh = 1)) } freeLocationForBufferBase(t) { let s = this.getLastBindBaseLocation(t); if (s >= this.yh) return t.gh = this.Mh, s; let i = 0, e = this.wh; for (; i < 2;) { e >= this.Ah && (e = this.yh, i++); const t = this.xh[e]; if (!t || t.gh !== this.Mh) break; e++ } return s = e, this.wh = e + 1, i >= 2 ? -1 : (t.gh = this.Mh, this.xh[s] = null, s) } getLastBindBaseLocation(t) { const s = t.mh; return this.xh[s] === t ? s : -1 } bindBufferRange(t, s, i, e) { const { Th: n } = this; i || (i = 0), s || (s = 0), this.xh[s] = null, n.bindBufferRange(n.UNIFORM_BUFFER, s || 0, t.buffer, 256 * i, e || 256) } updateBuffer(t) { const { Th: s } = this, i = this.getGlBuffer(t); if (t.X === i.updateID) return i; i.updateID = t.X, s.bindBuffer(i.type, i.buffer); const e = t.data, n = t.descriptor.usage & Ln.STATIC ? s.STATIC_DRAW : s.DYNAMIC_DRAW; return e ? i.byteLength >= e.byteLength ? s.bufferSubData(i.type, 0, e, 0, t.Vn / e.BYTES_PER_ELEMENT) : (i.byteLength = e.byteLength, s.bufferData(i.type, e, n)) : (i.byteLength = t.descriptor.size, s.bufferData(i.type, i.byteLength, n)), i } destroyAll() { const t = this.Th; for (const s in this.bh) this.bh[s] && t.deleteBuffer(this.bh[s].buffer); this.bh = Object.create(null) } onBufferDestroy(t, s) { if (!this.bh[t.uid]) return; const i = this.bh[t.uid], e = this.Th; s || e.deleteBuffer(i.buffer), t.off("destroy", this.onBufferDestroy, this), this.bh[t.uid] = null } createGLBuffer(t) { const { Th: s } = this; let i = Nh.ARRAY_BUFFER; t.descriptor.usage & Ln.INDEX ? i = Nh.ELEMENT_ARRAY_BUFFER : t.descriptor.usage & Ln.UNIFORM && (i = Nh.UNIFORM_BUFFER); const e = new Wh(s.createBuffer(), i); return this.bh[t.uid] = e, t.on("destroy", this.onBufferDestroy, this), e } resetState() { this.xh = Object.create(null) } } Hh.extension = { type: [r.WebGLSystem], name: "buffer" }; const qh = class t { constructor(t) { this.supports = { uint32Indices: !0, uniformBufferObject: !0, vertexArrayObject: !0, srgbTextures: !0, nonPowOf2wrapping: !0, msaa: !0, nonPowOf2mipmaps: !0 }, this.Gi = t, this.extensions = Object.create(null), this.handleContextLost = this.handleContextLost.bind(this), this.handleContextRestored = this.handleContextRestored.bind(this) } get isLost() { return !this.gl || this.gl.isContextLost() } contextChange(t) { this.gl = t, this.Gi.gl = t } init(s) { s = { ...t.defaultOptions, ...s }; let i = this.multiView = s.multiView; if (s.context && i && (Et(), i = !1), this.canvas = i ? ks.get().createCanvas(this.Gi.canvas.width, this.Gi.canvas.height) : this.Gi.view.canvas, s.context) this.initFromContext(s.context); else { const t = this.Gi.background.alpha < 1, i = s.premultipliedAlpha ?? !0, e = s.antialias && !this.Gi.backBuffer.useBackBuffer; this.createContext(s.preferWebGLVersion, { alpha: t, premultipliedAlpha: i, antialias: e, stencil: !0, preserveDrawingBuffer: s.preserveDrawingBuffer, powerPreference: s.powerPreference ?? "default" }) } } ensureCanvasSize(t) { if (!this.multiView) return void (t !== this.canvas && Et()); const { canvas: s } = this; (s.width < t.width || s.height < t.height) && (s.width = Math.max(t.width, t.width), s.height = Math.max(t.height, t.height)) } initFromContext(t) { this.gl = t, this.webGLVersion = t instanceof ks.get().getWebGLRenderingContext() ? 1 : 2, this.getExtensions(), this.validateContext(t), this.Gi.runners.contextChange.emit(t); const s = this.Gi.view.canvas; s.addEventListener("webglcontextlost", this.handleContextLost, !1), s.addEventListener("webglcontextrestored", this.handleContextRestored, !1) } createContext(t, s) { let i; const e = this.canvas; if (2 === t && (i = e.getContext("webgl2", s)), !i && (i = e.getContext("webgl", s), !i)) throw new Error("This browser does not support WebGL. Try using the canvas renderer"); this.gl = i, this.initFromContext(this.gl) } getExtensions() { const { gl: t } = this, s = { anisotropicFiltering: t.getExtension("EXT_texture_filter_anisotropic"), floatTextureLinear: t.getExtension("OES_texture_float_linear"), s3tc: t.getExtension("WEBGL_compressed_texture_s3tc"), s3tc_sRGB: t.getExtension("WEBGL_compressed_texture_s3tc_srgb"), etc: t.getExtension("WEBGL_compressed_texture_etc"), etc1: t.getExtension("WEBGL_compressed_texture_etc1"), pvrtc: t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"), atc: t.getExtension("WEBGL_compressed_texture_atc"), astc: t.getExtension("WEBGL_compressed_texture_astc"), bptc: t.getExtension("EXT_texture_compression_bptc"), rgtc: t.getExtension("EXT_texture_compression_rgtc"), loseContext: t.getExtension("WEBGL_lose_context") }; if (1 === this.webGLVersion) this.extensions = { ...s, drawBuffers: t.getExtension("WEBGL_draw_buffers"), depthTexture: t.getExtension("WEBGL_depth_texture"), vertexArrayObject: t.getExtension("OES_vertex_array_object") || t.getExtension("MOZ_OES_vertex_array_object") || t.getExtension("WEBKIT_OES_vertex_array_object"), uint32ElementIndex: t.getExtension("OES_element_index_uint"), floatTexture: t.getExtension("OES_texture_float"), floatTextureLinear: t.getExtension("OES_texture_float_linear"), textureHalfFloat: t.getExtension("OES_texture_half_float"), textureHalfFloatLinear: t.getExtension("OES_texture_half_float_linear"), vertexAttribDivisorANGLE: t.getExtension("ANGLE_instanced_arrays"), srgb: t.getExtension("EXT_sRGB") }; else { this.extensions = { ...s, colorBufferFloat: t.getExtension("EXT_color_buffer_float") }; const i = t.getExtension("WEBGL_provoking_vertex"); i && i.provokingVertexWEBGL(i.FIRST_VERTEX_CONVENTION_WEBGL) } } handleContextLost(t) { t.preventDefault(), this.Ch && (this.Ch = !1, setTimeout(() => { this.gl.isContextLost() && this.extensions.loseContext?.restoreContext() }, 0)) } handleContextRestored() { this.getExtensions(), this.Gi.runners.contextChange.emit(this.gl) } destroy() { const t = this.Gi.view.canvas; this.Gi = null, t.removeEventListener("webglcontextlost", this.handleContextLost), t.removeEventListener("webglcontextrestored", this.handleContextRestored), this.gl.useProgram(null), this.extensions.loseContext?.loseContext() } forceContextLoss() { this.extensions.loseContext?.loseContext(), this.Ch = !0 } validateContext(t) { const s = t.getContextAttributes(); s && !s.stencil && Et(); const i = this.supports, e = 2 === this.webGLVersion, n = this.extensions; i.uint32Indices = e || !!n.uint32ElementIndex, i.uniformBufferObject = e, i.vertexArrayObject = e || !!n.vertexArrayObject, i.srgbTextures = e || !!n.srgb, i.nonPowOf2wrapping = e, i.nonPowOf2mipmaps = e, i.msaa = e, i.uint32Indices || Et() } }; qh.extension = { type: [r.WebGLSystem], name: "context" }, qh.defaultOptions = { context: null, premultipliedAlpha: !0, preserveDrawingBuffer: !1, powerPreference: void 0, preferWebGLVersion: 2, multiView: !1 }; let Xh = qh; function Yh(t, s) { for (const i in t.attributes) { const e = t.attributes[i], n = s[i]; n ? (e.format ?? (e.format = n.format), e.offset ?? (e.offset = n.offset), e.instance ?? (e.instance = n.instance)) : Et() } !function (t) { const { buffers: s, attributes: i } = t, e = {}, n = {}; for (const r in s) { const t = s[r]; e[t.uid] = 0, n[t.uid] = 0 } for (const r in i) { const t = i[r]; e[t.buffer.uid] += zi(t.format).stride } for (const r in i) { const t = i[r]; t.stride ?? (t.stride = e[t.buffer.uid]), t.start ?? (t.start = n[t.buffer.uid]), n[t.buffer.uid] += zi(t.format).stride } }(t) } var Kh = (t => (t[t.RGBA = 6408] = "RGBA", t[t.RGB = 6407] = "RGB", t[t.RG = 33319] = "RG", t[t.RED = 6403] = "RED", t[t.RGBA_INTEGER = 36249] = "RGBA_INTEGER", t[t.RGB_INTEGER = 36248] = "RGB_INTEGER", t[t.RG_INTEGER = 33320] = "RG_INTEGER", t[t.RED_INTEGER = 36244] = "RED_INTEGER", t[t.ALPHA = 6406] = "ALPHA", t[t.LUMINANCE = 6409] = "LUMINANCE", t[t.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", t[t.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", t[t.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL", t))(Kh || {}), Zh = (t => (t[t.TEXTURE_2D = 3553] = "TEXTURE_2D", t[t.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", t[t.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", t[t.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", t[t.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", t[t.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", t[t.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", t[t.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", t[t.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z", t))(Zh || {}), Qh = (t => (t[t.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", t[t.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", t[t.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", t[t.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", t[t.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", t[t.UNSIGNED_INT = 5125] = "UNSIGNED_INT", t[t.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", t[t.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", t[t.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", t[t.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", t[t.BYTE = 5120] = "BYTE", t[t.SHORT = 5122] = "SHORT", t[t.INT = 5124] = "INT", t[t.FLOAT = 5126] = "FLOAT", t[t.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", t[t.HALF_FLOAT = 36193] = "HALF_FLOAT", t))(Qh || {}); const Jh = { uint8x2: Qh.UNSIGNED_BYTE, uint8x4: Qh.UNSIGNED_BYTE, sint8x2: Qh.BYTE, sint8x4: Qh.BYTE, unorm8x2: Qh.UNSIGNED_BYTE, unorm8x4: Qh.UNSIGNED_BYTE, snorm8x2: Qh.BYTE, snorm8x4: Qh.BYTE, uint16x2: Qh.UNSIGNED_SHORT, uint16x4: Qh.UNSIGNED_SHORT, sint16x2: Qh.SHORT, sint16x4: Qh.SHORT, unorm16x2: Qh.UNSIGNED_SHORT, unorm16x4: Qh.UNSIGNED_SHORT, snorm16x2: Qh.SHORT, snorm16x4: Qh.SHORT, float16x2: Qh.HALF_FLOAT, float16x4: Qh.HALF_FLOAT, float32: Qh.FLOAT, float32x2: Qh.FLOAT, float32x3: Qh.FLOAT, float32x4: Qh.FLOAT, uint32: Qh.UNSIGNED_INT, uint32x2: Qh.UNSIGNED_INT, uint32x3: Qh.UNSIGNED_INT, uint32x4: Qh.UNSIGNED_INT, sint32: Qh.INT, sint32x2: Qh.INT, sint32x3: Qh.INT, sint32x4: Qh.INT }; function ta(t) { return Jh[t] ?? Jh.float32 } const sa = { "point-list": 0, "line-list": 1, "line-strip": 3, "triangle-list": 4, "triangle-strip": 5 }; class ia { constructor(t) { this._h = Object.create(null), this.Gi = t, this.Sh = null, this.Ph = null, this.hasVao = !0, this.hasInstance = !0, this.Gi.renderableGC.addManagedHash(this, "_geometryVaoHash") } contextChange() { const t = this.gl = this.Gi.gl; if (!this.Gi.context.supports.vertexArrayObject) throw new Error("[PixiJS] Vertex Array Objects are not supported on this device"); const s = this.Gi.context.extensions.vertexArrayObject; s && (t.createVertexArray = () => s.createVertexArrayOES(), t.bindVertexArray = t => s.bindVertexArrayOES(t), t.deleteVertexArray = t => s.deleteVertexArrayOES(t)); const i = this.Gi.context.extensions.vertexAttribDivisorANGLE; i && (t.drawArraysInstanced = (t, s, e, n) => { i.drawArraysInstancedANGLE(t, s, e, n) }, t.drawElementsInstanced = (t, s, e, n, r) => { i.drawElementsInstancedANGLE(t, s, e, n, r) }, t.vertexAttribDivisor = (t, s) => i.vertexAttribDivisorANGLE(t, s)), this.Sh = null, this.Ph = null, this._h = Object.create(null) } bind(t, s) { const i = this.gl; this.Sh = t; const e = this.getVao(t, s); this.Ph !== e && (this.Ph = e, i.bindVertexArray(e)), this.updateBuffers() } resetState() { this.unbind() } updateBuffers() { const t = this.Sh, s = this.Gi.buffer; for (let i = 0; i < t.buffers.length; i++) { const e = t.buffers[i]; s.updateBuffer(e) } } checkCompatibility(t, s) { const i = t.attributes, e = s.Te; for (const n in e) if (!i[n]) throw new Error(`shader and geometry incompatible, geometry missing the "${n}" attribute`) } getSignature(t, s) { const i = t.attributes, e = s.Te, n = ["g", t.uid]; for (const r in i) e[r] && n.push(r, e[r].location); return n.join("-") } getVao(t, s) { return this._h[t.uid]?.[s.Me] || this.initGeometryVao(t, s) } initGeometryVao(t, s, i = !0) { const e = this.Gi.gl, n = this.Gi.buffer; this.Gi.shader.kh(s), this.checkCompatibility(t, s); const r = this.getSignature(t, s); this._h[t.uid] || (this._h[t.uid] = Object.create(null), t.on("destroy", this.onGeometryDestroy, this)); const o = this._h[t.uid]; let h = o[r]; if (h) return o[s.Me] = h, h; Yh(t, s.Te); const a = t.buffers; h = e.createVertexArray(), e.bindVertexArray(h); for (let u = 0; u < a.length; u++) { const t = a[u]; n.bind(t) } return this.activateVao(t, s), o[s.Me] = h, o[r] = h, e.bindVertexArray(null), h } onGeometryDestroy(t, s) { const i = this._h[t.uid], e = this.gl; if (i) { if (s) for (const t in i) this.Ph !== i[t] && this.unbind(), e.deleteVertexArray(i[t]); this._h[t.uid] = null } } destroyAll(t = !1) { const s = this.gl; for (const i in this._h) { if (t) for (const t in this._h[i]) { const e = this._h[i]; this.Ph !== e && this.unbind(), s.deleteVertexArray(e[t]) } this._h[i] = null } } activateVao(t, s) { const i = this.Gi.gl, e = this.Gi.buffer, n = t.attributes; t.indexBuffer && e.bind(t.indexBuffer); let r = null; for (const o in n) { const t = n[o], h = t.buffer, a = e.getGlBuffer(h), u = s.Te[o]; if (u) { r !== a && (e.bind(h), r = a); const s = u.location; i.enableVertexAttribArray(s); const n = zi(t.format), o = ta(t.format); if ("int" === u.format?.substring(1, 4) ? i.vertexAttribIPointer(s, n.size, o, t.stride, t.offset) : i.vertexAttribPointer(s, n.size, o, n.normalised, t.stride, t.offset), t.instance) { if (!this.hasInstance) throw new Error("geometry error, GPU Instancing is not supported on this device"); { const e = t.divisor ?? 1; i.vertexAttribDivisor(s, e) } } } } } draw(t, s, i, e) { const { gl: n } = this.Gi, r = this.Sh, o = sa[t || r.topology]; if (e ?? (e = r.instanceCount), r.indexBuffer) { const t = r.indexBuffer.data.BYTES_PER_ELEMENT, h = 2 === t ? n.UNSIGNED_SHORT : n.UNSIGNED_INT; 1 !== e ? n.drawElementsInstanced(o, s || r.indexBuffer.data.length, h, (i || 0) * t, e) : n.drawElements(o, s || r.indexBuffer.data.length, h, (i || 0) * t) } else 1 !== e ? n.drawArraysInstanced(o, i || 0, s || r.getSize(), e) : n.drawArrays(o, i || 0, s || r.getSize()); return this } unbind() { this.gl.bindVertexArray(null), this.Ph = null, this.Sh = null } destroy() { this.Gi = null, this.gl = null, this.Ph = null, this.Sh = null, this._h = {} } } ia.extension = { type: [r.WebGLSystem], name: "geometry" }; const ea = new Wn({ attributes: { aPosition: [-1, -1, 3, -1, -1, 3] } }), na = class t { constructor(t) { this.useBackBuffer = !1, this.Fh = !1, this.Gi = t } init(s = {}) { const { useBackBuffer: i, antialias: e } = { ...t.defaultOptions, ...s }; this.useBackBuffer = i, this.Eh = e, this.Gi.context.supports.msaa || (Et(), this.Eh = !1), this.je = se.for2d(); const n = new Gi({ vertex: "\n                attribute vec2 aPosition;\n                out vec2 vUv;\n\n                void main() {\n                    gl_Position = vec4(aPosition, 0.0, 1.0);\n\n                    vUv = (aPosition + 1.0) / 2.0;\n\n                    // flip dem UVs\n                    vUv.y = 1.0 - vUv.y;\n                }", fragment: "\n                in vec2 vUv;\n                out vec4 finalColor;\n\n                uniform sampler2D uTexture;\n\n                void main() {\n                    finalColor = texture(uTexture, vUv);\n                }", name: "big-triangle" }); this.Rh = new Qi({ glProgram: n, resources: { uTexture: Z.WHITE.source } }) } renderStart(t) { const s = this.Gi.renderTarget.getRenderTarget(t.target); if (this.Fh = this.useBackBuffer && !!s.isRoot, this.Fh) { const s = this.Gi.renderTarget.getRenderTarget(t.target); this.Oh = s.colorTexture, t.target = this.Uh(s.colorTexture) } } renderEnd() { this.Ih() } Ih() { const t = this.Gi; t.renderTarget.finishRenderPass(), this.Fh && (t.renderTarget.bind(this.Oh, !1), this.Rh.resources.uTexture = this.Bh.source, t.encoder.draw({ geometry: ea, shader: this.Rh, state: this.je })) } Uh(t) { return this.Bh = this.Bh || new Z({ source: new q({ width: t.width, height: t.height, resolution: t.G, antialias: this.Eh }) }), this.Bh.source.resize(t.width, t.height, t.G), this.Bh } destroy() { this.Bh && (this.Bh.destroy(), this.Bh = null) } }; na.extension = { type: [r.WebGLSystem], name: "backBuffer", priority: 1 }, na.defaultOptions = { useBackBuffer: !1 }; let ra = na; class oa { constructor(t) { this.Gh = 15, this.Gi = t } setMask(t) { this.Gh !== t && (this.Gh = t, this.Gi.gl.colorMask(!!(8 & t), !!(4 & t), !!(2 & t), !!(1 & t))) } } oa.extension = { type: [r.WebGLSystem], name: "colorMask" }; class ha { constructor(t) { this.commandFinished = Promise.resolve(), this.Gi = t } setGeometry(t, s) { this.Gi.geometry.bind(t, s.glProgram) } finishRenderPass() { } draw(t) { const s = this.Gi, { geometry: i, shader: e, state: n, skipSync: r, topology: o, size: h, start: a, instanceCount: u } = t; s.shader.bind(e, r), s.geometry.bind(i, s.shader.$h), n && s.state.set(n), s.geometry.draw(o, h, a, u ?? i.instanceCount) } destroy() { this.Gi = null } } ha.extension = { type: [r.WebGLSystem], name: "encoder" }; class aa { constructor(t) { this.Gi = t } contextChange() { const t = this.Gi.gl; this.maxTextures = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS), this.maxBatchableTextures = En(this.maxTextures, t); const s = 2 === this.Gi.context.webGLVersion; this.maxUniformBindings = s ? t.getParameter(t.MAX_UNIFORM_BUFFER_BINDINGS) : 0 } destroy() { } } aa.extension = { type: [r.WebGLSystem], name: "limits" }; class ua { constructor() { this.width = -1, this.height = -1, this.msaa = !1, this.msaaRenderBuffer = [] } } const la = []; la[Sn.NONE] = void 0, la[Sn.DISABLED] = { stencilWriteMask: 0, stencilReadMask: 0 }, la[Sn.RENDERING_MASK_ADD] = { stencilFront: { compare: "equal", passOp: "increment-clamp" }, stencilBack: { compare: "equal", passOp: "increment-clamp" } }, la[Sn.RENDERING_MASK_REMOVE] = { stencilFront: { compare: "equal", passOp: "decrement-clamp" }, stencilBack: { compare: "equal", passOp: "decrement-clamp" } }, la[Sn.MASK_ACTIVE] = { stencilWriteMask: 0, stencilFront: { compare: "equal", passOp: "keep" }, stencilBack: { compare: "equal", passOp: "keep" } }, la[Sn.INVERSE_MASK_ACTIVE] = { stencilWriteMask: 0, stencilFront: { compare: "not-equal", passOp: "keep" }, stencilBack: { compare: "not-equal", passOp: "keep" } }; class ca { constructor(t) { this.zh = { enabled: !1, stencilReference: 0, stencilMode: Sn.NONE }, this.Dh = Object.create(null), t.renderTarget.onRenderTargetChange.add(this) } contextChange(t) { this.Th = t, this.jh = { always: t.ALWAYS, never: t.NEVER, equal: t.EQUAL, "not-equal": t.NOTEQUAL, less: t.LESS, "less-equal": t.LEQUAL, greater: t.GREATER, "greater-equal": t.GEQUAL }, this.Lh = { keep: t.KEEP, zero: t.ZERO, replace: t.REPLACE, invert: t.INVERT, "increment-clamp": t.INCR, "decrement-clamp": t.DECR, "increment-wrap": t.INCR_WRAP, "decrement-wrap": t.DECR_WRAP }, this.resetState() } onRenderTargetChange(t) { if (this.Vh === t) return; this.Vh = t; let s = this.Dh[t.uid]; s || (s = this.Dh[t.uid] = { stencilMode: Sn.DISABLED, stencilReference: 0 }), this.setStencilMode(s.stencilMode, s.stencilReference) } resetState() { this.zh.enabled = !1, this.zh.stencilMode = Sn.NONE, this.zh.stencilReference = 0 } setStencilMode(t, s) { const i = this.Dh[this.Vh.uid], e = this.Th, n = la[t], r = this.zh; i.stencilMode = t, i.stencilReference = s, t !== Sn.DISABLED ? (this.zh.enabled || (this.zh.enabled = !0, e.enable(e.STENCIL_TEST)), t === r.stencilMode && r.stencilReference === s || (r.stencilMode = t, r.stencilReference = s, e.stencilFunc(this.jh[n.stencilBack.compare], s, 255), e.stencilOp(e.KEEP, e.KEEP, this.Lh[n.stencilBack.passOp]))) : this.zh.enabled && (this.zh.enabled = !1, e.disable(e.STENCIL_TEST)) } } ca.extension = { type: [r.WebGLSystem], name: "stencil" }; class fa { constructor(t) { this.Nh = Object.create(null), this.eh = t, this.Wh() } Wh() { if (!oe()) throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.") } ensureUniformGroup(t) { const s = this.getUniformGroupData(t); t.buffer || (t.buffer = new Vn({ data: new Float32Array(s.layout.size / 4), usage: Ln.UNIFORM | Ln.COPY_DST })) } getUniformGroupData(t) { return this.Nh[t.Ee] || this.Hh(t) } Hh(t) { const s = t.Ee; let i = this.Nh[s]; if (!i) { const e = Object.keys(t.uniformStructures).map(s => t.uniformStructures[s]), n = this.eh.createUboElements(e), r = this.qh(n.uboElements); i = this.Nh[s] = { layout: n, syncFunction: r } } return this.Nh[s] } qh(t) { return this.eh.generateUboSync(t) } syncUniformGroup(t, s, i) { const e = this.getUniformGroupData(t); t.buffer || (t.buffer = new Vn({ data: new Float32Array(e.layout.size / 4), usage: Ln.UNIFORM | Ln.COPY_DST })); let n = null; return s || (s = t.buffer.data, n = t.buffer.dataInt32), i || (i = 0), e.syncFunction(t.uniforms, s, n, i), !0 } updateUniformGroup(t) { if (t.isStatic && !t.Fe) return !1; t.Fe = 0; const s = this.syncUniformGroup(t); return t.buffer.update(), s } destroy() { this.Nh = null } } const da = { f32: 4, i32: 4, "vec2<f32>": 8, "vec3<f32>": 12, "vec4<f32>": 16, "vec2<i32>": 8, "vec3<i32>": 12, "vec4<i32>": 16, "mat2x2<f32>": 32, "mat3x3<f32>": 48, "mat4x4<f32>": 64 }; function pa(t) { const s = t.map(t => ({ data: t, offset: 0, size: 0 })); let i = 0, e = 0; for (let n = 0; n < s.length; n++) { const t = s[n]; if (i = da[t.data.type], !i) throw new Error(`Unknown type ${t.data.type}`); t.data.size > 1 && (i = Math.max(i, 16) * t.data.size); const r = 12 === i ? 16 : i; t.size = i; const o = e % 16; e += o > 0 && 16 - o < r ? (16 - o) % 16 : (i - o % i) % i, t.offset = e, e += i } return e = 16 * Math.ceil(e / 16), { uboElements: s, size: e } } const ma = [{ type: "mat3x3<f32>", test: t => void 0 !== t.value.a, ubo: "\n            var matrix = uv[name].toArray(true);\n            data[offset] = matrix[0];\n            data[offset + 1] = matrix[1];\n            data[offset + 2] = matrix[2];\n            data[offset + 4] = matrix[3];\n            data[offset + 5] = matrix[4];\n            data[offset + 6] = matrix[5];\n            data[offset + 8] = matrix[6];\n            data[offset + 9] = matrix[7];\n            data[offset + 10] = matrix[8];\n        ", uniform: "\n            gl.uniformMatrix3fv(ud[name].location, false, uv[name].toArray(true));\n        " }, { type: "vec4<f32>", test: t => "vec4<f32>" === t.type && 1 === t.size && void 0 !== t.value.width, ubo: "\n            v = uv[name];\n            data[offset] = v.x;\n            data[offset + 1] = v.y;\n            data[offset + 2] = v.width;\n            data[offset + 3] = v.height;\n        ", uniform: "\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height) {\n                cv[0] = v.x;\n                cv[1] = v.y;\n                cv[2] = v.width;\n                cv[3] = v.height;\n                gl.uniform4f(ud[name].location, v.x, v.y, v.width, v.height);\n            }\n        " }, { type: "vec2<f32>", test: t => "vec2<f32>" === t.type && 1 === t.size && void 0 !== t.value.x, ubo: "\n            v = uv[name];\n            data[offset] = v.x;\n            data[offset + 1] = v.y;\n        ", uniform: "\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.x || cv[1] !== v.y) {\n                cv[0] = v.x;\n                cv[1] = v.y;\n                gl.uniform2f(ud[name].location, v.x, v.y);\n            }\n        " }, { type: "vec4<f32>", test: t => "vec4<f32>" === t.type && 1 === t.size && void 0 !== t.value.red, ubo: "\n            v = uv[name];\n            data[offset] = v.red;\n            data[offset + 1] = v.green;\n            data[offset + 2] = v.blue;\n            data[offset + 3] = v.alpha;\n        ", uniform: "\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha) {\n                cv[0] = v.red;\n                cv[1] = v.green;\n                cv[2] = v.blue;\n                cv[3] = v.alpha;\n                gl.uniform4f(ud[name].location, v.red, v.green, v.blue, v.alpha);\n            }\n        " }, { type: "vec3<f32>", test: t => "vec3<f32>" === t.type && 1 === t.size && void 0 !== t.value.red, ubo: "\n            v = uv[name];\n            data[offset] = v.red;\n            data[offset + 1] = v.green;\n            data[offset + 2] = v.blue;\n        ", uniform: "\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue) {\n                cv[0] = v.red;\n                cv[1] = v.green;\n                cv[2] = v.blue;\n                gl.uniform3f(ud[name].location, v.red, v.green, v.blue);\n            }\n        " }]; function ga(t, s, i, e) { const n = ["\n        var v = null;\n        var v2 = null;\n        var t = 0;\n        var index = 0;\n        var name = null;\n        var arrayOffset = null;\n    "]; let r = 0; for (let h = 0; h < t.length; h++) { const o = t[h], a = o.data.name; let u = !1, l = 0; for (let t = 0; t < ma.length; t++)if (ma[t].test(o.data)) { l = o.offset / 4, n.push(`name = "${a}";`, `offset += ${l - r};`, ma[t][s] || ma[t].ubo), u = !0; break } if (!u) if (o.data.size > 1) l = o.offset / 4, n.push(i(o, l - r)); else { const t = e[o.data.type]; l = o.offset / 4, n.push(`\n                    v = uv.${a};\n                    offset += ${l - r};\n                    ${t};\n                `) } r = l } const o = n.join("\n"); return new Function("uv", "data", "dataInt32", "offset", o) } function va(t, s) { return `\n        for (let i = 0; i < ${t * s}; i++) {\n            data[offset + (((i / ${t})|0) * 4) + (i % ${t})] = v[i];\n        }\n    ` } const ba = { f32: "\n        data[offset] = v;", i32: "\n        dataInt32[offset] = v;", "vec2<f32>": "\n        data[offset] = v[0];\n        data[offset + 1] = v[1];", "vec3<f32>": "\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];", "vec4<f32>": "\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 3] = v[3];", "vec2<i32>": "\n        dataInt32[offset] = v[0];\n        dataInt32[offset + 1] = v[1];", "vec3<i32>": "\n        dataInt32[offset] = v[0];\n        dataInt32[offset + 1] = v[1];\n        dataInt32[offset + 2] = v[2];", "vec4<i32>": "\n        dataInt32[offset] = v[0];\n        dataInt32[offset + 1] = v[1];\n        dataInt32[offset + 2] = v[2];\n        dataInt32[offset + 3] = v[3];", "mat2x2<f32>": "\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 4] = v[2];\n        data[offset + 5] = v[3];", "mat3x3<f32>": "\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 4] = v[3];\n        data[offset + 5] = v[4];\n        data[offset + 6] = v[5];\n        data[offset + 8] = v[6];\n        data[offset + 9] = v[7];\n        data[offset + 10] = v[8];", "mat4x4<f32>": "\n        for (let i = 0; i < 16; i++) {\n            data[offset + i] = v[i];\n        }", "mat3x2<f32>": va(3, 2), "mat4x2<f32>": va(4, 2), "mat2x3<f32>": va(2, 3), "mat4x3<f32>": va(4, 3), "mat2x4<f32>": va(2, 4), "mat3x4<f32>": va(3, 4) }, xa = { ...ba, "mat2x2<f32>": "\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 3] = v[3];\n    " }; function ya(t, s) { const i = Math.max(da[t.data.type] / 16, 1), e = t.data.value.length / t.data.size, n = (4 - e % 4) % 4, r = t.data.type.indexOf("i32") >= 0 ? "dataInt32" : "data"; return `\n        v = uv.${t.data.name};\n        offset += ${s};\n\n        arrayOffset = offset;\n\n        t = 0;\n\n        for(var i=0; i < ${t.data.size * i}; i++)\n        {\n            for(var j = 0; j < ${e}; j++)\n            {\n                ${r}[arrayOffset++] = v[t++];\n            }\n            ${0 !== n ? `arrayOffset += ${n};` : ""}\n        }\n    ` } function wa(t) { return ga(t, "uboStd40", ya, ba) } class Ma extends fa { constructor() { super({ createUboElements: pa, generateUboSync: wa }) } } Ma.extension = { type: [r.WebGLSystem], name: "ubo" }; class Ta { constructor() { this.Xh = [0, 0, 0, 0], this.Yh = new O } init(t, s) { this.Gi = t, this.Kh = s, t.runners.contextChange.add(this) } contextChange() { this.Xh = [0, 0, 0, 0], this.Yh = new O } copyToTexture(t, s, i, e, n) { const r = this.Kh, o = this.Gi, h = r.getGpuRenderTarget(t), a = o.gl; return this.finishRenderPass(t), a.bindFramebuffer(a.FRAMEBUFFER, h.resolveTargetFramebuffer), o.texture.bind(s, 0), a.copyTexSubImage2D(a.TEXTURE_2D, 0, n.x, n.y, i.x, i.y, e.width, e.height), s } startRenderPass(t, s = !0, i, e) { const n = this.Kh, r = t.colorTexture, o = n.getGpuRenderTarget(t); let h = e.y; t.isRoot && (h = r.pixelHeight - e.height), t.colorTextures.forEach(t => { this.Gi.texture.unbind(t) }); const a = this.Gi.gl; a.bindFramebuffer(a.FRAMEBUFFER, o.framebuffer); const u = this.Yh; u.x === e.x && u.y === h && u.width === e.width && u.height === e.height || (u.x = e.x, u.y = h, u.width = e.width, u.height = e.height, a.viewport(e.x, h, e.width, e.height)), o.depthStencilRenderBuffer || !t.stencil && !t.depth || this.Zh(o), this.clear(t, s, i) } finishRenderPass(t) { const s = this.Kh.getGpuRenderTarget(t); if (!s.msaa) return; const i = this.Gi.gl; i.bindFramebuffer(i.FRAMEBUFFER, s.resolveTargetFramebuffer), i.bindFramebuffer(i.READ_FRAMEBUFFER, s.framebuffer), i.blitFramebuffer(0, 0, s.width, s.height, 0, 0, s.width, s.height, i.COLOR_BUFFER_BIT, i.NEAREST), i.bindFramebuffer(i.FRAMEBUFFER, s.framebuffer) } initGpuRenderTarget(t) { const s = this.Gi.gl, i = new ua; return t.colorTexture instanceof Fs ? (this.Gi.context.ensureCanvasSize(t.colorTexture.resource), i.framebuffer = null, i) : (this.Qh(t, i), s.bindFramebuffer(s.FRAMEBUFFER, null), i) } destroyGpuRenderTarget(t) { const s = this.Gi.gl; t.framebuffer && (s.deleteFramebuffer(t.framebuffer), t.framebuffer = null), t.resolveTargetFramebuffer && (s.deleteFramebuffer(t.resolveTargetFramebuffer), t.resolveTargetFramebuffer = null), t.depthStencilRenderBuffer && (s.deleteRenderbuffer(t.depthStencilRenderBuffer), t.depthStencilRenderBuffer = null), t.msaaRenderBuffer.forEach(t => { s.deleteRenderbuffer(t) }), t.msaaRenderBuffer = null } clear(t, s, i) { if (!s) return; const e = this.Kh; "boolean" == typeof s && (s = s ? Ue.ALL : Ue.NONE); const n = this.Gi.gl; if (s & Ue.COLOR) { i ?? (i = e.defaultClearColor); const t = this.Xh, s = i; t[0] === s[0] && t[1] === s[1] && t[2] === s[2] && t[3] === s[3] || (t[0] = s[0], t[1] = s[1], t[2] = s[2], t[3] = s[3], n.clearColor(s[0], s[1], s[2], s[3])) } n.clear(s) } resizeGpuRenderTarget(t) { if (t.isRoot) return; const s = this.Kh.getGpuRenderTarget(t); this.Jh(t, s), (t.stencil || t.depth) && this.ta(s) } Qh(t, s) { const i = this.Gi, e = i.gl, n = e.createFramebuffer(); if (s.resolveTargetFramebuffer = n, e.bindFramebuffer(e.FRAMEBUFFER, n), s.width = t.colorTexture.source.pixelWidth, s.height = t.colorTexture.source.pixelHeight, t.colorTextures.forEach((t, n) => { const r = t.source; r.antialias && (i.context.supports.msaa ? s.msaa = !0 : Et()), i.texture.bindSource(r, 0); const o = i.texture.getGlSource(r).texture; e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + n, 3553, o, 0) }), s.msaa) { const i = e.createFramebuffer(); s.framebuffer = i, e.bindFramebuffer(e.FRAMEBUFFER, i), t.colorTextures.forEach((t, i) => { const n = e.createRenderbuffer(); s.msaaRenderBuffer[i] = n }) } else s.framebuffer = n; this.Jh(t, s) } Jh(t, s) { const i = t.colorTexture.source; if (s.width = i.pixelWidth, s.height = i.pixelHeight, t.colorTextures.forEach((t, s) => { 0 !== s && t.source.resize(i.width, i.height, i.G) }), s.msaa) { const i = this.Gi, e = i.gl, n = s.framebuffer; e.bindFramebuffer(e.FRAMEBUFFER, n), t.colorTextures.forEach((t, n) => { const r = t.source; i.texture.bindSource(r, 0); const o = i.texture.getGlSource(r).internalFormat, h = s.msaaRenderBuffer[n]; e.bindRenderbuffer(e.RENDERBUFFER, h), e.renderbufferStorageMultisample(e.RENDERBUFFER, 4, o, r.pixelWidth, r.pixelHeight), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + n, e.RENDERBUFFER, h) }) } } Zh(t) { if (null === t.framebuffer) return; const s = this.Gi.gl, i = s.createRenderbuffer(); t.depthStencilRenderBuffer = i, s.bindRenderbuffer(s.RENDERBUFFER, i), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.RENDERBUFFER, i), this.ta(t) } ta(t) { const s = this.Gi.gl; s.bindRenderbuffer(s.RENDERBUFFER, t.depthStencilRenderBuffer), t.msaa ? s.renderbufferStorageMultisample(s.RENDERBUFFER, 4, s.DEPTH24_STENCIL8, t.width, t.height) : s.renderbufferStorage(s.RENDERBUFFER, 2 === this.Gi.context.webGLVersion ? s.DEPTH24_STENCIL8 : s.DEPTH_STENCIL, t.width, t.height) } prerender(t) { const s = t.colorTexture.resource; this.Gi.context.multiView && Fs.test(s) && this.Gi.context.ensureCanvasSize(s) } postrender(t) { if (this.Gi.context.multiView && Fs.test(t.colorTexture.resource)) { const s = this.Gi.context.canvas, i = t.colorTexture; i.context2D.drawImage(s, 0, i.pixelHeight - s.height) } } } const Aa = new Map; function Ca(t, s) { if (!Aa.has(t)) { const i = new Z({ source: new Fs({ resource: t, ...s }) }), e = () => { Aa.get(t) === i && Aa.delete(t) }; i.once("destroy", e), i.source.once("destroy", e), Aa.set(t, i) } return Aa.get(t) } Rt.register(Aa); const _a = class t { constructor(s = {}) { if (this.uid = I("renderTarget"), this.colorTextures = [], this.dirtyId = 0, this.isRoot = !1, this.sa = new Float32Array(2), this.ia = !1, s = { ...t.defaultOptions, ...s }, this.stencil = s.stencil, this.depth = s.depth, this.isRoot = s.isRoot, "number" == typeof s.colorTextures) { this.ia = !0; for (let t = 0; t < s.colorTextures; t++)this.colorTextures.push(new q({ width: s.width, height: s.height, resolution: s.resolution, antialias: s.antialias })) } else { this.colorTextures = [...s.colorTextures.map(t => t.source)]; const t = this.colorTexture.source; this.resize(t.width, t.height, t.G) } this.colorTexture.source.on("resize", this.onSourceResize, this), (s.depthStencilTexture || this.stencil) && (s.depthStencilTexture instanceof Z || s.depthStencilTexture instanceof q ? this.depthStencilTexture = s.depthStencilTexture.source : this.ensureDepthStencilTexture()) } get size() { const t = this.sa; return t[0] = this.pixelWidth, t[1] = this.pixelHeight, t } get width() { return this.colorTexture.source.width } get height() { return this.colorTexture.source.height } get pixelWidth() { return this.colorTexture.source.pixelWidth } get pixelHeight() { return this.colorTexture.source.pixelHeight } get resolution() { return this.colorTexture.source.G } get colorTexture() { return this.colorTextures[0] } onSourceResize(t) { this.resize(t.width, t.height, t.G, !0) } ensureDepthStencilTexture() { this.depthStencilTexture || (this.depthStencilTexture = new q({ width: this.width, height: this.height, resolution: this.resolution, format: "depth24plus-stencil8", autoGenerateMipmaps: !1, antialias: !1, mipLevelCount: 1 })) } resize(t, s, i = this.resolution, e = !1) { this.dirtyId++, this.colorTextures.forEach((n, r) => { e && 0 === r || n.source.resize(t, s, i) }), this.depthStencilTexture && this.depthStencilTexture.source.resize(t, s, i) } destroy() { this.colorTexture.source.off("resize", this.onSourceResize, this), this.ia && this.colorTextures.forEach(t => { t.destroy() }), this.depthStencilTexture && (this.depthStencilTexture.destroy(), delete this.depthStencilTexture) } }; _a.defaultOptions = { width: 0, height: 0, resolution: 1, colorTextures: 1, stencil: !1, depth: !1, antialias: !1, isRoot: !1 }; let Sa = _a; class Pa { constructor(t) { this.rootViewPort = new O, this.viewport = new O, this.onRenderTargetChange = new Ie("onRenderTargetChange"), this.projectionMatrix = new w, this.defaultClearColor = [0, 0, 0, 0], this.ea = new Map, this.na = Object.create(null), this.ra = [], this.Gi = t, t.renderableGC.addManagedHash(this, "_gpuRenderTargetHash") } finishRenderPass() { this.adaptor.finishRenderPass(this.renderTarget) } renderStart({ target: t, clear: s, clearColor: i, frame: e }) { this.ra.length = 0, this.push(t, s, i, e), this.rootViewPort.copyFrom(this.viewport), this.rootRenderTarget = this.renderTarget, this.renderingToScreen = function (t) { const s = t.colorTexture.source.resource; return globalThis.HTMLCanvasElement && s instanceof HTMLCanvasElement && document.body.contains(s) }(this.rootRenderTarget), this.adaptor.prerender?.(this.rootRenderTarget) } postrender() { this.adaptor.postrender?.(this.rootRenderTarget) } bind(t, s = !0, i, e) { const n = this.getRenderTarget(t), r = this.renderTarget !== n; this.renderTarget = n, this.renderSurface = t; const o = this.getGpuRenderTarget(n); n.pixelWidth === o.width && n.pixelHeight === o.height || (this.adaptor.resizeGpuRenderTarget(n), o.width = n.pixelWidth, o.height = n.pixelHeight); const h = n.colorTexture, a = this.viewport, u = h.pixelWidth, l = h.pixelHeight; if (!e && t instanceof Z && (e = t.frame), e) { const t = h.G; a.x = e.x * t + .5 | 0, a.y = e.y * t + .5 | 0, a.width = e.width * t + .5 | 0, a.height = e.height * t + .5 | 0 } else a.x = 0, a.y = 0, a.width = u, a.height = l; return function (t, s, i, e, n, r) { const o = r ? 1 : -1; t.identity(), t.a = 1 / e * 2, t.d = o * (1 / n * 2), t.tx = -1 - 0 * t.a, t.ty = -o - 0 * t.d }(this.projectionMatrix, 0, 0, a.width / h.resolution, a.height / h.resolution, !n.isRoot), this.adaptor.startRenderPass(n, s, i, a), r && this.onRenderTargetChange.emit(n), n } clear(t, s = Ue.ALL, i) { s && (t && (t = this.getRenderTarget(t)), this.adaptor.clear(t || this.renderTarget, s, i, this.viewport)) } contextChange() { this.na = Object.create(null) } push(t, s = Ue.ALL, i, e) { const n = this.bind(t, s, i, e); return this.ra.push({ renderTarget: n, frame: e }), n } pop() { this.ra.pop(); const t = this.ra[this.ra.length - 1]; this.bind(t.renderTarget, !1, null, t.frame) } getRenderTarget(t) { return t.isTexture && (t = t.source), this.ea.get(t) ?? this.oa(t) } copyToTexture(t, s, i, e, n) { i.x < 0 && (e.width += i.x, n.x -= i.x, i.x = 0), i.y < 0 && (e.height += i.y, n.y -= i.y, i.y = 0); const { pixelWidth: r, pixelHeight: o } = t; return e.width = Math.min(e.width, r - i.x), e.height = Math.min(e.height, o - i.y), this.adaptor.copyToTexture(t, s, i, e, n) } ensureDepthStencil() { this.renderTarget.stencil || (this.renderTarget.stencil = !0, this.adaptor.startRenderPass(this.renderTarget, !1, null, this.viewport)) } destroy() { this.Gi = null, this.ea.forEach((t, s) => { t !== s && t.destroy() }), this.ea.clear(), this.na = Object.create(null) } oa(t) { let s = null; return Fs.test(t) && (t = Ca(t).source), t instanceof Sa ? s = t : t instanceof q && (s = new Sa({ colorTextures: [t] }), t.source instanceof Fs && (s.isRoot = !0), t.once("destroy", () => { s.destroy(), this.ea.delete(t); const i = this.na[s.uid]; i && (this.na[s.uid] = null, this.adaptor.destroyGpuRenderTarget(i)) })), this.ea.set(t, s), s } getGpuRenderTarget(t) { return this.na[t.uid] || (this.na[t.uid] = this.adaptor.initGpuRenderTarget(t)) } resetState() { this.renderTarget = null, this.renderSurface = null } } class ka extends Pa { constructor(t) { super(t), this.adaptor = new Ta, this.adaptor.init(t, this) } } ka.extension = { type: [r.WebGLSystem], name: "renderTarget" }; class Fa extends m { constructor({ buffer: t, offset: s, size: i }) { super(), this.uid = I("buffer"), this.F = "bufferResource", this.R = 0, this.U = I("resource"), this.ha = !0, this.destroyed = !1, this.buffer = t, this.offset = 0 | s, this.size = i, this.buffer.on("change", this.onBufferChange, this) } onBufferChange() { this.U = I("resource"), this.emit("change", this) } destroy(t = !1) { this.destroyed = !0, t && this.buffer.destroy(), this.emit("change", this), this.buffer = null, this.removeAllListeners() } } class Ea { constructor(t, s) { this.program = t, this.uniformData = s, this.uniformGroups = {}, this.uniformDirtyGroups = {}, this.uniformBlockBindings = {} } destroy() { this.uniformData = null, this.uniformGroups = null, this.uniformDirtyGroups = null, this.uniformBlockBindings = null, this.program = null } } function Ra(t, s, i) { const e = t.createShader(s); return t.shaderSource(e, i), t.compileShader(e), e } function Oa(t) { const s = new Array(t); for (let i = 0; i < s.length; i++)s[i] = !1; return s } function Ua(t, s) { switch (t) { case "float": case "int": case "uint": case "sampler2D": case "sampler2DArray": return 0; case "vec2": return new Float32Array(2 * s); case "vec3": return new Float32Array(3 * s); case "vec4": return new Float32Array(4 * s); case "ivec2": return new Int32Array(2 * s); case "ivec3": return new Int32Array(3 * s); case "ivec4": return new Int32Array(4 * s); case "uvec2": return new Uint32Array(2 * s); case "uvec3": return new Uint32Array(3 * s); case "uvec4": return new Uint32Array(4 * s); case "bool": return !1; case "bvec2": return Oa(2 * s); case "bvec3": return Oa(3 * s); case "bvec4": return Oa(4 * s); case "mat2": return new Float32Array([1, 0, 0, 1]); case "mat3": return new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]); case "mat4": return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]) }return null } let Ia = null; const Ba = { FLOAT: "float", FLOAT_VEC2: "vec2", FLOAT_VEC3: "vec3", FLOAT_VEC4: "vec4", INT: "int", INT_VEC2: "ivec2", INT_VEC3: "ivec3", INT_VEC4: "ivec4", UNSIGNED_INT: "uint", UNSIGNED_INT_VEC2: "uvec2", UNSIGNED_INT_VEC3: "uvec3", UNSIGNED_INT_VEC4: "uvec4", BOOL: "bool", BOOL_VEC2: "bvec2", BOOL_VEC3: "bvec3", BOOL_VEC4: "bvec4", FLOAT_MAT2: "mat2", FLOAT_MAT3: "mat3", FLOAT_MAT4: "mat4", SAMPLER_2D: "sampler2D", INT_SAMPLER_2D: "sampler2D", UNSIGNED_INT_SAMPLER_2D: "sampler2D", SAMPLER_CUBE: "samplerCube", INT_SAMPLER_CUBE: "samplerCube", UNSIGNED_INT_SAMPLER_CUBE: "samplerCube", SAMPLER_2D_ARRAY: "sampler2DArray", INT_SAMPLER_2D_ARRAY: "sampler2DArray", UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray" }, Ga = { float: "float32", vec2: "float32x2", vec3: "float32x3", vec4: "float32x4", int: "sint32", ivec2: "sint32x2", ivec3: "sint32x3", ivec4: "sint32x4", uint: "uint32", uvec2: "uint32x2", uvec3: "uint32x3", uvec4: "uint32x4", bool: "uint32", bvec2: "uint32x2", bvec3: "uint32x3", bvec4: "uint32x4" }; function $a(t, s) { if (!Ia) { const s = Object.keys(Ba); Ia = {}; for (let i = 0; i < s.length; ++i) { const e = s[i]; Ia[t[e]] = Ba[e] } } return Ia[s] } function za(t, s) { const i = $a(t, s); return Ga[i] || "float32" } function Da(t, s) { const i = t.getShaderSource(s).split("\n").map((t, s) => `${s}: ${t}`), e = t.getShaderInfoLog(s).split("\n"), n = {}, r = e.map(t => parseFloat(t.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"))).filter(t => !(!t || n[t] || (n[t] = !0, 0))), o = [""]; r.forEach(t => { i[t - 1] = `%c${i[t - 1]}%c`, o.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px") }); const h = i.join("\n"); o[0] = h } const ja = { textureCount: 0, blockIndex: 0 }; class La { constructor(t) { this.$h = null, this.aa = Object.create(null), this.ua = Object.create(null), this.Gi = t, this.Gi.renderableGC.addManagedHash(this, "_programDataHash") } contextChange(t) { this.Th = t, this.aa = Object.create(null), this.ua = Object.create(null), this.$h = null } bind(t, s) { if (this.la(t.glProgram), s) return; ja.textureCount = 0, ja.blockIndex = 0; let i = this.ua[t.glProgram.Me]; i || (i = this.ua[t.glProgram.Me] = this.ca(t, this)), this.Gi.buffer.nextBindBase(!!t.glProgram.transformFeedbackVaryings), i(this.Gi, t, ja) } updateUniformGroup(t) { this.Gi.uniformGroup.updateUniformGroup(t, this.$h, ja) } bindUniformBlock(t, s, i = 0) { const e = this.Gi.buffer, n = this.kh(this.$h), r = t.ha; r || this.Gi.ubo.updateUniformGroup(t); const o = t.buffer, h = e.updateBuffer(o), a = e.freeLocationForBufferBase(h); if (r) { const { offset: s, size: i } = t; 0 === s && i === o.data.byteLength ? e.bindBufferBase(h, a) : e.bindBufferRange(h, a, s) } else e.getLastBindBaseLocation(h) !== a && e.bindBufferBase(h, a); const u = this.$h.Ce[s].index; n.uniformBlockBindings[i] !== a && (n.uniformBlockBindings[i] = a, this.Gi.gl.uniformBlockBinding(n.program, u, a)) } la(t) { if (this.$h === t) return; this.$h = t; const s = this.kh(t); this.Th.useProgram(s.program) } kh(t) { return this.aa[t.Me] || this.fa(t) } fa(t) { const s = t.Me; return this.aa[s] = function (t, s) { const i = Ra(t, t.VERTEX_SHADER, s.vertex), e = Ra(t, t.FRAGMENT_SHADER, s.fragment), n = t.createProgram(); t.attachShader(n, i), t.attachShader(n, e); const r = s.transformFeedbackVaryings; r && ("function" != typeof t.transformFeedbackVaryings ? Et() : t.transformFeedbackVaryings(n, r.names, "separate" === r.bufferMode ? t.SEPARATE_ATTRIBS : t.INTERLEAVED_ATTRIBS)), t.linkProgram(n), t.getProgramParameter(n, t.LINK_STATUS) || function (t, s, i, e) { t.getProgramParameter(s, t.LINK_STATUS) || (t.getShaderParameter(i, t.COMPILE_STATUS) || Da(t, i), t.getShaderParameter(e, t.COMPILE_STATUS) || Da(t, e), t.getProgramInfoLog(s)) }(t, n, i, e), s.Te = function (t, s, i = !1) { const e = {}, n = s.getProgramParameter(t, s.ACTIVE_ATTRIBUTES); for (let o = 0; o < n; o++) { const i = s.getActiveAttrib(t, o); if (i.name.startsWith("gl_")) continue; const n = za(s, i.type); e[i.name] = { location: 0, format: n, stride: zi(n).stride, offset: 0, instance: !1, start: 0 } } const r = Object.keys(e); if (i) { r.sort((t, s) => t > s ? 1 : -1); for (let i = 0; i < r.length; i++)e[r[i]].location = i, s.bindAttribLocation(t, i, r[i]); s.linkProgram(t) } else for (let o = 0; o < r.length; o++)e[r[o]].location = s.getAttribLocation(t, r[o]); return e }(n, t, !/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(s.vertex)), s.Ae = function (t, s) { const i = {}, e = s.getProgramParameter(t, s.ACTIVE_UNIFORMS); for (let n = 0; n < e; n++) { const e = s.getActiveUniform(t, n), r = e.name.replace(/\[.*?\]$/, ""), o = !!e.name.match(/\[.*?\]$/), h = $a(s, e.type); i[r] = { name: r, index: n, type: h, size: e.size, isArray: o, value: Ua(h, e.size) } } return i }(n, t), s.Ce = function (t, s) { if (!s.ACTIVE_UNIFORM_BLOCKS) return {}; const i = {}, e = s.getProgramParameter(t, s.ACTIVE_UNIFORM_BLOCKS); for (let n = 0; n < e; n++) { const e = s.getActiveUniformBlockName(t, n), r = s.getUniformBlockIndex(t, e), o = s.getActiveUniformBlockParameter(t, n, s.UNIFORM_BLOCK_DATA_SIZE); i[e] = { name: e, index: r, size: o } } return i }(n, t), t.deleteShader(i), t.deleteShader(e); const o = {}; for (const h in s.Ae) { const i = s.Ae[h]; o[h] = { location: t.getUniformLocation(n, h), value: Ua(i.type, i.size) } } return new Ea(n, o) }(this.Th, t), this.aa[s] } destroy() { for (const t of Object.keys(this.aa)) this.aa[t].destroy(), this.aa[t] = null; this.aa = null, this.ua = null, this.$h = null, this.Gi = null, this.Th = null } ca(t, s) { return function (t, s) { const i = [], e = ["\n        var g = s.groups;\n        var sS = r.shader;\n        var p = s.glProgram;\n        var ugS = r.uniformGroup;\n        var resources;\n    "]; let n = !1, r = 0; const o = s.kh(t.glProgram); for (const a in t.groups) { const h = t.groups[a]; i.push(`\n            resources = g[${a}].resources;\n        `); for (const u in h.resources) { const l = h.resources[u]; if (l instanceof Yi) if (l.ubo) { const s = t.Ie[a][Number(u)]; i.push(`\n                        sS.bindUniformBlock(\n                            resources[${u}],\n                            '${s}',\n                            ${t.glProgram.Ce[s].index}\n                        );\n                    `) } else i.push(`\n                        ugS.updateUniformGroup(resources[${u}], p, sD);\n                    `); else if (l instanceof Fa) { const s = t.Ie[a][Number(u)]; i.push(`\n                    sS.bindUniformBlock(\n                        resources[${u}],\n                        '${s}',\n                        ${t.glProgram.Ce[s].index}\n                    );\n                `) } else if (l instanceof q) { const h = t.Ie[a][u], l = o.uniformData[h]; l && (n || (n = !0, e.push("\n                        var tS = r.texture;\n                        ")), s.Th.uniform1i(l.location, r), i.push(`\n                        tS.bind(resources[${u}], ${r});\n                    `), r++) } } } const h = [...e, ...i].join("\n"); return new Function("r", "s", "sD", h) }(t, s) } resetState() { this.$h = null } } La.extension = { type: [r.WebGLSystem], name: "shader" }; const Va = { f32: "if (cv !== v) {\n            cu.value = v;\n            gl.uniform1f(location, v);\n        }", "vec2<f32>": "if (cv[0] !== v[0] || cv[1] !== v[1]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            gl.uniform2f(location, v[0], v[1]);\n        }", "vec3<f32>": "if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            gl.uniform3f(location, v[0], v[1], v[2]);\n        }", "vec4<f32>": "if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            cv[3] = v[3];\n            gl.uniform4f(location, v[0], v[1], v[2], v[3]);\n        }", i32: "if (cv !== v) {\n            cu.value = v;\n            gl.uniform1i(location, v);\n        }", "vec2<i32>": "if (cv[0] !== v[0] || cv[1] !== v[1]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            gl.uniform2i(location, v[0], v[1]);\n        }", "vec3<i32>": "if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            gl.uniform3i(location, v[0], v[1], v[2]);\n        }", "vec4<i32>": "if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            cv[3] = v[3];\n            gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n        }", u32: "if (cv !== v) {\n            cu.value = v;\n            gl.uniform1ui(location, v);\n        }", "vec2<u32>": "if (cv[0] !== v[0] || cv[1] !== v[1]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            gl.uniform2ui(location, v[0], v[1]);\n        }", "vec3<u32>": "if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            gl.uniform3ui(location, v[0], v[1], v[2]);\n        }", "vec4<u32>": "if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            cv[3] = v[3];\n            gl.uniform4ui(location, v[0], v[1], v[2], v[3]);\n        }", bool: "if (cv !== v) {\n            cu.value = v;\n            gl.uniform1i(location, v);\n        }", "vec2<bool>": "if (cv[0] !== v[0] || cv[1] !== v[1]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            gl.uniform2i(location, v[0], v[1]);\n        }", "vec3<bool>": "if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            gl.uniform3i(location, v[0], v[1], v[2]);\n        }", "vec4<bool>": "if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            cv[3] = v[3];\n            gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n        }", "mat2x2<f32>": "gl.uniformMatrix2fv(location, false, v);", "mat3x3<f32>": "gl.uniformMatrix3fv(location, false, v);", "mat4x4<f32>": "gl.uniformMatrix4fv(location, false, v);" }, Na = { f32: "gl.uniform1fv(location, v);", "vec2<f32>": "gl.uniform2fv(location, v);", "vec3<f32>": "gl.uniform3fv(location, v);", "vec4<f32>": "gl.uniform4fv(location, v);", "mat2x2<f32>": "gl.uniformMatrix2fv(location, false, v);", "mat3x3<f32>": "gl.uniformMatrix3fv(location, false, v);", "mat4x4<f32>": "gl.uniformMatrix4fv(location, false, v);", i32: "gl.uniform1iv(location, v);", "vec2<i32>": "gl.uniform2iv(location, v);", "vec3<i32>": "gl.uniform3iv(location, v);", "vec4<i32>": "gl.uniform4iv(location, v);", u32: "gl.uniform1iv(location, v);", "vec2<u32>": "gl.uniform2iv(location, v);", "vec3<u32>": "gl.uniform3iv(location, v);", "vec4<u32>": "gl.uniform4iv(location, v);", bool: "gl.uniform1iv(location, v);", "vec2<bool>": "gl.uniform2iv(location, v);", "vec3<bool>": "gl.uniform3iv(location, v);", "vec4<bool>": "gl.uniform4iv(location, v);" }; class Wa { constructor(t) { this.hi = {}, this.da = {}, this.Gi = t, this.gl = null, this.hi = {} } contextChange(t) { this.gl = t } updateUniformGroup(t, s, i) { const e = this.Gi.shader.kh(s); t.isStatic && t.Fe === e.uniformDirtyGroups[t.uid] || (e.uniformDirtyGroups[t.uid] = t.Fe, this.pa(t, s)(e.uniformData, t.uniforms, this.Gi, i)) } pa(t, s) { return this.da[t.Ee]?.[s.Me] || this.ma(t, s) } ma(t, s) { const i = this.da[t.Ee] || (this.da[t.Ee] = {}), e = this.ga(t, s.Ae, "u"); return this.hi[e] || (this.hi[e] = this.va(t, s.Ae)), i[s.Me] = this.hi[e], i[s.Me] } va(t, s) { return function (t, s) { const i = ["\n        var v = null;\n        var cv = null;\n        var cu = null;\n        var t = 0;\n        var gl = renderer.gl;\n        var name = null;\n    "]; for (const e in t.uniforms) { if (!s[e]) { t.uniforms[e] instanceof Yi ? t.uniforms[e].ubo ? i.push(`\n                        renderer.shader.bindUniformBlock(uv.${e}, "${e}");\n                    `) : i.push(`\n                        renderer.shader.updateUniformGroup(uv.${e});\n                    `) : t.uniforms[e] instanceof Fa && i.push(`\n                        renderer.shader.bindBufferResource(uv.${e}, "${e}");\n                    `); continue } const n = t.uniformStructures[e]; let r = !1; for (let t = 0; t < ma.length; t++) { const s = ma[t]; if (n.type === s.type && s.test(n)) { i.push(`name = "${e}";`, ma[t].uniform), r = !0; break } } if (!r) { const t = (1 === n.size ? Va : Na)[n.type].replace("location", `ud["${e}"].location`); i.push(`\n            cu = ud["${e}"];\n            cv = cu.value;\n            v = uv["${e}"];\n            ${t};`) } } return new Function("ud", "uv", "renderer", "syncData", i.join("\n")) }(t, s) } ga(t, s, i) { const e = t.uniforms, n = [`${i}-`]; for (const r in e) n.push(r), s[r] && n.push(s[r].type); return n.join("-") } destroy() { this.Gi = null, this.hi = null } } Wa.extension = { type: [r.WebGLSystem], name: "uniformGroup" }; const Ha = class t { constructor(t) { this.ba = !1, this.gl = null, this.stateId = 0, this.polygonOffset = 0, this.blendMode = "none", this.xa = !1, this.map = [], this.map[0] = this.setBlend, this.map[1] = this.setOffset, this.map[2] = this.setCullFace, this.map[3] = this.setDepthTest, this.map[4] = this.setFrontFace, this.map[5] = this.setDepthMask, this.checks = [], this.defaultState = se.for2d(), t.renderTarget.onRenderTargetChange.add(this) } onRenderTargetChange(t) { this.ba = !t.isRoot, this.ya ? this.setFrontFace(this.wa) : this.Ma = !0 } contextChange(t) { this.gl = t, this.blendModesMap = function (t) { const s = {}; if (s.normal = [t.ONE, t.ONE_MINUS_SRC_ALPHA], s.add = [t.ONE, t.ONE], s.multiply = [t.DST_COLOR, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA], s.screen = [t.ONE, t.ONE_MINUS_SRC_COLOR, t.ONE, t.ONE_MINUS_SRC_ALPHA], s.none = [0, 0], s["normal-npm"] = [t.SRC_ALPHA, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA], s["add-npm"] = [t.SRC_ALPHA, t.ONE, t.ONE, t.ONE], s["screen-npm"] = [t.SRC_ALPHA, t.ONE_MINUS_SRC_COLOR, t.ONE, t.ONE_MINUS_SRC_ALPHA], s.erase = [t.ZERO, t.ONE_MINUS_SRC_ALPHA], t instanceof ks.get().getWebGLRenderingContext()) { const i = t.getExtension("EXT_blend_minmax"); i && (s.min = [t.ONE, t.ONE, t.ONE, t.ONE, i.MIN_EXT, i.MIN_EXT], s.max = [t.ONE, t.ONE, t.ONE, t.ONE, i.MAX_EXT, i.MAX_EXT]) } else s.min = [t.ONE, t.ONE, t.ONE, t.ONE, t.MIN, t.MIN], s.max = [t.ONE, t.ONE, t.ONE, t.ONE, t.MAX, t.MAX]; return s }(t), this.resetState() } set(t) { if (t || (t = this.defaultState), this.stateId !== t.data) { let s = this.stateId ^ t.data, i = 0; for (; s;)1 & s && this.map[i].call(this, !!(t.data & 1 << i)), s >>= 1, i++; this.stateId = t.data } for (let s = 0; s < this.checks.length; s++)this.checks[s](this, t) } forceState(t) { t || (t = this.defaultState); for (let s = 0; s < this.map.length; s++)this.map[s].call(this, !!(t.data & 1 << s)); for (let s = 0; s < this.checks.length; s++)this.checks[s](this, t); this.stateId = t.data } setBlend(s) { this.Ta(t.Aa, s), this.gl[s ? "enable" : "disable"](this.gl.BLEND) } setOffset(s) { this.Ta(t.Ca, s), this.gl[s ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL) } setDepthTest(t) { this.gl[t ? "enable" : "disable"](this.gl.DEPTH_TEST) } setDepthMask(t) { this.gl.depthMask(t) } setCullFace(t) { this.ya = t, this.gl[t ? "enable" : "disable"](this.gl.CULL_FACE), this.ya && this.Ma && this.setFrontFace(this.wa) } setFrontFace(t) { this.wa = t, this.Ma = !1; const s = this.ba ? !t : t; this._a !== s && (this._a = s, this.gl.frontFace(this.gl[s ? "CW" : "CCW"])) } setBlendMode(t) { if (this.blendModesMap[t] || (t = "normal"), t === this.blendMode) return; this.blendMode = t; const s = this.blendModesMap[t], i = this.gl; 2 === s.length ? i.blendFunc(s[0], s[1]) : i.blendFuncSeparate(s[0], s[1], s[2], s[3]), 6 === s.length ? (this.xa = !0, i.blendEquationSeparate(s[4], s[5])) : this.xa && (this.xa = !1, i.blendEquationSeparate(i.FUNC_ADD, i.FUNC_ADD)) } setPolygonOffset(t, s) { this.gl.polygonOffset(t, s) } resetState() { this._a = !1, this.wa = !1, this.ya = !1, this.Ma = !1, this.ba = !1, this.gl.frontFace(this.gl.CCW), this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, !1), this.forceState(this.defaultState), this.xa = !0, this.blendMode = "", this.setBlendMode("normal") } Ta(t, s) { const i = this.checks.indexOf(t); s && -1 === i ? this.checks.push(t) : s || -1 === i || this.checks.splice(i, 1) } static Aa(t, s) { t.setBlendMode(s.blendMode) } static Ca(t, s) { t.setPolygonOffset(1, s.polygonOffset) } destroy() { this.gl = null, this.checks.length = 0 } }; Ha.extension = { type: [r.WebGLSystem], name: "state" }; let qa = Ha; class Xa { constructor(t) { this.target = Zh.TEXTURE_2D, this.texture = t, this.width = -1, this.height = -1, this.type = Qh.UNSIGNED_BYTE, this.internalFormat = Kh.RGBA, this.format = Kh.RGBA, this.samplerType = 0 } } const Ya = { id: "buffer", upload(t, s, i) { s.width === t.width || s.height === t.height ? i.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, t.width, t.height, s.format, s.type, t.resource) : i.texImage2D(s.target, 0, s.internalFormat, t.width, t.height, 0, s.format, s.type, t.resource), s.width = t.width, s.height = t.height } }, Ka = { "bc1-rgba-unorm": !0, "bc1-rgba-unorm-srgb": !0, "bc2-rgba-unorm": !0, "bc2-rgba-unorm-srgb": !0, "bc3-rgba-unorm": !0, "bc3-rgba-unorm-srgb": !0, "bc4-r-unorm": !0, "bc4-r-snorm": !0, "bc5-rg-unorm": !0, "bc5-rg-snorm": !0, "bc6h-rgb-ufloat": !0, "bc6h-rgb-float": !0, "bc7-rgba-unorm": !0, "bc7-rgba-unorm-srgb": !0, "etc2-rgb8unorm": !0, "etc2-rgb8unorm-srgb": !0, "etc2-rgb8a1unorm": !0, "etc2-rgb8a1unorm-srgb": !0, "etc2-rgba8unorm": !0, "etc2-rgba8unorm-srgb": !0, "eac-r11unorm": !0, "eac-r11snorm": !0, "eac-rg11unorm": !0, "eac-rg11snorm": !0, "astc-4x4-unorm": !0, "astc-4x4-unorm-srgb": !0, "astc-5x4-unorm": !0, "astc-5x4-unorm-srgb": !0, "astc-5x5-unorm": !0, "astc-5x5-unorm-srgb": !0, "astc-6x5-unorm": !0, "astc-6x5-unorm-srgb": !0, "astc-6x6-unorm": !0, "astc-6x6-unorm-srgb": !0, "astc-8x5-unorm": !0, "astc-8x5-unorm-srgb": !0, "astc-8x6-unorm": !0, "astc-8x6-unorm-srgb": !0, "astc-8x8-unorm": !0, "astc-8x8-unorm-srgb": !0, "astc-10x5-unorm": !0, "astc-10x5-unorm-srgb": !0, "astc-10x6-unorm": !0, "astc-10x6-unorm-srgb": !0, "astc-10x8-unorm": !0, "astc-10x8-unorm-srgb": !0, "astc-10x10-unorm": !0, "astc-10x10-unorm-srgb": !0, "astc-12x10-unorm": !0, "astc-12x10-unorm-srgb": !0, "astc-12x12-unorm": !0, "astc-12x12-unorm-srgb": !0 }, Za = { id: "compressed", upload(t, s, i) { i.pixelStorei(i.UNPACK_ALIGNMENT, 4); let e = t.pixelWidth, n = t.pixelHeight; const r = !!Ka[t.format]; for (let o = 0; o < t.resource.length; o++) { const h = t.resource[o]; r ? i.compressedTexImage2D(i.TEXTURE_2D, o, s.internalFormat, e, n, 0, h) : i.texImage2D(i.TEXTURE_2D, o, s.internalFormat, e, n, 0, s.format, s.type, h), e = Math.max(e >> 1, 1), n = Math.max(n >> 1, 1) } } }, Qa = { id: "image", upload(t, s, i, e) { const n = s.width, r = s.height, o = t.pixelWidth, h = t.pixelHeight, a = t.resourceWidth, u = t.resourceHeight; a < o || u < h ? (n === o && r === h || i.texImage2D(s.target, 0, s.internalFormat, o, h, 0, s.format, s.type, null), 2 === e ? i.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, a, u, s.format, s.type, t.resource) : i.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, s.format, s.type, t.resource)) : n === o && r === h ? i.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, s.format, s.type, t.resource) : 2 === e ? i.texImage2D(s.target, 0, s.internalFormat, o, h, 0, s.format, s.type, t.resource) : i.texImage2D(s.target, 0, s.internalFormat, s.format, s.type, t.resource), s.width = o, s.height = h } }, Ja = { id: "video", upload(t, s, i, e) { t.isValid ? Qa.upload(t, s, i, e) : i.texImage2D(s.target, 0, s.internalFormat, 1, 1, 0, s.format, s.type, null) } }, tu = { linear: 9729, nearest: 9728 }, su = { linear: { linear: 9987, nearest: 9985 }, nearest: { linear: 9986, nearest: 9984 } }, iu = { "clamp-to-edge": 33071, repeat: 10497, "mirror-repeat": 33648 }, eu = { never: 512, less: 513, equal: 514, "less-equal": 515, greater: 516, "not-equal": 517, "greater-equal": 518, always: 519 }; function nu(t, s, i, e, n, r, o, h) { const a = r; if (!h || "repeat" !== t.addressModeU || "repeat" !== t.addressModeV || "repeat" !== t.addressModeW) { const i = iu[o ? "clamp-to-edge" : t.addressModeU], e = iu[o ? "clamp-to-edge" : t.addressModeV], r = iu[o ? "clamp-to-edge" : t.addressModeW]; s[n](a, s.TEXTURE_WRAP_S, i), s[n](a, s.TEXTURE_WRAP_T, e), s.TEXTURE_WRAP_R && s[n](a, s.TEXTURE_WRAP_R, r) } if (h && "linear" === t.magFilter || s[n](a, s.TEXTURE_MAG_FILTER, tu[t.magFilter]), i) { if (!h || "linear" !== t.mipmapFilter) { const i = su[t.minFilter][t.mipmapFilter]; s[n](a, s.TEXTURE_MIN_FILTER, i) } } else s[n](a, s.TEXTURE_MIN_FILTER, tu[t.minFilter]); if (e && t.maxAnisotropy > 1) { const i = Math.min(t.maxAnisotropy, s.getParameter(e.MAX_TEXTURE_MAX_ANISOTROPY_EXT)); s[n](a, e.TEXTURE_MAX_ANISOTROPY_EXT, i) } t.compare && s[n](a, s.TEXTURE_COMPARE_FUNC, eu[t.compare]) } class ru { constructor(t) { this.managedTextures = [], this.Sa = Object.create(null), this.Pa = Object.create(null), this.ka = [], this.Fa = -1, this.Ea = Object.create(null), this.Ra = { image: Qa, buffer: Ya, video: Ja, compressed: Za }, this.Oa = !1, this.Ua = !1, this.Gi = t, this.Gi.renderableGC.addManagedHash(this, "_glTextures"), this.Gi.renderableGC.addManagedHash(this, "_glSamplers") } contextChange(t) { this.Th = t, this.Ia || (this.Ia = function (t, s) { let i = {}, e = t.RGBA; return t instanceof ks.get().getWebGLRenderingContext() ? s.srgb && (i = { "rgba8unorm-srgb": s.srgb.SRGB8_ALPHA8_EXT, "bgra8unorm-srgb": s.srgb.SRGB8_ALPHA8_EXT }) : (i = { "rgba8unorm-srgb": t.SRGB8_ALPHA8, "bgra8unorm-srgb": t.SRGB8_ALPHA8 }, e = t.RGBA8), { r8unorm: t.R8, r8snorm: t.R8_SNORM, r8uint: t.R8UI, r8sint: t.R8I, r16uint: t.R16UI, r16sint: t.R16I, r16float: t.R16F, rg8unorm: t.RG8, rg8snorm: t.RG8_SNORM, rg8uint: t.RG8UI, rg8sint: t.RG8I, r32uint: t.R32UI, r32sint: t.R32I, r32float: t.R32F, rg16uint: t.RG16UI, rg16sint: t.RG16I, rg16float: t.RG16F, rgba8unorm: t.RGBA, ...i, rgba8snorm: t.RGBA8_SNORM, rgba8uint: t.RGBA8UI, rgba8sint: t.RGBA8I, bgra8unorm: e, rgb9e5ufloat: t.RGB9_E5, rgb10a2unorm: t.RGB10_A2, rg11b10ufloat: t.R11F_G11F_B10F, rg32uint: t.RG32UI, rg32sint: t.RG32I, rg32float: t.RG32F, rgba16uint: t.RGBA16UI, rgba16sint: t.RGBA16I, rgba16float: t.RGBA16F, rgba32uint: t.RGBA32UI, rgba32sint: t.RGBA32I, rgba32float: t.RGBA32F, stencil8: t.STENCIL_INDEX8, depth16unorm: t.DEPTH_COMPONENT16, depth24plus: t.DEPTH_COMPONENT24, "depth24plus-stencil8": t.DEPTH24_STENCIL8, depth32float: t.DEPTH_COMPONENT32F, "depth32float-stencil8": t.DEPTH32F_STENCIL8, ...s.s3tc ? { "bc1-rgba-unorm": s.s3tc.COMPRESSED_RGBA_S3TC_DXT1_EXT, "bc2-rgba-unorm": s.s3tc.COMPRESSED_RGBA_S3TC_DXT3_EXT, "bc3-rgba-unorm": s.s3tc.COMPRESSED_RGBA_S3TC_DXT5_EXT } : {}, ...s.s3tc_sRGB ? { "bc1-rgba-unorm-srgb": s.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT, "bc2-rgba-unorm-srgb": s.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT, "bc3-rgba-unorm-srgb": s.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT } : {}, ...s.rgtc ? { "bc4-r-unorm": s.rgtc.COMPRESSED_RED_RGTC1_EXT, "bc4-r-snorm": s.rgtc.COMPRESSED_SIGNED_RED_RGTC1_EXT, "bc5-rg-unorm": s.rgtc.COMPRESSED_RED_GREEN_RGTC2_EXT, "bc5-rg-snorm": s.rgtc.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT } : {}, ...s.bptc ? { "bc6h-rgb-float": s.bptc.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT, "bc6h-rgb-ufloat": s.bptc.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT, "bc7-rgba-unorm": s.bptc.COMPRESSED_RGBA_BPTC_UNORM_EXT, "bc7-rgba-unorm-srgb": s.bptc.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT } : {}, ...s.etc ? { "etc2-rgb8unorm": s.etc.COMPRESSED_RGB8_ETC2, "etc2-rgb8unorm-srgb": s.etc.COMPRESSED_SRGB8_ETC2, "etc2-rgb8a1unorm": s.etc.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2, "etc2-rgb8a1unorm-srgb": s.etc.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2, "etc2-rgba8unorm": s.etc.COMPRESSED_RGBA8_ETC2_EAC, "etc2-rgba8unorm-srgb": s.etc.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC, "eac-r11unorm": s.etc.COMPRESSED_R11_EAC, "eac-rg11unorm": s.etc.COMPRESSED_SIGNED_RG11_EAC } : {}, ...s.astc ? { "astc-4x4-unorm": s.astc.COMPRESSED_RGBA_ASTC_4x4_KHR, "astc-4x4-unorm-srgb": s.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR, "astc-5x4-unorm": s.astc.COMPRESSED_RGBA_ASTC_5x4_KHR, "astc-5x4-unorm-srgb": s.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR, "astc-5x5-unorm": s.astc.COMPRESSED_RGBA_ASTC_5x5_KHR, "astc-5x5-unorm-srgb": s.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR, "astc-6x5-unorm": s.astc.COMPRESSED_RGBA_ASTC_6x5_KHR, "astc-6x5-unorm-srgb": s.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR, "astc-6x6-unorm": s.astc.COMPRESSED_RGBA_ASTC_6x6_KHR, "astc-6x6-unorm-srgb": s.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR, "astc-8x5-unorm": s.astc.COMPRESSED_RGBA_ASTC_8x5_KHR, "astc-8x5-unorm-srgb": s.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR, "astc-8x6-unorm": s.astc.COMPRESSED_RGBA_ASTC_8x6_KHR, "astc-8x6-unorm-srgb": s.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR, "astc-8x8-unorm": s.astc.COMPRESSED_RGBA_ASTC_8x8_KHR, "astc-8x8-unorm-srgb": s.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR, "astc-10x5-unorm": s.astc.COMPRESSED_RGBA_ASTC_10x5_KHR, "astc-10x5-unorm-srgb": s.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR, "astc-10x6-unorm": s.astc.COMPRESSED_RGBA_ASTC_10x6_KHR, "astc-10x6-unorm-srgb": s.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR, "astc-10x8-unorm": s.astc.COMPRESSED_RGBA_ASTC_10x8_KHR, "astc-10x8-unorm-srgb": s.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR, "astc-10x10-unorm": s.astc.COMPRESSED_RGBA_ASTC_10x10_KHR, "astc-10x10-unorm-srgb": s.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR, "astc-12x10-unorm": s.astc.COMPRESSED_RGBA_ASTC_12x10_KHR, "astc-12x10-unorm-srgb": s.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR, "astc-12x12-unorm": s.astc.COMPRESSED_RGBA_ASTC_12x12_KHR, "astc-12x12-unorm-srgb": s.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR } : {} } }(t, this.Gi.context.extensions), this.Ba = function (t) { return { r8unorm: t.UNSIGNED_BYTE, r8snorm: t.BYTE, r8uint: t.UNSIGNED_BYTE, r8sint: t.BYTE, r16uint: t.UNSIGNED_SHORT, r16sint: t.SHORT, r16float: t.HALF_FLOAT, rg8unorm: t.UNSIGNED_BYTE, rg8snorm: t.BYTE, rg8uint: t.UNSIGNED_BYTE, rg8sint: t.BYTE, r32uint: t.UNSIGNED_INT, r32sint: t.INT, r32float: t.FLOAT, rg16uint: t.UNSIGNED_SHORT, rg16sint: t.SHORT, rg16float: t.HALF_FLOAT, rgba8unorm: t.UNSIGNED_BYTE, "rgba8unorm-srgb": t.UNSIGNED_BYTE, rgba8snorm: t.BYTE, rgba8uint: t.UNSIGNED_BYTE, rgba8sint: t.BYTE, bgra8unorm: t.UNSIGNED_BYTE, "bgra8unorm-srgb": t.UNSIGNED_BYTE, rgb9e5ufloat: t.UNSIGNED_INT_5_9_9_9_REV, rgb10a2unorm: t.UNSIGNED_INT_2_10_10_10_REV, rg11b10ufloat: t.UNSIGNED_INT_10F_11F_11F_REV, rg32uint: t.UNSIGNED_INT, rg32sint: t.INT, rg32float: t.FLOAT, rgba16uint: t.UNSIGNED_SHORT, rgba16sint: t.SHORT, rgba16float: t.HALF_FLOAT, rgba32uint: t.UNSIGNED_INT, rgba32sint: t.INT, rgba32float: t.FLOAT, stencil8: t.UNSIGNED_BYTE, depth16unorm: t.UNSIGNED_SHORT, depth24plus: t.UNSIGNED_INT, "depth24plus-stencil8": t.UNSIGNED_INT_24_8, depth32float: t.FLOAT, "depth32float-stencil8": t.FLOAT_32_UNSIGNED_INT_24_8_REV } }(t), this.Ga = function (t) { return { r8unorm: t.RED, r8snorm: t.RED, r8uint: t.RED, r8sint: t.RED, r16uint: t.RED, r16sint: t.RED, r16float: t.RED, rg8unorm: t.RG, rg8snorm: t.RG, rg8uint: t.RG, rg8sint: t.RG, r32uint: t.RED, r32sint: t.RED, r32float: t.RED, rg16uint: t.RG, rg16sint: t.RG, rg16float: t.RG, rgba8unorm: t.RGBA, "rgba8unorm-srgb": t.RGBA, rgba8snorm: t.RGBA, rgba8uint: t.RGBA, rgba8sint: t.RGBA, bgra8unorm: t.RGBA, "bgra8unorm-srgb": t.RGBA, rgb9e5ufloat: t.RGB, rgb10a2unorm: t.RGBA, rg11b10ufloat: t.RGB, rg32uint: t.RG, rg32sint: t.RG, rg32float: t.RG, rgba16uint: t.RGBA, rgba16sint: t.RGBA, rgba16float: t.RGBA, rgba32uint: t.RGBA, rgba32sint: t.RGBA, rgba32float: t.RGBA, stencil8: t.STENCIL_INDEX8, depth16unorm: t.DEPTH_COMPONENT, depth24plus: t.DEPTH_COMPONENT, "depth24plus-stencil8": t.DEPTH_STENCIL, depth32float: t.DEPTH_COMPONENT, "depth32float-stencil8": t.DEPTH_STENCIL } }(t)), this.Sa = Object.create(null), this.Pa = Object.create(null), this.Ea = Object.create(null), this.Oa = !1; for (let s = 0; s < 16; s++)this.bind(Z.EMPTY, s) } initSource(t) { this.bind(t) } bind(t, s = 0) { const i = t.source; t ? (this.bindSource(i, s), this.Ua && this.$a(i.style, s)) : (this.bindSource(null, s), this.Ua && this.$a(null, s)) } bindSource(t, s = 0) { const i = this.Th; if (t.R = this.Gi.textureGC.count, this.ka[s] !== t) { this.ka[s] = t, this.za(s), t || (t = Z.EMPTY.source); const e = this.getGlSource(t); i.bindTexture(e.target, e.texture) } } $a(t, s = 0) { const i = this.Th; if (!t) return this.Ea[s] = null, void i.bindSampler(s, null); const e = this.Da(t); this.Ea[s] !== e && (this.Ea[s] = e, i.bindSampler(s, e)) } unbind(t) { const s = t.source, i = this.ka, e = this.Th; for (let n = 0; n < i.length; n++)if (i[n] === s) { this.za(n); const t = this.getGlSource(s); e.bindTexture(t.target, null), i[n] = null } } za(t) { this.Fa !== t && (this.Fa = t, this.Th.activeTexture(this.Th.TEXTURE0 + t)) } ja(t) { const s = this.Th, i = new Xa(s.createTexture()); if (i.type = this.Ba[t.format], i.internalFormat = this.Ia[t.format], i.format = this.Ga[t.format], t.autoGenerateMipmaps && (this.Gi.context.supports.nonPowOf2mipmaps || t.isPowerOfTwo)) { const s = Math.max(t.width, t.height); t.mipLevelCount = Math.floor(Math.log2(s)) + 1 } return this.Sa[t.uid] = i, this.managedTextures.includes(t) || (t.on("update", this.onSourceUpdate, this), t.on("resize", this.onSourceUpdate, this), t.on("styleChange", this.onStyleChange, this), t.on("destroy", this.onSourceDestroy, this), t.on("unload", this.onSourceUnload, this), t.on("updateMipmaps", this.onUpdateMipmaps, this), this.managedTextures.push(t)), this.onSourceUpdate(t), this.updateStyle(t, !1), i } onStyleChange(t) { this.updateStyle(t, !1) } updateStyle(t, s) { const i = this.Th, e = this.getGlSource(t); i.bindTexture(i.TEXTURE_2D, e.texture), this.ka[this.Fa] = t, nu(t.style, i, t.mipLevelCount > 1, this.Gi.context.extensions.anisotropicFiltering, "texParameteri", i.TEXTURE_2D, !this.Gi.context.supports.nonPowOf2wrapping && !t.isPowerOfTwo, s) } onSourceUnload(t) { const s = this.Sa[t.uid]; s && (this.unbind(t), this.Sa[t.uid] = null, this.Th.deleteTexture(s.texture)) } onSourceUpdate(t) { const s = this.Th, i = this.getGlSource(t); s.bindTexture(s.TEXTURE_2D, i.texture), this.ka[this.Fa] = t; const e = "premultiply-alpha-on-upload" === t.alphaMode; this.Oa !== e && (this.Oa = e, s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e)), this.Ra[t.uploadMethodId] ? this.Ra[t.uploadMethodId].upload(t, i, s, this.Gi.context.webGLVersion) : s.texImage2D(s.TEXTURE_2D, 0, s.RGBA, t.pixelWidth, t.pixelHeight, 0, s.RGBA, s.UNSIGNED_BYTE, null), t.autoGenerateMipmaps && t.mipLevelCount > 1 && this.onUpdateMipmaps(t, !1) } onUpdateMipmaps(t, s = !0) { s && this.bindSource(t, 0); const i = this.getGlSource(t); this.Th.generateMipmap(i.target) } onSourceDestroy(t) { t.off("destroy", this.onSourceDestroy, this), t.off("update", this.onSourceUpdate, this), t.off("resize", this.onSourceUpdate, this), t.off("unload", this.onSourceUnload, this), t.off("styleChange", this.onStyleChange, this), t.off("updateMipmaps", this.onUpdateMipmaps, this), this.managedTextures.splice(this.managedTextures.indexOf(t), 1), this.onSourceUnload(t) } La(t) { const s = this.Th, i = this.Th.createSampler(); return this.Pa[t.U] = i, nu(t, s, this.ka[this.Fa].mipLevelCount > 1, this.Gi.context.extensions.anisotropicFiltering, "samplerParameteri", i, !1, !0), this.Pa[t.U] } Da(t) { return this.Pa[t.U] || this.La(t) } getGlSource(t) { return this.Sa[t.uid] || this.ja(t) } generateCanvas(t) { const { pixels: s, width: i, height: e } = this.getPixels(t), n = ks.get().createCanvas(); n.width = i, n.height = e; const r = n.getContext("2d"); if (r) { const t = r.createImageData(i, e); t.data.set(s), r.putImageData(t, 0, 0) } return n } getPixels(t) { const s = t.source.resolution, i = t.frame, e = Math.max(Math.round(i.width * s), 1), n = Math.max(Math.round(i.height * s), 1), r = new Uint8Array(4 * e * n), o = this.Gi, h = o.renderTarget.getRenderTarget(t), a = o.renderTarget.getGpuRenderTarget(h), u = o.gl; return u.bindFramebuffer(u.FRAMEBUFFER, a.resolveTargetFramebuffer), u.readPixels(Math.round(i.x * s), Math.round(i.y * s), e, n, u.RGBA, u.UNSIGNED_BYTE, r), { pixels: new Uint8ClampedArray(r.buffer), width: e, height: n } } destroy() { this.managedTextures.slice().forEach(t => this.onSourceDestroy(t)), this.managedTextures = null, this.Sa = null, this.Pa = null, this.ka = null, this.Ea = null, this.Ia = null, this.Ba = null, this.Ga = null, this.Ra = null, this.Gi = null } resetState() { this.Fa = -1, this.ka.fill(Z.EMPTY.source), this.Ea = Object.create(null); const t = this.Th; this.Oa = !1, t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.Oa) } } ru.extension = { type: [r.WebGLSystem], name: "texture" }; class ou { contextChange(t) { const s = new Yi({ uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" }, uTransformMatrix: { value: new w, type: "mat3x3<f32>" }, uRound: { value: 0, type: "f32" } }), i = t.limits.maxBatchableTextures, e = cr({ name: "graphics", bits: [dr, yr(i), Bh, Mr] }); this.shader = new Qi({ glProgram: e, resources: { localUniforms: s, batchSamplers: Ar(i) } }) } execute(t, s) { const i = s.context, e = i.customShader || this.shader, n = t.renderer, r = n.graphicsContext, { batcher: o, instructions: h } = r.getContextRenderData(i); e.groups[0] = n.globalUniforms.bindGroup, n.state.set(t.state), n.shader.bind(e), n.geometry.bind(o.geometry, e.glProgram); const a = h.instructions; for (let u = 0; u < h.instructionSize; u++) { const t = a[u]; if (t.size) { for (let s = 0; s < t.textures.count; s++)n.texture.bind(t.textures.textures[s], s); n.geometry.draw(t.topology, t.size, t.start) } } } destroy() { this.shader.destroy(!0), this.shader = null } } ou.extension = { type: [r.WebGLPipesAdaptor], name: "graphics" }; class hu { init() { const t = cr({ name: "mesh", bits: [Bh, $h, Mr] }); this.Jo = new Qi({ glProgram: t, resources: { uTexture: Z.EMPTY.source, textureUniforms: { uTextureMatrix: { type: "mat3x3<f32>", value: new w } } } }) } execute(t, s) { const i = t.renderer; let e = s.Jo; if (e) { if (!e.glProgram) return void Et(s.shader) } else { e = this.Jo; const t = s.texture, i = t.source; e.resources.uTexture = i, e.resources.uSampler = i.style, e.resources.textureUniforms.uniforms.uTextureMatrix = t.textureMatrix.mapCoord } e.groups[100] = i.globalUniforms.bindGroup, e.groups[101] = t.localUniformsBindGroup, i.encoder.draw({ geometry: s.th, shader: e, state: s.state }) } destroy() { this.Jo.destroy(!0), this.Jo = null } } hu.extension = { type: [r.WebGLPipesAdaptor], name: "mesh" }; class au { constructor(t) { this.Gi = t } updateRenderable() { } destroyRenderable() { } validateRenderable() { return !1 } addRenderable(t, s) { this.Gi.renderPipes.batch.break(s), s.add(t) } execute(t) { t.isRenderable && t.render(this.Gi) } destroy() { this.Gi = null } } au.extension = { type: [r.WebGLPipes, r.WebGPUPipes, r.CanvasPipes], name: "customRender" }; class uu { constructor() { this.batcherName = "default", this.topology = "triangle-list", this.attributeSize = 4, this.indexSize = 6, this.packAsQuad = !0, this.roundPixels = 0, this.Un = 0, this.In = null, this.Bn = null } get blendMode() { return this.renderable.groupBlendMode } get color() { return this.renderable.groupColorAlpha } reset() { this.renderable = null, this.texture = null, this.In = null, this.Bn = null, this.bounds = null } destroy() { } } function lu(t, s) { const i = t.instructionSet, e = i.instructions; for (let n = 0; n < i.instructionSize; n++) { const t = e[n]; s[t.renderPipeId].execute(t) } } const cu = new w; class fu { constructor(t) { this.Gi = t } addRenderGroup(t, s) { t.isCachedAsTexture ? this.Va(t, s) : this.Na(t, s) } execute(t) { t.isRenderable && (t.isCachedAsTexture ? this.Wa(t) : this.Ha(t)) } destroy() { this.Gi = null } Na(t, s) { this.Gi.renderPipes.batch.break(s), t.qa && (Ut.return(t.qa), t.qa = null), s.add(t) } Va(t, s) { const i = t.qa ?? (t.qa = Ut.get(uu)); i.renderable = t.root, i.transform = t.root.relativeGroupTransform, i.texture = t.texture, i.bounds = t.Xt, s.add(t), this.Gi.renderPipes.blendMode.pushBlendMode(t, t.root.groupBlendMode, s), this.Gi.renderPipes.batch.addToBatch(i, s), this.Gi.renderPipes.blendMode.popBlendMode(s) } Wa(t) { if (t.textureNeedsUpdate) { t.textureNeedsUpdate = !1; const s = cu.identity().translate(-t.Xt.x, -t.Xt.y); this.Gi.renderTarget.push(t.texture, !0, null, t.texture.frame), this.Gi.globalUniforms.push({ worldTransformMatrix: s, worldColor: 4294967295, offset: { x: 0, y: 0 } }), lu(t, this.Gi.renderPipes), this.Gi.renderTarget.finishRenderPass(), this.Gi.renderTarget.pop(), this.Gi.globalUniforms.pop() } t.qa.In.updateElement(t.qa), t.qa.In.geometry.buffers[0].update() } Ha(t) { this.Gi.globalUniforms.push({ worldTransformMatrix: t.inverseParentTextureTransform, worldColor: t.worldColorAlpha }), lu(t, this.Gi.renderPipes), this.Gi.globalUniforms.pop() } } function du(t, s) { s || (s = 0); for (let i = s; i < t.length && t[i]; i++)t[i] = null } fu.extension = { type: [r.WebGLPipes, r.WebGPUPipes, r.CanvasPipes], name: "renderGroup" }; const pu = new bs; function mu(t, s = !1) { !function (t) { const s = t.root; let i; if (t.renderGroupParent) { const e = t.renderGroupParent; t.worldTransform.appendFrom(s.relativeGroupTransform, e.worldTransform), t.worldColor = Qt(s.groupColor, e.worldColor), i = s.groupAlpha * e.worldAlpha } else t.worldTransform.copyFrom(s.localTransform), t.worldColor = s.localColor, i = s.localAlpha; i = i < 0 ? 0 : i > 1 ? 1 : i, t.worldAlpha = i, t.worldColorAlpha = t.worldColor + (255 * i << 24) }(t); const i = t.childrenToUpdate, e = t.updateTick++; for (const n in i) { const s = Number(n), r = i[n], o = r.list, h = r.index; for (let i = 0; i < h; i++) { const n = o[i]; n.parentRenderGroup === t && n.relativeRenderGroupDepth === s && gu(n, e, 0) } du(o, h), r.index = 0 } if (s) for (let n = 0; n < t.renderGroupChildren.length; n++)mu(t.renderGroupChildren[n], s) } function gu(t, s, i) { if (s === t.updateTick) return; t.updateTick = s, t.didChange = !1; const e = t.localTransform; t.updateLocalTransform(); const n = t.parent; if (n && !n.renderGroup ? (i |= t.wt, t.relativeGroupTransform.appendFrom(e, n.relativeGroupTransform), 7 & i && vu(t, n, i)) : (i = t.wt, t.relativeGroupTransform.copyFrom(e), 7 & i && vu(t, pu, i)), !t.renderGroup) { const e = t.children, n = e.length; for (let t = 0; t < n; t++)gu(e[t], s, i); const r = t.parentRenderGroup, o = t; o.renderPipeId && !r.structureDidChange && r.updateRenderable(o) } } function vu(t, s, i) { if (1 & i) { t.groupColor = Qt(t.localColor, s.groupColor); let i = t.localAlpha * s.groupAlpha; i = i < 0 ? 0 : i > 1 ? 1 : i, t.groupAlpha = i, t.groupColorAlpha = t.groupColor + (255 * i << 24) } 2 & i && (t.groupBlendMode = "inherit" === t.localBlendMode ? s.groupBlendMode : t.localBlendMode), 4 & i && (t.globalDisplayStatus = t.localDisplayStatus & s.globalDisplayStatus), t.wt = 0 } const bu = new w; class xu { constructor(t) { this.Gi = t } render({ container: t, transform: s }) { const i = t.parent, e = t.renderGroup.renderGroupParent; t.parent = null, t.renderGroup.renderGroupParent = null; const n = this.Gi, r = bu; s && (r.copyFrom(t.renderGroup.localTransform), t.renderGroup.localTransform.copyFrom(s)); const o = n.renderPipes; this.Xa(t.renderGroup, null), this.Ya(t.renderGroup), n.globalUniforms.start({ worldTransformMatrix: s ? t.renderGroup.localTransform : t.renderGroup.worldTransform, worldColor: t.renderGroup.worldColorAlpha }), lu(t.renderGroup, o), o.uniformBatch && o.uniformBatch.renderEnd(), s && t.renderGroup.localTransform.copyFrom(r), t.parent = i, t.renderGroup.renderGroupParent = e } destroy() { this.Gi = null } Xa(t, s) { if (t.Vt = s, t.isCachedAsTexture) { if (!t.textureNeedsUpdate) return; s = t } for (let i = t.renderGroupChildren.length - 1; i >= 0; i--)this.Xa(t.renderGroupChildren[i], s); if (t.invalidateMatrices(), t.isCachedAsTexture) { if (t.textureNeedsUpdate) { const s = t.root.getLocalBounds(); s.ceil(); const i = t.texture; t.texture && fs.returnTexture(t.texture, !0); const e = this.Gi, n = t.textureOptions.resolution || e.view.resolution, r = t.textureOptions.antialias ?? e.view.antialias, o = t.textureOptions.scaleMode ?? "linear", h = fs.getOptimalTexture(s.width, s.height, n, r); h.K.style = new W({ scaleMode: o }), t.texture = h, t.Xt || (t.Xt = new tt), t.Xt.copyFrom(s), i !== t.texture && t.renderGroupParent && (t.renderGroupParent.structureDidChange = !0) } } else t.texture && (fs.returnTexture(t.texture, !0), t.texture = null) } Ya(t) { const s = this.Gi, i = s.renderPipes; if (t.runOnRender(s), t.instructionSet.renderPipes = i, t.structureDidChange ? du(t.childrenRenderablesToUpdate.list, 0) : function (t, s) { const { list: i } = t.childrenRenderablesToUpdate; let e = !1; for (let n = 0; n < t.childrenRenderablesToUpdate.index; n++) { const t = i[n]; if (e = s[t.renderPipeId].validateRenderable(t), e) break } t.structureDidChange = e }(t, i), mu(t), t.structureDidChange ? (t.structureDidChange = !1, this.Ka(t, s)) : this.Za(t), t.childrenRenderablesToUpdate.index = 0, s.renderPipes.batch.upload(t.instructionSet), !t.isCachedAsTexture || t.textureNeedsUpdate) for (let e = 0; e < t.renderGroupChildren.length; e++)this.Ya(t.renderGroupChildren[e]) } Za(t) { const { list: s, index: i } = t.childrenRenderablesToUpdate; for (let e = 0; e < i; e++) { const i = s[e]; i.didViewUpdate && t.updateRenderable(i) } du(s, i) } Ka(t, s) { const i = t.root, e = t.instructionSet; e.reset(); const n = s.renderPipes ? s : s.batch.renderer, r = n.renderPipes; r.batch.buildStart(e), r.blendMode.buildStart(), r.colorMask.buildStart(), i.sortableChildren && i.sortChildren(), i.collectRenderablesWithEffects(e, n, null), r.batch.buildEnd(e), r.blendMode.buildEnd(e) } } xu.extension = { type: [r.WebGLSystem, r.WebGPUSystem, r.CanvasSystem], name: "renderGroup" }; class yu { constructor(t) { this.Gi = t } addRenderable(t, s) { const i = this.Qa(t); t.didViewUpdate && this.Ja(t, i), this.Gi.renderPipes.batch.addToBatch(i, s) } updateRenderable(t) { const s = this.Qa(t); t.didViewUpdate && this.Ja(t, s), s.In.updateElement(s) } validateRenderable(t) { const s = this.Qa(t); return !s.In.checkAndUpdateTexture(s, t.Y) } Ja(t, s) { s.bounds = t.visualBounds, s.texture = t.Y } Qa(t) { return t.ps[this.Gi.uid] || this.tu(t) } tu(t) { const s = new uu; return s.renderable = t, s.transform = t.groupTransform, s.texture = t.Y, s.bounds = t.visualBounds, s.roundPixels = this.Gi.fs | t.fs, t.ps[this.Gi.uid] = s, s } destroy() { this.Gi = null } } yu.extension = { type: [r.WebGLPipes, r.WebGPUPipes, r.CanvasPipes], name: "sprite" }; const wu = class t { constructor() { this.clearBeforeRender = !0, this.su = new kt(0), this.color = this.su, this.alpha = 1 } init(s) { s = { ...t.defaultOptions, ...s }, this.clearBeforeRender = s.clearBeforeRender, this.color = s.background || s.backgroundColor || this.su, this.alpha = s.backgroundAlpha, this.su.setAlpha(s.backgroundAlpha) } get color() { return this.su } set color(t) { kt.shared.setValue(t).alpha < 1 && 1 === this.su.alpha && Et(), this.su.setValue(t) } get alpha() { return this.su.alpha } set alpha(t) { this.su.setAlpha(t) } get colorRgba() { return this.su.toArray() } destroy() { } }; wu.extension = { type: [r.WebGLSystem, r.WebGPUSystem, r.CanvasSystem], name: "background", priority: 0 }, wu.defaultOptions = { backgroundAlpha: 1, backgroundColor: 0, clearBeforeRender: !0 }; let Mu = wu; const Tu = {}; a.handle(r.BlendMode, t => { if (!t.name) throw new Error("BlendMode extension must have a name property"); Tu[t.name] = t.ref }, t => { delete Tu[t.name] }); class Au { constructor(t) { this.iu = [], this.eu = !1, this.nu = Object.create(null), this.Gi = t, this.Gi.runners.prerender.add(this) } prerender() { this.ru = "normal", this.eu = !1 } pushBlendMode(t, s, i) { this.iu.push(s), this.setBlendMode(t, s, i) } popBlendMode(t) { this.iu.pop(); const s = this.iu[this.ru.length - 1] ?? "normal"; this.setBlendMode(null, s, t) } setBlendMode(t, s, i) { const e = t instanceof ds; this.ru !== s ? (this.eu && this.ou(i), this.ru = s, t && (this.eu = !!Tu[s], this.eu && this.hu(t, i))) : this.eu && t && !e && this.au?.push(t) } hu(t, s) { this.Gi.renderPipes.batch.break(s); const i = this.ru; if (!Tu[i]) return void Et(); const e = this.uu(i), n = t instanceof ds, r = { renderPipeId: "filter", action: "pushFilter", filterEffect: e, renderables: n ? null : [t], container: n ? t.root : null, canBundle: !1 }; this.au = r.renderables, s.add(r) } uu(t) { let s = this.nu[t]; return s || (s = this.nu[t] = new zt, s.filters = [new Tu[t]]), s } ou(t) { this.eu = !1, this.au = null, this.Gi.renderPipes.batch.break(t), t.add({ renderPipeId: "filter", action: "popFilter", canBundle: !1 }) } buildStart() { this.eu = !1 } buildEnd(t) { this.eu && this.ou(t) } destroy() { this.Gi = null, this.au = null; for (const t in this.nu) this.nu[t].destroy(); this.nu = null } } Au.extension = { type: [r.WebGLPipes, r.WebGPUPipes, r.CanvasPipes], name: "blendMode" }; const Cu = { png: "image/png", jpg: "image/jpeg", webp: "image/webp" }, _u = class t { constructor(t) { this.Gi = t } lu(t, s = {}) { return t instanceof bs || t instanceof Z ? { target: t, ...s } : { ...s, ...t } } async image(t) { const s = ks.get().createImage(); return s.src = await this.base64(t), s } async base64(s) { s = this.lu(s, t.defaultImageOptions); const { format: i, quality: e } = s, n = this.canvas(s); if (void 0 !== n.toBlob) return new Promise((t, s) => { n.toBlob(i => { if (!i) return void s(new Error("ICanvas.toBlob failed!")); const e = new FileReader; e.onload = () => t(e.result), e.onerror = s, e.readAsDataURL(i) }, Cu[i], e) }); if (void 0 !== n.toDataURL) return n.toDataURL(Cu[i], e); if (void 0 !== n.convertToBlob) { const t = await n.convertToBlob({ type: Cu[i], quality: e }); return new Promise((s, i) => { const e = new FileReader; e.onload = () => s(e.result), e.onerror = i, e.readAsDataURL(t) }) } throw new Error("Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented") } canvas(t) { const s = (t = this.lu(t)).target, i = this.Gi; if (s instanceof Z) return i.texture.generateCanvas(s); const e = i.textureGenerator.generateTexture(t), n = i.texture.generateCanvas(e); return e.destroy(!0), n } pixels(t) { const s = (t = this.lu(t)).target, i = this.Gi, e = s instanceof Z ? s : i.textureGenerator.generateTexture(t), n = i.texture.getPixels(e); return s instanceof bs && e.destroy(!0), n } texture(t) { return (t = this.lu(t)).target instanceof Z ? t.target : this.Gi.textureGenerator.generateTexture(t) } download(t) { t = this.lu(t); const s = this.canvas(t), i = document.createElement("a"); i.download = t.filename ?? "image.png", i.href = s.toDataURL("image/png"), document.body.appendChild(i), i.click(), document.body.removeChild(i) } log(t) { const s = t.width ?? 200; t = this.lu(t), ["font-size: 1px;", `padding: ${s}px 300px;`, `background: url(${this.canvas(t).toDataURL()}) no-repeat;`, "background-size: contain;"].join(" ") } destroy() { this.Gi = null } }; _u.extension = { type: [r.WebGLSystem, r.WebGPUSystem], name: "extract" }, _u.defaultImageOptions = { format: "png", quality: 1 }; let Su = _u; class Pu extends Z { static create(t) { return new Pu({ source: new q(t) }) } resize(t, s, i) { return this.source.resize(t, s, i), this } } const ku = new O, Fu = new tt, Eu = [0, 0, 0, 0]; class Ru { constructor(t) { this.Gi = t } generateTexture(t) { t instanceof bs && (t = { target: t, frame: void 0, textureSourceOptions: {}, resolution: void 0 }); const s = t.resolution || this.Gi.resolution, i = t.antialias || this.Gi.view.antialias, e = t.target; let n = t.clearColor; n = n ? Array.isArray(n) && 4 === n.length ? n : kt.shared.setValue(n).toArray() : Eu; const r = t.frame?.copyTo(ku) || ss(e, Fu).rectangle; r.width = 0 | Math.max(r.width, 1 / s), r.height = 0 | Math.max(r.height, 1 / s); const o = Pu.create({ ...t.textureSourceOptions, width: r.width, height: r.height, resolution: s, antialias: i }), h = w.shared.translate(-r.x, -r.y); return this.Gi.render({ container: e, transform: h, target: o, clearColor: n }), o.source.updateMipmaps(), o } destroy() { this.Gi = null } } function Ou(t, s, i) { const e = (t >> 24 & 255) / 255; s[i++] = (255 & t) / 255 * e, s[i++] = (t >> 8 & 255) / 255 * e, s[i++] = (t >> 16 & 255) / 255 * e, s[i++] = e } Ru.extension = { type: [r.WebGLSystem, r.WebGPUSystem], name: "textureGenerator" }; class Uu { constructor(t) { this.cu = 0, this.fu = [], this.du = [], this.pu = [], this.mu = [], this.gu = [], this.Gi = t } reset() { this.cu = 0; for (let t = 0; t < this.pu.length; t++)this.du.push(this.pu[t]); for (let t = 0; t < this.gu.length; t++)this.mu.push(this.gu[t]); this.pu.length = 0, this.gu.length = 0 } start(t) { this.reset(), this.push(t) } bind({ size: t, projectionMatrix: s, worldTransformMatrix: i, worldColor: e, offset: n }) { const r = this.Gi.renderTarget.renderTarget, o = this.cu ? this.fu[this.cu - 1] : { worldTransformMatrix: new w, worldColor: 4294967295, offset: new x }, h = { projectionMatrix: s || this.Gi.renderTarget.projectionMatrix, resolution: t || r.size, worldTransformMatrix: i || o.worldTransformMatrix, worldColor: e || o.worldColor, offset: n || o.offset, bindGroup: null }, a = this.du.pop() || this.vu(); this.pu.push(a); const u = a.uniforms; let l; u.uProjectionMatrix = h.projectionMatrix, u.uResolution = h.resolution, u.uWorldTransformMatrix.copyFrom(h.worldTransformMatrix), u.uWorldTransformMatrix.tx -= h.offset.x, u.uWorldTransformMatrix.ty -= h.offset.y, Ou(h.worldColor, u.uWorldColorAlpha, 0), a.update(), this.Gi.renderPipes.uniformBatch ? l = this.Gi.renderPipes.uniformBatch.getUniformBindGroup(a, !1) : (l = this.mu.pop() || new Ki, this.gu.push(l), l.setResource(a, 0)), h.bindGroup = l, this.bu = h } push(t) { this.bind(t), this.fu[this.cu++] = this.bu } pop() { this.bu = this.fu[--this.cu - 1], this.Gi.type === Zi.WEBGL && this.bu.bindGroup.resources[0].update() } get bindGroup() { return this.bu.bindGroup } get globalUniformData() { return this.bu } get uniformGroup() { return this.bu.bindGroup.resources[0] } vu() { return new Yi({ uProjectionMatrix: { value: new w, type: "mat3x3<f32>" }, uWorldTransformMatrix: { value: new w, type: "mat3x3<f32>" }, uWorldColorAlpha: { value: new Float32Array(4), type: "vec4<f32>" }, uResolution: { value: [0, 0], type: "vec2<f32>" } }, { isStatic: !0 }) } destroy() { this.Gi = null, this.fu.length = 0, this.du.length = 0, this.pu.length = 0, this.mu.length = 0, this.gu.length = 0, this.bu = null } } Uu.extension = { type: [r.WebGLSystem, r.WebGPUSystem, r.CanvasSystem], name: "globalUniforms" }; let Iu = 1; class Bu { constructor() { this.xu = [], this.yu = 0 } init() { Bs.system.add(this.so, this) } repeat(t, s, i = !0) { const e = Iu++; let n = 0; return i && (this.yu += 1e3, n = this.yu), this.xu.push({ func: t, duration: s, start: performance.now(), offset: n, last: performance.now(), repeat: !0, id: e }), e } cancel(t) { for (let s = 0; s < this.xu.length; s++)if (this.xu[s].id === t) return void this.xu.splice(s, 1) } so() { const t = performance.now(); for (let s = 0; s < this.xu.length; s++) { const i = this.xu[s]; if (t - i.offset - i.last >= i.duration) { const s = t - i.start; i.func(s), i.last = t } } } destroy() { Bs.system.remove(this.so, this), this.xu.length = 0 } } Bu.extension = { type: [r.WebGLSystem, r.WebGPUSystem, r.CanvasSystem], name: "scheduler", priority: 0 }; let Gu = !1; class $u { constructor(t) { this.Gi = t } init(t) { if (t.hello) { let t = this.Gi.name; this.Gi.type === Zi.WEBGL && (t += ` ${this.Gi.context.webGLVersion}`), function (t) { if (!Gu) { if (ks.get().getNavigator().userAgent.toLowerCase().indexOf("chrome") > -1) { const s = [`%c  %c  %c  %c  %c PixiJS %c v${Ne} (${t}) http://www.pixijs.com/\n\n`, "background: #E72264; padding:5px 0;", "background: #6CA2EA; padding:5px 0;", "background: #B5D33D; padding:5px 0;", "background: #FED23F; padding:5px 0;", "color: #FFFFFF; background: #E72264; padding:5px 0;", "color: #E72264; background: #FFFFFF; padding:5px 0;"]; globalThis.console.log(...s) } else globalThis.console && globalThis.console.log(`PixiJS ${Ne} - ${t} - http://www.pixijs.com/`); Gu = !0 } }(t) } } } function zu(t) { let s = !1; for (const e in t) if (null == t[e]) { s = !0; break } if (!s) return t; const i = Object.create(null); for (const e in t) { const s = t[e]; s && (i[e] = s) } return i } function Du(t) { let s = 0; for (let i = 0; i < t.length; i++)null == t[i] ? s++ : t[i - s] = t[i]; return t.length -= s, t } $u.extension = { type: [r.WebGLSystem, r.WebGPUSystem, r.CanvasSystem], name: "hello", priority: -2 }, $u.defaultOptions = { hello: !1 }; let ju = 0; const Lu = class t { constructor(t) { this.wu = [], this.Mu = [], this.Tu = [], this.Gi = t } init(s) { s = { ...t.defaultOptions, ...s }, this.maxUnusedTime = s.renderableGCMaxUnusedTime, this.Au = s.renderableGCFrequency, this.enabled = s.renderableGCActive } get enabled() { return !!this.Cu } set enabled(t) { this.enabled !== t && (t ? (this.Cu = this.Gi.scheduler.repeat(() => this.run(), this.Au, !1), this._u = this.Gi.scheduler.repeat(() => { for (const t of this.Mu) t.context[t.hash] = zu(t.context[t.hash]) }, this.Au), this.Su = this.Gi.scheduler.repeat(() => { for (const t of this.Tu) Du(t.context[t.hash]) }, this.Au)) : (this.Gi.scheduler.cancel(this.Cu), this.Gi.scheduler.cancel(this._u), this.Gi.scheduler.cancel(this.Su))) } addManagedHash(t, s) { this.Mu.push({ context: t, hash: s }) } addManagedArray(t, s) { this.Tu.push({ context: t, hash: s }) } prerender({ container: t }) { this.Pu = performance.now(), t.renderGroup.gcTick = ju++, this.ku(t.renderGroup, t.renderGroup.gcTick) } addRenderable(t) { this.enabled && (-1 === t.ds && (this.wu.push(t), t.once("destroyed", this.Fu, this)), t.ds = this.Pu) } run() { const t = this.Pu, s = this.wu, i = this.Gi.renderPipes; let e = 0; for (let n = 0; n < s.length; n++) { const r = s[n]; if (null === r) { e++; continue } const o = r.renderGroup ?? r.parentRenderGroup, h = o?.instructionSet?.gcTick ?? -1; if ((o?.gcTick ?? 0) === h && (r.ds = t), t - r.ds > this.maxUnusedTime) { if (!r.destroyed) { const t = i; o && (o.structureDidChange = !0), t[r.renderPipeId].destroyRenderable(r) } r.ds = -1, e++, r.off("destroyed", this.Fu, this) } else s[n - e] = r } s.length -= e } destroy() { this.enabled = !1, this.Gi = null, this.wu.length = 0, this.Mu.length = 0, this.Tu.length = 0 } Fu(t) { const s = this.wu.indexOf(t); s >= 0 && (t.off("destroyed", this.Fu, this), this.wu[s] = null) } ku(t, s) { t.instructionSet.gcTick = s; for (const i of t.renderGroupChildren) this.ku(i, s) } }; Lu.extension = { type: [r.WebGLSystem, r.WebGPUSystem], name: "renderableGC", priority: 0 }, Lu.defaultOptions = { renderableGCActive: !0, renderableGCMaxUnusedTime: 6e4, renderableGCFrequency: 3e4 }; let Vu = Lu; const Nu = class t { constructor(t) { this.Gi = t, this.count = 0, this.checkCount = 0 } init(s) { s = { ...t.defaultOptions, ...s }, this.checkCountMax = s.textureGCCheckCountMax, this.maxIdle = s.textureGCAMaxIdle ?? s.textureGCMaxIdle, this.active = s.textureGCActive } postrender() { this.Gi.renderingToScreen && (this.count++, this.active && (this.checkCount++, this.checkCount > this.checkCountMax && (this.checkCount = 0, this.run()))) } run() { const t = this.Gi.texture.managedTextures; for (let s = 0; s < t.length; s++) { const i = t[s]; i.autoGarbageCollect && i.resource && i.R > -1 && this.count - i.R > this.maxIdle && (i.R = -1, i.unload()) } } destroy() { this.Gi = null } }; Nu.extension = { type: [r.WebGLSystem, r.WebGPUSystem], name: "textureGC" }, Nu.defaultOptions = { textureGCActive: !0, textureGCAMaxIdle: null, textureGCMaxIdle: 3600, textureGCCheckCountMax: 600 }; let Wu = Nu; const Hu = class t { get autoDensity() { return this.texture.source.autoDensity } set autoDensity(t) { this.texture.source.autoDensity = t } get resolution() { return this.texture.source.G } set resolution(t) { this.texture.source.resize(this.texture.source.width, this.texture.source.height, t) } init(s) { (s = { ...t.defaultOptions, ...s }).view && ($(0, "ViewSystem.view has been renamed to ViewSystem.canvas"), s.canvas = s.view), this.screen = new O(0, 0, s.width, s.height), this.canvas = s.canvas || ks.get().createCanvas(), this.antialias = !!s.antialias, this.texture = Ca(this.canvas, s), this.renderTarget = new Sa({ colorTextures: [this.texture], depth: !!s.depth, isRoot: !0 }), this.texture.source.transparent = s.backgroundAlpha < 1, this.resolution = s.resolution } resize(t, s, i) { this.texture.source.resize(t, s, i), this.screen.width = this.texture.frame.width, this.screen.height = this.texture.frame.height } destroy(t = !1) { ("boolean" == typeof t ? t : !!t?.removeView) && this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas), this.texture.destroy() } }; Hu.extension = { type: [r.WebGLSystem, r.WebGPUSystem, r.CanvasSystem], name: "view", priority: 0 }, Hu.defaultOptions = { width: 800, height: 600, autoDensity: !1, antialias: !1 }; const qu = [Mu, Uu, $u, Hu, xu, Wu, Ru, Su, He, Vu, Bu], Xu = [Au, Oh, yu, fu, jh, Vh, Lh, au], Yu = [...qu, Ma, ra, Xh, aa, Hh, ru, ka, ia, Wa, La, ha, qa, ca, oa], Ku = [...Xu], Zu = [kh, hu, ou], Qu = [], Ju = [], tl = []; a.handleByNamedList(r.WebGLSystem, Qu), a.handleByNamedList(r.WebGLPipes, Ju), a.handleByNamedList(r.WebGLPipesAdaptor, tl), a.add(...Yu, ...Ku, ...Zu); const sl = Object.freeze(Object.defineProperty({ __proto__: null, WebGLRenderer: class extends De { constructor() { super({ name: "webgl", type: Zi.WEBGL, systems: Qu, renderPipes: Ju, renderPipeAdaptors: tl }) } } }, Symbol.toStringTag, { value: "Module" })); class il { constructor(t) { this.Eu = Object.create(null), this.Gi = t, this.Gi.renderableGC.addManagedHash(this, "_hash") } contextChange(t) { this.Ru = t } getBindGroup(t, s, i) { return t.Oe(), this.Eu[t.Me] || this.Ou(t, s, i) } Ou(t, s, i) { const e = this.Ru.device, n = s.layout[i], r = [], o = this.Gi; for (const u in n) { const s = t.resources[u] ?? t.resources[n[u]]; let i; if ("uniformGroup" === s.F) { const t = s; o.ubo.updateUniformGroup(t); const e = t.buffer; i = { buffer: o.buffer.getGPUBuffer(e), offset: 0, size: e.descriptor.size } } else if ("buffer" === s.F) { const t = s; i = { buffer: o.buffer.getGPUBuffer(t), offset: 0, size: t.descriptor.size } } else if ("bufferResource" === s.F) { const t = s; i = { buffer: o.buffer.getGPUBuffer(t.buffer), offset: t.offset, size: t.size } } else if ("textureSampler" === s.F) { const t = s; i = o.texture.getGpuSampler(t) } else if ("textureSource" === s.F) { const t = s; i = o.texture.getGpuSource(t).createView({}) } r.push({ binding: n[u], resource: i }) } const h = o.shader.getProgramData(s).bindGroups[i], a = e.createBindGroup({ layout: h, entries: r }); return this.Eu[t.Me] = a, a } destroy() { for (const t of Object.keys(this.Eu)) this.Eu[t] = null; this.Eu = null, this.Gi = null } } il.extension = { type: [r.WebGPUSystem], name: "bindGroup" }; class el { constructor(t) { this.bh = Object.create(null), t.renderableGC.addManagedHash(this, "_gpuBuffers") } contextChange(t) { this.Ru = t } getGPUBuffer(t) { return this.bh[t.uid] || this.createGPUBuffer(t) } updateBuffer(t) { const s = this.bh[t.uid] || this.createGPUBuffer(t), i = t.data; return t.X && i && (t.X = 0, this.Ru.device.queue.writeBuffer(s, 0, i.buffer, 0, (t.Vn || i.byteLength) + 3 & -4)), s } destroyAll() { for (const t in this.bh) this.bh[t]?.destroy(); this.bh = {} } createGPUBuffer(t) { this.bh[t.uid] || (t.on("update", this.updateBuffer, this), t.on("change", this.onBufferChange, this), t.on("destroy", this.onBufferDestroy, this)); const s = this.Ru.device.createBuffer(t.descriptor); return t.X = 0, t.data && (Cn(t.data.buffer, s.getMappedRange()), s.unmap()), this.bh[t.uid] = s, s } onBufferChange(t) { this.bh[t.uid].destroy(), t.X = 0, this.bh[t.uid] = this.createGPUBuffer(t) } onBufferDestroy(t) { this.Uu(t) } destroy() { this.destroyAll(), this.bh = {} } Uu(t) { t.off("update", this.updateBuffer, this), t.off("change", this.onBufferChange, this), t.off("destroy", this.onBufferDestroy, this), this.bh[t.uid] && (this.bh[t.uid].destroy(), this.bh[t.uid] = null) } } el.extension = { type: [r.WebGPUSystem], name: "buffer" }; class nl { constructor({ minUniformOffsetAlignment: t }) { this.Iu = 256, this.byteIndex = 0, this.Iu = t, this.data = new Float32Array(65535) } clear() { this.byteIndex = 0 } addEmptyGroup(t) { if (t > this.Iu / 4) throw new Error("UniformBufferBatch: array is too large: " + 4 * t); const s = this.byteIndex; let i = s + 4 * t; if (i = Math.ceil(i / this.Iu) * this.Iu, i > 4 * this.data.length) throw new Error("UniformBufferBatch: ubo batch got too big"); return this.byteIndex = i, s } addGroup(t) { const s = this.addEmptyGroup(t.length); for (let i = 0; i < t.length; i++)this.data[s / 4 + i] = t[i]; return s } destroy() { this.data = null } } class rl { constructor(t) { this.Gh = 15, this.Gi = t } setMask(t) { this.Gh !== t && (this.Gh = t, this.Gi.pipeline.setColorMask(t)) } destroy() { this.Gi = null, this.Gh = null } } rl.extension = { type: [r.WebGPUSystem], name: "colorMask" }; class ol { constructor(t) { this.Gi = t } async init(t) { return this.Bu || (this.Bu = (t.gpu ? Promise.resolve(t.gpu) : this.Gu(t)).then(t => { this.gpu = t, this.Gi.runners.contextChange.emit(this.gpu) })), this.Bu } contextChange(t) { this.Gi.gpu = t } async Gu(t) { const s = await ks.get().getNavigator().gpu.requestAdapter({ powerPreference: t.powerPreference, forceFallbackAdapter: t.forceFallbackAdapter }), i = ["texture-compression-bc", "texture-compression-astc", "texture-compression-etc2"].filter(t => s.features.has(t)), e = await s.requestDevice({ requiredFeatures: i }); return { adapter: s, device: e } } destroy() { this.gpu = null, this.Gi = null } } ol.extension = { type: [r.WebGPUSystem], name: "device" }, ol.defaultOptions = { powerPreference: void 0, forceFallbackAdapter: !1 }; class hl { constructor(t) { this.$u = Object.create(null), this.zu = Object.create(null), this.Gi = t } renderStart() { this.commandFinished = new Promise(t => { this.Du = t }), this.commandEncoder = this.Gi.gpu.device.createCommandEncoder() } beginRenderPass(t) { this.endRenderPass(), this.ju(), this.renderPassEncoder = this.commandEncoder.beginRenderPass(t.descriptor) } endRenderPass() { this.renderPassEncoder && this.renderPassEncoder.end(), this.renderPassEncoder = null } setViewport(t) { this.renderPassEncoder.setViewport(t.x, t.y, t.width, t.height, 0, 1) } setPipelineFromGeometryProgramAndState(t, s, i, e) { const n = this.Gi.pipeline.getPipeline(t, s, i, e); this.setPipeline(n) } setPipeline(t) { this.Lu !== t && (this.Lu = t, this.renderPassEncoder.setPipeline(t)) } Vu(t, s) { this.zu[t] !== s && (this.zu[t] = s, this.renderPassEncoder.setVertexBuffer(t, this.Gi.buffer.updateBuffer(s))) } Nu(t) { if (this.Wu === t) return; this.Wu = t; const s = 2 === t.data.BYTES_PER_ELEMENT ? "uint16" : "uint32"; this.renderPassEncoder.setIndexBuffer(this.Gi.buffer.updateBuffer(t), s) } resetBindGroup(t) { this.$u[t] = null } setBindGroup(t, s, i) { if (this.$u[t] === s) return; this.$u[t] = s, s.Ue(this.Gi.textureGC.count); const e = this.Gi.bindGroup.getBindGroup(s, i, t); this.renderPassEncoder.setBindGroup(t, e) } setGeometry(t, s) { const i = this.Gi.pipeline.getBufferNamesToBind(t, s); for (const e in i) this.Vu(parseInt(e, 10), t.attributes[i[e]].buffer); t.indexBuffer && this.Nu(t.indexBuffer) } Hu(t, s) { for (const i in t.groups) { const e = t.groups[i]; s || this.qu(e), this.setBindGroup(i, e, t.gpuProgram) } } qu(t) { for (const s in t.resources) { const i = t.resources[s]; i.isUniformGroup && this.Gi.ubo.updateUniformGroup(i) } } draw(t) { const { geometry: s, shader: i, state: e, topology: n, size: r, start: o, instanceCount: h, skipSync: a } = t; this.setPipelineFromGeometryProgramAndState(s, i.gpuProgram, e, n), this.setGeometry(s, i.gpuProgram), this.Hu(i, a), s.indexBuffer ? this.renderPassEncoder.drawIndexed(r || s.indexBuffer.data.length, h ?? s.instanceCount, o || 0) : this.renderPassEncoder.draw(r || s.getSize(), h ?? s.instanceCount, o || 0) } finishRenderPass() { this.renderPassEncoder && (this.renderPassEncoder.end(), this.renderPassEncoder = null) } postrender() { this.finishRenderPass(), this.Ru.device.queue.submit([this.commandEncoder.finish()]), this.Du(), this.commandEncoder = null } restoreRenderPass() { const t = this.Gi.renderTarget.adaptor.getDescriptor(this.Gi.renderTarget.renderTarget, !1, [0, 0, 0, 1]); this.renderPassEncoder = this.commandEncoder.beginRenderPass(t); const s = this.Lu, i = { ...this.zu }, e = this.Wu, n = { ...this.$u }; this.ju(); const r = this.Gi.renderTarget.viewport; this.renderPassEncoder.setViewport(r.x, r.y, r.width, r.height, 0, 1), this.setPipeline(s); for (const o in i) this.Vu(o, i[o]); for (const o in n) this.setBindGroup(o, n[o], null); this.Nu(e) } ju() { for (let t = 0; t < 16; t++)this.$u[t] = null, this.zu[t] = null; this.Wu = null, this.Lu = null } destroy() { this.Gi = null, this.Ru = null, this.$u = null, this.zu = null, this.Wu = null, this.Lu = null } contextChange(t) { this.Ru = t } } hl.extension = { type: [r.WebGPUSystem], name: "encoder", priority: 1 }; class al { constructor(t) { this.Gi = t } contextChange() { this.maxTextures = this.Gi.device.gpu.device.limits.maxSampledTexturesPerShaderStage, this.maxBatchableTextures = this.maxTextures } destroy() { } } al.extension = { type: [r.WebGPUSystem], name: "limits" }; class ul { constructor(t) { this.Dh = Object.create(null), this.Gi = t, t.renderTarget.onRenderTargetChange.add(this) } onRenderTargetChange(t) { let s = this.Dh[t.uid]; s || (s = this.Dh[t.uid] = { stencilMode: Sn.DISABLED, stencilReference: 0 }), this.Vh = t, this.setStencilMode(s.stencilMode, s.stencilReference) } setStencilMode(t, s) { const i = this.Dh[this.Vh.uid]; i.stencilMode = t, i.stencilReference = s; const e = this.Gi; e.pipeline.setStencilMode(t), e.encoder.renderPassEncoder.setStencilReference(s) } destroy() { this.Gi.renderTarget.onRenderTargetChange.remove(this), this.Gi = null, this.Vh = null, this.Dh = null } } ul.extension = { type: [r.WebGPUSystem], name: "stencil" }; const ll = { i32: { align: 4, size: 4 }, u32: { align: 4, size: 4 }, f32: { align: 4, size: 4 }, f16: { align: 2, size: 2 }, "vec2<i32>": { align: 8, size: 8 }, "vec2<u32>": { align: 8, size: 8 }, "vec2<f32>": { align: 8, size: 8 }, "vec2<f16>": { align: 4, size: 4 }, "vec3<i32>": { align: 16, size: 12 }, "vec3<u32>": { align: 16, size: 12 }, "vec3<f32>": { align: 16, size: 12 }, "vec3<f16>": { align: 8, size: 6 }, "vec4<i32>": { align: 16, size: 16 }, "vec4<u32>": { align: 16, size: 16 }, "vec4<f32>": { align: 16, size: 16 }, "vec4<f16>": { align: 8, size: 8 }, "mat2x2<f32>": { align: 8, size: 16 }, "mat2x2<f16>": { align: 4, size: 8 }, "mat3x2<f32>": { align: 8, size: 24 }, "mat3x2<f16>": { align: 4, size: 12 }, "mat4x2<f32>": { align: 8, size: 32 }, "mat4x2<f16>": { align: 4, size: 16 }, "mat2x3<f32>": { align: 16, size: 32 }, "mat2x3<f16>": { align: 8, size: 16 }, "mat3x3<f32>": { align: 16, size: 48 }, "mat3x3<f16>": { align: 8, size: 24 }, "mat4x3<f32>": { align: 16, size: 64 }, "mat4x3<f16>": { align: 8, size: 32 }, "mat2x4<f32>": { align: 16, size: 32 }, "mat2x4<f16>": { align: 8, size: 16 }, "mat3x4<f32>": { align: 16, size: 48 }, "mat3x4<f16>": { align: 8, size: 24 }, "mat4x4<f32>": { align: 16, size: 64 }, "mat4x4<f16>": { align: 8, size: 32 } }; function cl(t) { const s = t.map(t => ({ data: t, offset: 0, size: 0 })); let i = 0; for (let e = 0; e < s.length; e++) { const t = s[e]; let n = ll[t.data.type].size; const r = ll[t.data.type].align; if (!ll[t.data.type]) throw new Error(`[Pixi.js] WebGPU UniformBuffer: Unknown type ${t.data.type}`); t.data.size > 1 && (n = Math.max(n, r) * t.data.size), i = Math.ceil(i / r) * r, t.size = n, t.offset = i, i += n } return i = 16 * Math.ceil(i / 16), { uboElements: s, size: i } } function fl(t, s) { const { size: i, align: e } = ll[t.data.type], n = (e - i) / 4, r = t.data.type.indexOf("i32") >= 0 ? "dataInt32" : "data"; return `\n         v = uv.${t.data.name};\n         ${0 !== s ? `offset += ${s};` : ""}\n\n         arrayOffset = offset;\n\n         t = 0;\n\n         for(var i=0; i < ${t.data.size * (i / 4)}; i++)\n         {\n             for(var j = 0; j < ${i / 4}; j++)\n             {\n                 ${r}[arrayOffset++] = v[t++];\n             }\n             ${0 !== n ? `arrayOffset += ${n};` : ""}\n         }\n     ` } function dl(t) { return ga(t, "uboWgsl", fl, xa) } class pl extends fa { constructor() { super({ createUboElements: cl, generateUboSync: dl }) } } pl.extension = { type: [r.WebGPUSystem], name: "ubo" }; const ml = 128; class gl { constructor(t) { this.Xu = Object.create(null), this.Yu = [], this.Ku = [], this.Zu = [], this.Gi = t, this.Gi.renderableGC.addManagedHash(this, "_bindGroupHash"), this.Qu = new nl({ minUniformOffsetAlignment: ml }); for (let s = 0; s < 2; s++) { let t = Ln.UNIFORM | Ln.COPY_DST; 0 === s && (t |= Ln.COPY_SRC), this.Yu.push(new Vn({ data: this.Qu.data, usage: t })) } } renderEnd() { this.Ju(), this.tl() } tl() { for (const t in this.Xu) this.Xu[t] = null; this.Qu.clear() } getUniformBindGroup(t, s) { if (!s && this.Xu[t.uid]) return this.Xu[t.uid]; this.Gi.ubo.ensureUniformGroup(t); const i = t.buffer.data, e = this.Qu.addEmptyGroup(i.length); return this.Gi.ubo.syncUniformGroup(t, this.Qu.data, e / 4), this.Xu[t.uid] = this.sl(e / ml), this.Xu[t.uid] } getUboResource(t) { this.Gi.ubo.updateUniformGroup(t); const s = t.buffer.data, i = this.Qu.addGroup(s); return this.il(i / ml) } getArrayBindGroup(t) { const s = this.Qu.addGroup(t); return this.sl(s / ml) } getArrayBufferResource(t) { const s = this.Qu.addGroup(t) / ml; return this.il(s) } il(t) { if (!this.Zu[t]) { const s = this.Yu[t % 2]; this.Zu[t] = new Fa({ buffer: s, offset: 256 * (t / 2 | 0), size: ml }) } return this.Zu[t] } sl(t) { if (!this.Ku[t]) { const s = new Ki({ 0: this.il(t) }); this.Ku[t] = s } return this.Ku[t] } Ju() { const t = this.Gi.buffer, s = this.Yu[0]; s.update(this.Qu.byteIndex), t.updateBuffer(s); const i = this.Gi.gpu.device.createCommandEncoder(); for (let e = 1; e < this.Yu.length; e++) { const n = this.Yu[e]; i.copyBufferToBuffer(t.getGPUBuffer(s), ml, t.getGPUBuffer(n), 0, this.Qu.byteIndex) } this.Gi.gpu.device.queue.submit([i.finish()]) } destroy() { for (let t = 0; t < this.Ku.length; t++)this.Ku[t]?.destroy(); this.Ku = null, this.Xu = null; for (let t = 0; t < this.Yu.length; t++)this.Yu[t].destroy(); this.Yu = null; for (let t = 0; t < this.Zu.length; t++)this.Zu[t].destroy(); this.Zu = null, this.Qu.destroy(), this.Xu = null, this.Gi = null } } gl.extension = { type: [r.WebGPUPipes], name: "uniformBatch" }; const vl = { "point-list": 0, "line-list": 1, "line-strip": 2, "triangle-list": 3, "triangle-strip": 4 }; class bl { constructor(t) { this.el = Object.create(null), this.nl = Object.create(null), this.rl = Object.create(null), this.ol = Object.create(null), this.hl = Object.create(null), this.al = 15, this.ul = 1, this.Gi = t } contextChange(t) { this.Ru = t, this.setStencilMode(Sn.DISABLED), this.ll() } setMultisampleCount(t) { this.ul !== t && (this.ul = t, this.ll()) } setRenderTarget(t) { this.ul = t.msaaSamples, this.cl = t.descriptor.depthStencilAttachment ? 1 : 0, this.ll() } setColorMask(t) { this.al !== t && (this.al = t, this.ll()) } setStencilMode(t) { this.fl !== t && (this.fl = t, this.dl = la[t], this.ll()) } setPipeline(t, s, i, e) { const n = this.getPipeline(t, s, i); e.setPipeline(n) } getPipeline(t, s, i, e) { t.Se || (Yh(t, s.attributeData), this.pl(t)), e || (e = t.topology); const n = function (t, s, i, e, n) { return t << 24 | s << 16 | i << 10 | e << 5 | n }(t.Se, s.Se, i.data, i.ze, vl[e]); return this.ol[n] || (this.ol[n] = this.ml(t, s, i, e)), this.ol[n] } ml(t, s, i, e) { const n = this.Ru.device, r = this.vl(t, s), o = this.Gi.state.getColorTargets(i); o[0].writeMask = this.fl === Sn.RENDERING_MASK_ADD ? 0 : this.al; const h = this.Gi.shader.getProgramData(s).pipeline, a = { vertex: { module: this.bl(s.vertex.source), entryPoint: s.vertex.entryPoint, buffers: r }, fragment: { module: this.bl(s.fragment.source), entryPoint: s.fragment.entryPoint, targets: o }, primitive: { topology: e, cullMode: i.cullMode }, layout: h, multisample: { count: this.ul }, label: "PIXI Pipeline" }; return this.cl && (a.depthStencil = { ...this.dl, format: "depth24plus-stencil8", depthWriteEnabled: i.depthTest, depthCompare: i.depthTest ? "less" : "always" }), n.createRenderPipeline(a) } bl(t) { return this.el[t] || this.xl(t) } xl(t) { const s = this.Ru.device; return this.el[t] = s.createShaderModule({ code: t }), this.el[t] } pl(t) { const s = []; let i = 0; const e = Object.keys(t.attributes).sort(); for (let r = 0; r < e.length; r++) { const n = t.attributes[e[r]]; s[i++] = n.offset, s[i++] = n.format, s[i++] = n.stride, s[i++] = n.instance } const n = s.join("|"); return t.Se = Si(n, "geometry"), t.Se } yl(t) { const s = []; let i = 0; const e = Object.keys(t.attributeData).sort(); for (let r = 0; r < e.length; r++) { const n = t.attributeData[e[r]]; s[i++] = n.location } const n = s.join("|"); return t.Pe = Si(n, "programAttributes"), t.Pe } getBufferNamesToBind(t, s) { const i = t.Se << 16 | s.Pe; if (this.rl[i]) return this.rl[i]; const e = this.vl(t, s), n = Object.create(null), r = s.attributeData; for (let o = 0; o < e.length; o++) { const t = Object.values(e[o].attributes)[0].shaderLocation; for (const s in r) if (r[s].location === t) { n[o] = s; break } } return this.rl[i] = n, n } vl(t, s) { s.Pe || this.yl(s); const i = t.Se << 16 | s.Pe; if (this.nl[i]) return this.nl[i]; const e = []; return t.buffers.forEach(i => { const n = { arrayStride: 0, stepMode: "vertex", attributes: [] }, r = n.attributes; for (const e in s.attributeData) { const o = t.attributes[e]; 1 !== (o.divisor ?? 1) && Et(o.divisor), o.buffer === i && (n.arrayStride = o.stride, n.stepMode = o.instance ? "instance" : "vertex", r.push({ shaderLocation: s.attributeData[e].location, offset: o.offset, format: o.format })) } r.length && e.push(n) }), this.nl[i] = e, e } ll() { const t = (s = this.fl, i = this.ul, this.al << 6 | s << 3 | this.cl << 1 | i); var s, i; this.hl[t] || (this.hl[t] = Object.create(null)), this.ol = this.hl[t] } destroy() { this.Gi = null, this.nl = null } } bl.extension = { type: [r.WebGPUSystem], name: "pipeline" }; class xl { constructor() { this.contexts = [], this.msaaTextures = [], this.msaaSamples = 1 } } class yl { init(t, s) { this.Gi = t, this.Kh = s } copyToTexture(t, s, i, e, n) { const r = this.Gi, o = this.wl(t), h = r.texture.getGpuSource(s.source); return r.encoder.commandEncoder.copyTextureToTexture({ texture: o, origin: i }, { texture: h, origin: n }, e), s } startRenderPass(t, s = !0, i, e) { const n = this.Kh.getGpuRenderTarget(t), r = this.getDescriptor(t, s, i); n.descriptor = r, this.Gi.pipeline.setRenderTarget(n), this.Gi.encoder.beginRenderPass(n), this.Gi.encoder.setViewport(e) } finishRenderPass() { this.Gi.encoder.endRenderPass() } wl(t) { const s = this.Kh.getGpuRenderTarget(t); return s.contexts[0] ? s.contexts[0].getCurrentTexture() : this.Gi.texture.getGpuSource(t.colorTextures[0].source) } getDescriptor(t, s, i) { "boolean" == typeof s && (s = s ? Ue.ALL : Ue.NONE); const e = this.Kh, n = e.getGpuRenderTarget(t), r = t.colorTextures.map((t, r) => { const o = n.contexts[r]; let h, a; h = o ? o.getCurrentTexture().createView() : this.Gi.texture.getGpuSource(t).createView({ mipLevelCount: 1 }), n.msaaTextures[r] && (a = h, h = this.Gi.texture.getTextureView(n.msaaTextures[r])); const u = s & Ue.COLOR ? "clear" : "load"; return i ?? (i = e.defaultClearColor), { view: h, resolveTarget: a, clearValue: i, storeOp: "store", loadOp: u } }); let o; if (!t.stencil && !t.depth || t.depthStencilTexture || (t.ensureDepthStencilTexture(), t.depthStencilTexture.source.sampleCount = n.msaa ? 4 : 1), t.depthStencilTexture) { const i = s & Ue.STENCIL ? "clear" : "load", e = s & Ue.DEPTH ? "clear" : "load"; o = { view: this.Gi.texture.getGpuSource(t.depthStencilTexture.source).createView(), stencilStoreOp: "store", stencilLoadOp: i, depthClearValue: 1, depthLoadOp: e, depthStoreOp: "store" } } return { colorAttachments: r, depthStencilAttachment: o } } clear(t, s = !0, i, e) { if (!s) return; const { gpu: n, encoder: r } = this.Gi, o = n.device; if (null === r.commandEncoder) { const n = o.createCommandEncoder(), r = this.getDescriptor(t, s, i), h = n.beginRenderPass(r); h.setViewport(e.x, e.y, e.width, e.height, 0, 1), h.end(); const a = n.finish(); o.queue.submit([a]) } else this.startRenderPass(t, s, i, e) } initGpuRenderTarget(t) { t.isRoot = !0; const s = new xl; return t.colorTextures.forEach((t, i) => { if (t instanceof Fs) { const n = t.resource.getContext("webgpu"), r = t.transparent ? "premultiplied" : "opaque"; try { n.configure({ device: this.Gi.gpu.device, usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC, format: "bgra8unorm", alphaMode: r }) } catch (e) { } s.contexts[i] = n } if (s.msaa = t.source.antialias, t.source.antialias) { const t = new q({ width: 0, height: 0, sampleCount: 4 }); s.msaaTextures[i] = t } }), s.msaa && (s.msaaSamples = 4, t.depthStencilTexture && (t.depthStencilTexture.source.sampleCount = 4)), s } destroyGpuRenderTarget(t) { t.contexts.forEach(t => { t.unconfigure() }), t.msaaTextures.forEach(t => { t.destroy() }), t.msaaTextures.length = 0, t.contexts.length = 0 } ensureDepthStencilTexture(t) { const s = this.Kh.getGpuRenderTarget(t); t.depthStencilTexture && s.msaa && (t.depthStencilTexture.source.sampleCount = 4) } resizeGpuRenderTarget(t) { const s = this.Kh.getGpuRenderTarget(t); s.width = t.width, s.height = t.height, s.msaa && t.colorTextures.forEach((t, i) => { const e = s.msaaTextures[i]; e?.resize(t.source.width, t.source.height, t.source.G) }) } } class wl extends Pa { constructor(t) { super(t), this.adaptor = new yl, this.adaptor.init(t, this) } } wl.extension = { type: [r.WebGPUSystem], name: "renderTarget" }; class Ml { constructor() { this.Ml = Object.create(null) } contextChange(t) { this.Ru = t } getProgramData(t) { return this.Ml[t.Se] || this.Tl(t) } Tl(t) { const s = this.Ru.device, i = t.gpuLayout.map(t => s.createBindGroupLayout({ entries: t })), e = { bindGroupLayouts: i }; return this.Ml[t.Se] = { bindGroups: i, pipeline: s.createPipelineLayout(e) }, this.Ml[t.Se] } destroy() { this.Ru = null, this.Ml = null } } Ml.extension = { type: [r.WebGPUSystem], name: "shader" }; const Tl = { normal: { alpha: { srcFactor: "one", dstFactor: "one-minus-src-alpha", operation: "add" }, color: { srcFactor: "one", dstFactor: "one-minus-src-alpha", operation: "add" } }, add: { alpha: { srcFactor: "src-alpha", dstFactor: "one-minus-src-alpha", operation: "add" }, color: { srcFactor: "one", dstFactor: "one", operation: "add" } }, multiply: { alpha: { srcFactor: "one", dstFactor: "one-minus-src-alpha", operation: "add" }, color: { srcFactor: "dst", dstFactor: "one-minus-src-alpha", operation: "add" } }, screen: { alpha: { srcFactor: "one", dstFactor: "one-minus-src-alpha", operation: "add" }, color: { srcFactor: "one", dstFactor: "one-minus-src", operation: "add" } }, overlay: { alpha: { srcFactor: "one", dstFactor: "one-minus-src-alpha", operation: "add" }, color: { srcFactor: "one", dstFactor: "one-minus-src", operation: "add" } }, none: { alpha: { srcFactor: "one", dstFactor: "one-minus-src-alpha", operation: "add" }, color: { srcFactor: "zero", dstFactor: "zero", operation: "add" } }, "normal-npm": { alpha: { srcFactor: "one", dstFactor: "one-minus-src-alpha", operation: "add" }, color: { srcFactor: "src-alpha", dstFactor: "one-minus-src-alpha", operation: "add" } }, "add-npm": { alpha: { srcFactor: "one", dstFactor: "one", operation: "add" }, color: { srcFactor: "src-alpha", dstFactor: "one", operation: "add" } }, "screen-npm": { alpha: { srcFactor: "one", dstFactor: "one-minus-src-alpha", operation: "add" }, color: { srcFactor: "src-alpha", dstFactor: "one-minus-src", operation: "add" } }, erase: { alpha: { srcFactor: "zero", dstFactor: "one-minus-src-alpha", operation: "add" }, color: { srcFactor: "zero", dstFactor: "one-minus-src", operation: "add" } }, min: { alpha: { srcFactor: "one", dstFactor: "one", operation: "min" }, color: { srcFactor: "one", dstFactor: "one", operation: "min" } }, max: { alpha: { srcFactor: "one", dstFactor: "one", operation: "max" }, color: { srcFactor: "one", dstFactor: "one", operation: "max" } } }; class Al { constructor() { this.defaultState = new se, this.defaultState.blend = !0 } contextChange(t) { this.gpu = t } getColorTargets(t) { return [{ format: "bgra8unorm", writeMask: 0, blend: Tl[t.blendMode] || Tl.normal }] } destroy() { this.gpu = null } } Al.extension = { type: [r.WebGPUSystem], name: "state" }; const Cl = { type: "image", upload(t, s, i) { const e = t.resource, n = (0 | t.pixelWidth) * (0 | t.pixelHeight), r = e.byteLength / n; i.device.queue.writeTexture({ texture: s }, e, { offset: 0, rowsPerImage: t.pixelHeight, bytesPerRow: t.pixelWidth * r }, { width: t.pixelWidth, height: t.pixelHeight, depthOrArrayLayers: 1 }) } }, _l = { "bc1-rgba-unorm": { blockBytes: 8, blockWidth: 4, blockHeight: 4 }, "bc2-rgba-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 }, "bc3-rgba-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 }, "bc7-rgba-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 }, "etc1-rgb-unorm": { blockBytes: 8, blockWidth: 4, blockHeight: 4 }, "etc2-rgba8unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 }, "astc-4x4-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 } }, Sl = { blockBytes: 4, blockWidth: 1, blockHeight: 1 }, Pl = { type: "compressed", upload(t, s, i) { let e = t.pixelWidth, n = t.pixelHeight; const r = _l[t.format] || Sl; for (let o = 0; o < t.resource.length; o++) { const h = t.resource[o], a = Math.ceil(e / r.blockWidth) * r.blockBytes; i.device.queue.writeTexture({ texture: s, mipLevel: o }, h, { offset: 0, bytesPerRow: a }, { width: Math.ceil(e / r.blockWidth) * r.blockWidth, height: Math.ceil(n / r.blockHeight) * r.blockHeight, depthOrArrayLayers: 1 }), e = Math.max(e >> 1, 1), n = Math.max(n >> 1, 1) } } }, kl = { type: "image", upload(t, s, i) { const e = t.resource; if (!e) return; if (globalThis.HTMLImageElement && e instanceof HTMLImageElement) { const s = ks.get().createCanvas(e.width, e.height); s.getContext("2d").drawImage(e, 0, 0, e.width, e.height), t.resource = s, Et() } const n = Math.min(s.width, t.resourceWidth || t.pixelWidth), r = Math.min(s.height, t.resourceHeight || t.pixelHeight), o = "premultiply-alpha-on-upload" === t.alphaMode; i.device.queue.copyExternalImageToTexture({ source: e }, { texture: s, premultipliedAlpha: o }, { width: n, height: r }) } }, Fl = { type: "video", upload(t, s, i) { kl.upload(t, s, i) } }; class El { constructor(t) { this.device = t, this.sampler = t.createSampler({ minFilter: "linear" }), this.pipelines = {} } Al(t) { let s = this.pipelines[t]; return s || (this.mipmapShaderModule || (this.mipmapShaderModule = this.device.createShaderModule({ code: "\n                        var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(\n                        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));\n\n                        struct VertexOutput {\n                        @builtin(position) position : vec4<f32>,\n                        @location(0) texCoord : vec2<f32>,\n                        };\n\n                        @vertex\n                        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {\n                        var output : VertexOutput;\n                        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);\n                        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);\n                        return output;\n                        }\n\n                        @group(0) @binding(0) var imgSampler : sampler;\n                        @group(0) @binding(1) var img : texture_2d<f32>;\n\n                        @fragment\n                        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {\n                        return textureSample(img, imgSampler, texCoord);\n                        }\n                    " })), s = this.device.createRenderPipeline({ layout: "auto", vertex: { module: this.mipmapShaderModule, entryPoint: "vertexMain" }, fragment: { module: this.mipmapShaderModule, entryPoint: "fragmentMain", targets: [{ format: t }] } }), this.pipelines[t] = s), s } generateMipmap(t) { const s = this.Al(t.format); if ("3d" === t.dimension || "1d" === t.dimension) throw new Error("Generating mipmaps for non-2d textures is currently unsupported!"); let i = t; const e = t.depthOrArrayLayers || 1, n = t.usage & GPUTextureUsage.RENDER_ATTACHMENT; if (!n) { const s = { size: { width: Math.ceil(t.width / 2), height: Math.ceil(t.height / 2), depthOrArrayLayers: e }, format: t.format, usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT, mipLevelCount: t.mipLevelCount - 1 }; i = this.device.createTexture(s) } const r = this.device.createCommandEncoder({}), o = s.getBindGroupLayout(0); for (let h = 0; h < e; ++h) { let e = t.createView({ baseMipLevel: 0, mipLevelCount: 1, dimension: "2d", baseArrayLayer: h, arrayLayerCount: 1 }), a = n ? 1 : 0; for (let n = 1; n < t.mipLevelCount; ++n) { const t = i.createView({ baseMipLevel: a++, mipLevelCount: 1, dimension: "2d", baseArrayLayer: h, arrayLayerCount: 1 }), n = r.beginRenderPass({ colorAttachments: [{ view: t, storeOp: "store", loadOp: "clear", clearValue: { r: 0, g: 0, b: 0, a: 0 } }] }), u = this.device.createBindGroup({ layout: o, entries: [{ binding: 0, resource: this.sampler }, { binding: 1, resource: e }] }); n.setPipeline(s), n.setBindGroup(0, u), n.draw(3, 1, 0, 0), n.end(), e = t } } if (!n) { const s = { width: Math.ceil(t.width / 2), height: Math.ceil(t.height / 2), depthOrArrayLayers: e }; for (let e = 1; e < t.mipLevelCount; ++e)r.copyTextureToTexture({ texture: i, mipLevel: e - 1 }, { texture: t, mipLevel: e }, s), s.width = Math.ceil(s.width / 2), s.height = Math.ceil(s.height / 2) } return this.device.queue.submit([r.finish()]), n || i.destroy(), t } } class Rl { constructor(t) { this.managedTextures = [], this.Cl = Object.create(null), this._l = Object.create(null), this.Xu = Object.create(null), this.Sl = Object.create(null), this.Ra = { image: kl, buffer: Cl, video: Fl, compressed: Pl }, this.Gi = t, t.renderableGC.addManagedHash(this, "_gpuSources"), t.renderableGC.addManagedHash(this, "_gpuSamplers"), t.renderableGC.addManagedHash(this, "_bindGroupHash"), t.renderableGC.addManagedHash(this, "_textureViewHash") } contextChange(t) { this.Ru = t } initSource(t) { return this.Cl[t.uid] ? this.Cl[t.uid] : this.ja(t) } ja(t) { if (t.autoGenerateMipmaps) { const s = Math.max(t.pixelWidth, t.pixelHeight); t.mipLevelCount = Math.floor(Math.log2(s)) + 1 } let s = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST; "compressed" !== t.uploadMethodId && (s |= GPUTextureUsage.RENDER_ATTACHMENT, s |= GPUTextureUsage.COPY_SRC); const i = _l[t.format] || { blockWidth: 1, blockHeight: 1 }, e = Math.ceil(t.pixelWidth / i.blockWidth) * i.blockWidth, n = Math.ceil(t.pixelHeight / i.blockHeight) * i.blockHeight, r = { label: t.label, size: { width: e, height: n }, format: t.format, sampleCount: t.sampleCount, mipLevelCount: t.mipLevelCount, dimension: t.dimension, usage: s }, o = this.Cl[t.uid] = this.Ru.device.createTexture(r); return this.managedTextures.includes(t) || (t.on("update", this.onSourceUpdate, this), t.on("resize", this.onSourceResize, this), t.on("destroy", this.onSourceDestroy, this), t.on("unload", this.onSourceUnload, this), t.on("updateMipmaps", this.onUpdateMipmaps, this), this.managedTextures.push(t)), this.onSourceUpdate(t), o } onSourceUpdate(t) { const s = this.getGpuSource(t); s && (this.Ra[t.uploadMethodId] && this.Ra[t.uploadMethodId].upload(t, s, this.Ru), t.autoGenerateMipmaps && t.mipLevelCount > 1 && this.onUpdateMipmaps(t)) } onSourceUnload(t) { const s = this.Cl[t.uid]; s && (this.Cl[t.uid] = null, s.destroy()) } onUpdateMipmaps(t) { this.Pl || (this.Pl = new El(this.Ru.device)); const s = this.getGpuSource(t); this.Pl.generateMipmap(s) } onSourceDestroy(t) { t.off("update", this.onSourceUpdate, this), t.off("unload", this.onSourceUnload, this), t.off("destroy", this.onSourceDestroy, this), t.off("resize", this.onSourceResize, this), t.off("updateMipmaps", this.onUpdateMipmaps, this), this.managedTextures.splice(this.managedTextures.indexOf(t), 1), this.onSourceUnload(t) } onSourceResize(t) { const s = this.Cl[t.uid]; s ? s.width === t.pixelWidth && s.height === t.pixelHeight || (this.Sl[t.uid] = null, this.Xu[t.uid] = null, this.onSourceUnload(t), this.initSource(t)) : this.initSource(t) } La(t) { return this._l[t.U] = this.Ru.device.createSampler(t), this._l[t.U] } getGpuSampler(t) { return this._l[t.U] || this.La(t) } getGpuSource(t) { return this.Cl[t.uid] || this.initSource(t) } getTextureBindGroup(t) { return this.Xu[t.uid] ?? this.kl(t) } kl(t) { const s = t.source; return this.Xu[t.uid] = new Ki({ 0: s, 1: s.style, 2: new Yi({ uTextureMatrix: { type: "mat3x3<f32>", value: t.textureMatrix.mapCoord } }) }), this.Xu[t.uid] } getTextureView(t) { const s = t.source; return this.Sl[s.uid] ?? this.Fl(s) } Fl(t) { return this.Sl[t.uid] = this.getGpuSource(t).createView(), this.Sl[t.uid] } generateCanvas(t) { const s = this.Gi, i = s.gpu.device.createCommandEncoder(), e = ks.get().createCanvas(); e.width = t.source.pixelWidth, e.height = t.source.pixelHeight; const n = e.getContext("webgpu"); return n.configure({ device: s.gpu.device, usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC, format: ks.get().getNavigator().gpu.getPreferredCanvasFormat(), alphaMode: "premultiplied" }), i.copyTextureToTexture({ texture: s.texture.getGpuSource(t.source), origin: { x: 0, y: 0 } }, { texture: n.getCurrentTexture() }, { width: e.width, height: e.height }), s.gpu.device.queue.submit([i.finish()]), e } getPixels(t) { const s = this.generateCanvas(t), i = $o.getOptimalCanvasAndContext(s.width, s.height), e = i.context; e.drawImage(s, 0, 0); const { width: n, height: r } = s, o = e.getImageData(0, 0, n, r), h = new Uint8ClampedArray(o.data.buffer); return $o.returnCanvasAndContext(i), { pixels: h, width: n, height: r } } destroy() { this.managedTextures.slice().forEach(t => this.onSourceDestroy(t)), this.managedTextures = null; for (const t of Object.keys(this.Xu)) { const s = Number(t), i = this.Xu[s]; i?.destroy(), this.Xu[s] = null } this.Gi = null, this.Ru = null, this.Pl = null, this.Cl = null, this.Xu = null, this.Sl = null, this._l = null } } Rl.extension = { type: [r.WebGPUSystem], name: "texture" }; class Ol { constructor() { this.El = 0 } contextChange(t) { const s = new Yi({ uTransformMatrix: { value: new w, type: "mat3x3<f32>" }, uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" }, uRound: { value: 0, type: "f32" } }); this.El = t.limits.maxBatchableTextures; const i = lr({ name: "graphics", bits: [fr, vr(this.El), Ih, wr] }); this.shader = new Qi({ gpuProgram: i, resources: { localUniforms: s } }) } execute(t, s) { const i = s.context, e = i.customShader || this.shader, n = t.renderer, r = n.graphicsContext, { batcher: o, instructions: h } = r.getContextRenderData(i), a = n.encoder; a.setGeometry(o.geometry, e.gpuProgram); const u = n.globalUniforms.bindGroup; a.setBindGroup(0, u, e.gpuProgram); const l = n.renderPipes.uniformBatch.getUniformBindGroup(e.resources.localUniforms, !0); a.setBindGroup(2, l, e.gpuProgram); const c = h.instructions; let f = null; for (let d = 0; d < h.instructionSize; d++) { const s = c[d]; if (s.topology !== f && (f = s.topology, a.setPipelineFromGeometryProgramAndState(o.geometry, e.gpuProgram, t.state, s.topology)), e.groups[1] = s.bindGroup, !s.gpuBindGroup) { const t = s.textures; s.bindGroup = Tn(t.textures, t.count, this.El), s.gpuBindGroup = n.bindGroup.getBindGroup(s.bindGroup, e.gpuProgram, 1) } a.setBindGroup(1, s.bindGroup, e.gpuProgram), a.renderPassEncoder.drawIndexed(s.size, 1, s.start) } } destroy() { this.shader.destroy(!0), this.shader = null } } Ol.extension = { type: [r.WebGPUPipesAdaptor], name: "graphics" }; class Ul { init() { const t = lr({ name: "mesh", bits: [Uh, Gh, wr] }); this.Jo = new Qi({ gpuProgram: t, resources: { uTexture: Z.EMPTY.K, uSampler: Z.EMPTY.K.style, textureUniforms: { uTextureMatrix: { type: "mat3x3<f32>", value: new w } } } }) } execute(t, s) { const i = t.renderer; let e = s.Jo; if (e) { if (!e.gpuProgram) return void Et(s.shader) } else e = this.Jo, e.groups[2] = i.texture.getTextureBindGroup(s.texture); const n = e.gpuProgram; if (n.autoAssignGlobalUniforms && (e.groups[0] = i.globalUniforms.bindGroup), n.autoAssignLocalUniforms) { const s = t.localUniforms; e.groups[1] = i.renderPipes.uniformBatch.getUniformBindGroup(s, !0) } i.encoder.draw({ geometry: s.th, shader: e, state: s.state }) } destroy() { this.Jo.destroy(!0), this.Jo = null } } Ul.extension = { type: [r.WebGPUPipesAdaptor], name: "mesh" }; const Il = [...qu, pl, hl, ol, al, el, Rl, wl, Ml, Al, bl, rl, ul, il], Bl = [...Xu, gl], Gl = [Eh, Ul, Ol], $l = [], zl = [], Dl = []; a.handleByNamedList(r.WebGPUSystem, $l), a.handleByNamedList(r.WebGPUPipes, zl), a.handleByNamedList(r.WebGPUPipesAdaptor, Dl), a.add(...Il, ...Bl, ...Gl); const jl = Object.freeze(Object.defineProperty({ __proto__: null, WebGPURenderer: class extends De { constructor() { super({ name: "webgpu", type: Zi.WEBGPU, systems: $l, renderPipes: zl, renderPipeAdaptors: Dl }) } } }, Symbol.toStringTag, { value: "Module" })); class Ll { constructor() { this.batches = [], this.batched = !1 } destroy() { this.batches.forEach(t => { Ut.return(t) }), this.batches.length = 0 } } class Vl { constructor(t, s) { this.state = se.for2d(), this.renderer = t, this.eh = s, this.renderer.runners.contextChange.add(this) } contextChange() { this.eh.contextChange(this.renderer) } validateRenderable(t) { const s = t.context, i = !!t.ps, e = this.renderer.graphicsContext.updateGpuContext(s); return !(!e.isBatchable && i === e.isBatchable) } addRenderable(t, s) { const i = this.renderer.graphicsContext.updateGpuContext(t.context); t.didViewUpdate && this.Rl(t), i.isBatchable ? this.Ol(t, s) : (this.renderer.renderPipes.batch.break(s), s.add(t)) } updateRenderable(t) { const s = this.Ul(t).batches; for (let i = 0; i < s.length; i++) { const t = s[i]; t.In.updateElement(t) } } execute(t) { if (!t.isRenderable) return; const s = this.renderer, i = t.context; if (!s.graphicsContext.getGpuContext(i).batches.length) return; const e = i.customShader || this.eh.shader; this.state.blendMode = t.groupBlendMode; const n = e.resources.localUniforms.uniforms; n.uTransformMatrix = t.groupTransform, n.uRound = s.fs | t.fs, Ou(t.groupColorAlpha, n.uColor, 0), this.eh.execute(this, t) } Rl(t) { const s = this.Ul(t), i = this.renderer.graphicsContext.updateGpuContext(t.context); s.destroy(), i.isBatchable && this.Il(t, s) } Ol(t, s) { const i = this.renderer.renderPipes.batch, e = this.Ul(t).batches; for (let n = 0; n < e.length; n++) { const t = e[n]; i.addToBatch(t, s) } } Ul(t) { return t.ps[this.renderer.uid] || this.Bl(t) } Bl(t) { const s = new Ll; return t.ps[this.renderer.uid] = s, s } Il(t, s) { const i = t.context, e = this.renderer.graphicsContext.getGpuContext(i), n = this.renderer.fs | t.fs; s.batches = e.batches.map(s => { const i = Ut.get(Er); return s.copyTo(i), i.renderable = t, i.roundPixels = n, i }) } destroy() { this.renderer = null, this.eh.destroy(), this.eh = null, this.state = null } } Vl.extension = { type: [r.WebGLPipes, r.WebGPUPipes, r.CanvasPipes], name: "graphics" }; const Nl = class t extends mh { constructor(...t) { super({}); let s = t[0] ?? {}; "number" == typeof s && ($(0, "PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead"), s = { width: s, height: t[1], verticesX: t[2], verticesY: t[3] }), this.build(s) } build(s) { s = { ...t.defaultOptions, ...s }, this.verticesX = this.verticesX ?? s.verticesX, this.verticesY = this.verticesY ?? s.verticesY, this.width = this.width ?? s.width, this.height = this.height ?? s.height; const i = this.verticesX * this.verticesY, e = [], n = [], r = [], o = this.verticesX - 1, h = this.verticesY - 1, a = this.width / o, u = this.height / h; for (let t = 0; t < i; t++) { const s = t % this.verticesX, i = t / this.verticesX | 0; e.push(s * a, i * u), n.push(s / o, i / h) } const l = o * h; for (let t = 0; t < l; t++) { const s = t % o, i = t / o | 0, e = i * this.verticesX + s, n = i * this.verticesX + s + 1, h = (i + 1) * this.verticesX + s, a = (i + 1) * this.verticesX + s + 1; r.push(e, n, h, n, a, h) } this.buffers[0].data = new Float32Array(e), this.buffers[1].data = new Float32Array(n), this.indexBuffer.data = new Uint32Array(r), this.buffers[0].update(), this.buffers[1].update(), this.indexBuffer.update() } }; Nl.defaultOptions = { width: 100, height: 100, verticesX: 10, verticesY: 10 }; let Wl = Nl; class Hl { constructor() { this.batcherName = "default", this.packAsQuad = !1, this.indexOffset = 0, this.attributeOffset = 0, this.roundPixels = 0, this.In = null, this.Bn = null, this.Gl = -1, this.$l = -1 } get blendMode() { return this.renderable.groupBlendMode } get topology() { return this.zl || this.geometry.topology } set topology(t) { this.zl = t } reset() { this.renderable = null, this.texture = null, this.In = null, this.Bn = null, this.geometry = null, this.$l = -1, this.Gl = -1 } setTexture(t) { this.texture !== t && (this.texture = t, this.Gl = -1) } get uvs() { const t = this.geometry.getBuffer("aUV"), s = t.data; let i = s; const e = this.texture.textureMatrix; return e.isSimple || (i = this.Dl, this.Gl === e.X && this.$l === t.X || ((!i || i.length < s.length) && (i = this.Dl = new Float32Array(s.length)), this.Gl = e.X, this.$l = t.X, e.multiplyUvs(s, i))), i } get positions() { return this.geometry.positions } get indices() { return this.geometry.indices } get color() { return this.renderable.groupColorAlpha } get groupTransform() { return this.renderable.groupTransform } get attributeSize() { return this.geometry.positions.length / 2 } get indexSize() { return this.geometry.indices.length } } class ql { destroy() { } } class Xl { constructor(t, s) { this.localUniforms = new Yi({ uTransformMatrix: { value: new w, type: "mat3x3<f32>" }, uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" }, uRound: { value: 0, type: "f32" } }), this.localUniformsBindGroup = new Ki({ 0: this.localUniforms }), this.renderer = t, this.eh = s, this.eh.init() } validateRenderable(t) { const s = this.jl(t), i = s.batched, e = t.batched; if (s.batched = e, i !== e) return !0; if (e) { const i = t.th; if (i.indices.length !== s.indexSize || i.positions.length !== s.vertexSize) return s.indexSize = i.indices.length, s.vertexSize = i.positions.length, !0; const e = this.Ll(t); return e.texture.uid !== t.Y.uid && (e.Gl = -1), !e.In.checkAndUpdateTexture(e, t.Y) } return !1 } addRenderable(t, s) { const i = this.renderer.renderPipes.batch, e = this.jl(t); if (t.didViewUpdate && (e.indexSize = t.th.indices?.length, e.vertexSize = t.th.positions?.length), e.batched) { const e = this.Ll(t); e.setTexture(t.Y), e.geometry = t.th, i.addToBatch(e, s) } else i.break(s), s.add(t) } updateRenderable(t) { if (t.batched) { const s = this.Ll(t); s.setTexture(t.Y), s.geometry = t.th, s.In.updateElement(s) } } execute(t) { if (!t.isRenderable) return; t.state.blendMode = Pn(t.groupBlendMode, t.texture.K); const s = this.localUniforms; s.uniforms.uTransformMatrix = t.groupTransform, s.uniforms.uRound = this.renderer.fs | t.fs, s.update(), Ou(t.groupColorAlpha, s.uniforms.uColor, 0), this.eh.execute(this, t) } jl(t) { var s, i; return (s = t.ps)[i = this.renderer.uid] || (s[i] = new ql), t.ps[this.renderer.uid].meshData || this.Vl(t) } Vl(t) { return t.ps[this.renderer.uid].meshData = { batched: t.batched, indexSize: 0, vertexSize: 0 }, t.ps[this.renderer.uid].meshData } Ll(t) { var s, i; return (s = t.ps)[i = this.renderer.uid] || (s[i] = new ql), t.ps[this.renderer.uid].batchableMesh || this.Nl(t) } Nl(t) { const s = new Hl; return s.renderable = t, s.setTexture(t.Y), s.transform = t.groupTransform, s.roundPixels = this.renderer.fs | t.fs, t.ps[this.renderer.uid].batchableMesh = s, s } destroy() { this.localUniforms = null, this.localUniformsBindGroup = null, this.eh.destroy(), this.eh = null, this.renderer = null } } Xl.extension = { type: [r.WebGLPipes, r.WebGPUPipes, r.CanvasPipes], name: "mesh" }; class Yl { execute(t, s) { const i = t.state, e = t.renderer, n = s.shader || t.defaultShader; n.resources.uTexture = s.texture.K, n.resources.uniforms = t.localUniforms; const r = e.gl, o = t.getBuffers(s); e.shader.bind(n), e.state.set(i), e.geometry.bind(o.geometry, n.glProgram); const h = 2 === o.geometry.indexBuffer.data.BYTES_PER_ELEMENT ? r.UNSIGNED_SHORT : r.UNSIGNED_INT; r.drawElements(r.TRIANGLES, 6 * s.particleChildren.length, h, 0) } } class Kl { execute(t, s) { const i = t.renderer, e = s.shader || t.defaultShader; e.groups[0] = i.renderPipes.uniformBatch.getUniformBindGroup(t.localUniforms, !0), e.groups[1] = i.texture.getTextureBindGroup(s.texture); const n = t.state, r = t.getBuffers(s); i.encoder.draw({ geometry: r.geometry, shader: s.shader || t.defaultShader, state: n, size: 6 * s.particleChildren.length }) } } function Zl(t, s = null) { const i = 6 * t; if (i > 65535 ? s || (s = new Uint32Array(i)) : s || (s = new Uint16Array(i)), s.length !== i) throw new Error(`Out buffer length is incorrect, got ${s.length} and expected ${i}`); for (let e = 0, n = 0; e < i; e += 6, n += 4)s[e + 0] = n + 0, s[e + 1] = n + 1, s[e + 2] = n + 2, s[e + 3] = n + 0, s[e + 4] = n + 2, s[e + 5] = n + 3; return s } function Ql(t, s) { const i = []; i.push("\n\n        var index = 0;\n\n        for (let i = 0; i < ps.length; ++i)\n        {\n            const p = ps[i];\n\n            "); let e = 0; for (const r in t) { const n = t[r]; s === n.dynamic && (i.push(`offset = index + ${e}`), i.push(n.code), e += zi(n.format).stride / 4) } i.push("\n            index += stride * 4;\n        }\n    "), i.unshift(`\n        var stride = ${e};\n    `); const n = i.join("\n"); return new Function("ps", "f32v", "u32v", n) } class Jl { constructor(t) { this.sa = 0, this.Wl = {}; const s = this.sa = t.size ?? 1e3, i = t.properties; let e = 0, n = 0; for (const u in i) { const t = i[u], s = zi(t.format); t.dynamic ? n += s.stride : e += s.stride } this.Hl = n / 4, this.ql = e / 4, this.staticAttributeBuffer = new An(4 * s * e), this.dynamicAttributeBuffer = new An(4 * s * n), this.indexBuffer = Zl(s); const r = new Wn; let o = 0, h = 0; this.Xl = new Vn({ data: new Float32Array(1), label: "static-particle-buffer", shrinkToFit: !1, usage: Ln.VERTEX | Ln.COPY_DST }), this.Yl = new Vn({ data: new Float32Array(1), label: "dynamic-particle-buffer", shrinkToFit: !1, usage: Ln.VERTEX | Ln.COPY_DST }); for (const u in i) { const t = i[u], s = zi(t.format); t.dynamic ? (r.addAttribute(t.attributeName, { buffer: this.Yl, stride: 4 * this.Hl, offset: 4 * o, format: t.format }), o += s.size) : (r.addAttribute(t.attributeName, { buffer: this.Xl, stride: 4 * this.ql, offset: 4 * h, format: t.format }), h += s.size) } r.addIndex(this.indexBuffer); const a = this.getParticleUpdate(i); this.Kl = a.dynamicUpdate, this.Zl = a.staticUpdate, this.geometry = r } getParticleUpdate(t) { const s = function (t) { const s = []; for (const i in t) { const e = t[i]; s.push(i, e.code, e.dynamic ? "d" : "s") } return s.join("_") }(t); return this.Wl[s] || (this.Wl[s] = this.generateParticleUpdate(t)), this.Wl[s] } generateParticleUpdate(t) { return function (t) { return { dynamicUpdate: Ql(t, !0), staticUpdate: Ql(t, !1) } }(t) } update(t, s) { t.length > this.sa && (s = !0, this.sa = Math.max(t.length, 1.5 * this.sa | 0), this.staticAttributeBuffer = new An(this.sa * this.ql * 4 * 4), this.dynamicAttributeBuffer = new An(this.sa * this.Hl * 4 * 4), this.indexBuffer = Zl(this.sa), this.geometry.indexBuffer.setDataWithSize(this.indexBuffer, this.indexBuffer.byteLength, !0)); const i = this.dynamicAttributeBuffer; if (this.Kl(t, i.float32View, i.uint32View), this.Yl.setDataWithSize(this.dynamicAttributeBuffer.float32View, t.length * this.Hl * 4, !0), s) { const s = this.staticAttributeBuffer; this.Zl(t, s.float32View, s.uint32View), this.Xl.setDataWithSize(s.float32View, t.length * this.ql * 4, !0) } } destroy() { this.Xl.destroy(), this.Yl.destroy(), this.geometry.destroy() } } var tc = "\nstruct ParticleUniforms {\n  uTranslationMatrix:mat3x3<f32>,\n  uColor:vec4<f32>,\n  uRound:f32,\n  uResolution:vec2<f32>,\n};\n\nfn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32>\n{\n  return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n}\n\n@group(0) @binding(0) var<uniform> uniforms: ParticleUniforms;\n\n@group(1) @binding(0) var uTexture: texture_2d<f32>;\n@group(1) @binding(1) var uSampler : sampler;\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>,\n    @location(1) color : vec4<f32>,\n  };\n@vertex\nfn mainVertex(\n  @location(0) aVertex: vec2<f32>,\n  @location(1) aPosition: vec2<f32>,\n  @location(2) aUV: vec2<f32>,\n  @location(3) aColor: vec4<f32>,\n  @location(4) aRotation: f32,\n) -> VSOutput {\n  \n   let v = vec2(\n       aVertex.x * cos(aRotation) - aVertex.y * sin(aRotation),\n       aVertex.x * sin(aRotation) + aVertex.y * cos(aRotation)\n   ) + aPosition;\n\n   var position = vec4((uniforms.uTranslationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n   if(uniforms.uRound == 1.0) {\n       position = vec4(roundPixels(position.xy, uniforms.uResolution), position.zw);\n   }\n\n    let vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uniforms.uColor;\n\n  return VSOutput(\n   position,\n   aUV,\n   vColor,\n  );\n}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @location(1) color: vec4<f32>,\n  @builtin(position) position: vec4<f32>,\n) -> @location(0) vec4<f32> {\n\n    var sample = textureSample(uTexture, uSampler, uv) * color;\n   \n    return sample;\n}"; class sc extends Qi { constructor() { super({ glProgram: Gi.from({ vertex: "attribute vec2 aVertex;\nattribute vec2 aUV;\nattribute vec4 aColor;\n\nattribute vec2 aPosition;\nattribute float aRotation;\n\nuniform mat3 uTranslationMatrix;\nuniform float uRound;\nuniform vec2 uResolution;\nuniform vec4 uColor;\n\nvarying vec2 vUV;\nvarying vec4 vColor;\n\nvec2 roundPixels(vec2 position, vec2 targetSize)\n{       \n    return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n}\n\nvoid main(void){\n    float cosRotation = cos(aRotation);\n    float sinRotation = sin(aRotation);\n    float x = aVertex.x * cosRotation - aVertex.y * sinRotation;\n    float y = aVertex.x * sinRotation + aVertex.y * cosRotation;\n\n    vec2 v = vec2(x, y);\n    v = v + aPosition;\n\n    gl_Position = vec4((uTranslationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n    if(uRound == 1.0)\n    {\n        gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n    }\n\n    vUV = aUV;\n    vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uColor;\n}\n", fragment: "varying vec2 vUV;\nvarying vec4 vColor;\n\nuniform sampler2D uTexture;\n\nvoid main(void){\n    vec4 color = texture2D(uTexture, vUV) * vColor;\n    gl_FragColor = color;\n}" }), gpuProgram: Ni.from({ fragment: { source: tc, entryPoint: "mainFragment" }, vertex: { source: tc, entryPoint: "mainVertex" } }), resources: { uTexture: Z.WHITE.source, uSampler: new W({}), uniforms: { uTranslationMatrix: { value: new w, type: "mat3x3<f32>" }, uColor: { value: new kt(16777215), type: "vec4<f32>" }, uRound: { value: 1, type: "f32" }, uResolution: { value: [0, 0], type: "vec2<f32>" } } } }) } } class ic { constructor(t, s) { this.state = se.for2d(), this.localUniforms = new Yi({ uTranslationMatrix: { value: new w, type: "mat3x3<f32>" }, uColor: { value: new Float32Array(4), type: "vec4<f32>" }, uRound: { value: 1, type: "f32" }, uResolution: { value: [0, 0], type: "vec2<f32>" } }), this.renderer = t, this.adaptor = s, this.defaultShader = new sc, this.state = se.for2d() } validateRenderable(t) { return !1 } addRenderable(t, s) { this.renderer.renderPipes.batch.break(s), s.add(t) } getBuffers(t) { return t.ps[this.renderer.uid] || this.Ql(t) } Ql(t) { return t.ps[this.renderer.uid] = new Jl({ size: t.particleChildren.length, properties: t.Jl }), t.ps[this.renderer.uid] } updateRenderable(t) { } execute(t) { const s = t.particleChildren; if (0 === s.length) return; const i = this.renderer, e = this.getBuffers(t); t.texture || (t.texture = s[0].texture); const n = this.state; e.update(s, t.tc), t.tc = !1, n.blendMode = Pn(t.blendMode, t.texture.K); const r = this.localUniforms.uniforms, o = r.uTranslationMatrix; t.worldTransform.copyTo(o), o.prepend(i.globalUniforms.globalUniformData.projectionMatrix), r.uResolution = i.globalUniforms.globalUniformData.resolution, r.uRound = i.fs | t.fs, Ou(t.groupColorAlpha, r.uColor, 0), this.adaptor.execute(this, t) } destroy() { this.renderer = null, this.defaultShader && (this.defaultShader.destroy(), this.defaultShader = null) } } class ec extends ic { constructor(t) { super(t, new Yl) } } ec.extension = { type: [r.WebGLPipes], name: "particle" }; class nc extends ic { constructor(t) { super(t, new Kl) } } nc.extension = { type: [r.WebGPUPipes], name: "particle" }; const rc = class t extends Wl { constructor(s = {}) { super({ width: (s = { ...t.defaultOptions, ...s }).width, height: s.height, verticesX: 4, verticesY: 4 }), this.update(s) } update(t) { this.width = t.width ?? this.width, this.height = t.height ?? this.height, this.sc = t.originalWidth ?? this.sc, this.ec = t.originalHeight ?? this.ec, this.nc = t.leftWidth ?? this.nc, this.rc = t.rightWidth ?? this.rc, this.oc = t.topHeight ?? this.oc, this.hc = t.bottomHeight ?? this.hc, this.ac = t.anchor?.x, this.uc = t.anchor?.y, this.updateUvs(), this.updatePositions() } updatePositions() { const t = this.positions, { width: s, height: i, nc: e, rc: n, oc: r, hc: o, ac: h, uc: a } = this, u = e + n, l = s > u ? 1 : s / u, c = r + o, f = i > c ? 1 : i / c, d = Math.min(l, f), p = h * s, m = a * i; t[0] = t[8] = t[16] = t[24] = -p, t[2] = t[10] = t[18] = t[26] = e * d - p, t[4] = t[12] = t[20] = t[28] = s - n * d - p, t[6] = t[14] = t[22] = t[30] = s - p, t[1] = t[3] = t[5] = t[7] = -m, t[9] = t[11] = t[13] = t[15] = r * d - m, t[17] = t[19] = t[21] = t[23] = i - o * d - m, t[25] = t[27] = t[29] = t[31] = i - m, this.getBuffer("aPosition").update() } updateUvs() { const t = this.uvs; t[0] = t[8] = t[16] = t[24] = 0, t[1] = t[3] = t[5] = t[7] = 0, t[6] = t[14] = t[22] = t[30] = 1, t[25] = t[27] = t[29] = t[31] = 1; const s = 1 / this.sc, i = 1 / this.ec; t[2] = t[10] = t[18] = t[26] = s * this.nc, t[9] = t[11] = t[13] = t[15] = i * this.oc, t[4] = t[12] = t[20] = t[28] = 1 - s * this.rc, t[17] = t[19] = t[21] = t[23] = 1 - i * this.hc, this.getBuffer("aUV").update() } }; rc.defaultOptions = { width: 100, height: 100, leftWidth: 10, topHeight: 10, rightWidth: 10, bottomHeight: 10, originalWidth: 100, originalHeight: 100 }; let oc = rc; class hc extends Hl { constructor() { super(), this.geometry = new oc } destroy() { this.geometry.destroy() } } class ac { constructor(t) { this.Gi = t } addRenderable(t, s) { const i = this.Qa(t); t.didViewUpdate && this.Ja(t, i), this.Gi.renderPipes.batch.addToBatch(i, s) } updateRenderable(t) { const s = this.Qa(t); t.didViewUpdate && this.Ja(t, s), s.In.updateElement(s) } validateRenderable(t) { const s = this.Qa(t); return !s.In.checkAndUpdateTexture(s, t.Y) } Ja(t, s) { s.geometry.update(t), s.setTexture(t.Y) } Qa(t) { return t.ps[this.Gi.uid] || this.tu(t) } tu(t) { const s = t.ps[this.Gi.uid] = new hc, i = s; return i.renderable = t, i.transform = t.groupTransform, i.texture = t.Y, i.roundPixels = this.Gi.fs | t.fs, t.didViewUpdate || this.Ja(t, i), s } destroy() { this.Gi = null } } ac.extension = { type: [r.WebGLPipes, r.WebGPUPipes, r.CanvasPipes], name: "nineSliceSprite" }; const uc = { name: "tiling-bit", vertex: { header: "\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        ", main: "\n            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;\n\n            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;\n        " }, fragment: { header: "\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        ", main: "\n\n            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);\n            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;\n            var unclamped = coord;\n            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);\n\n            var bias = 0.;\n\n            if(unclamped.x == coord.x && unclamped.y == coord.y)\n            {\n                bias = -32.;\n            }\n\n            outColor = textureSampleBias(uTexture, uSampler, coord, bias);\n        " } }, lc = { name: "tiling-bit", vertex: { header: "\n            uniform mat3 uTextureTransform;\n            uniform vec4 uSizeAnchor;\n\n        ", main: "\n            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;\n\n            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;\n        " }, fragment: { header: "\n            uniform sampler2D uTexture;\n            uniform mat3 uMapCoord;\n            uniform vec4 uClampFrame;\n            uniform vec2 uClampOffset;\n        ", main: "\n\n        vec2 coord = vUV + ceil(uClampOffset - vUV);\n        coord = (uMapCoord * vec3(coord, 1.0)).xy;\n        vec2 unclamped = coord;\n        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0\n\n        " } }; let cc, fc; class dc extends Qi { constructor() { cc ?? (cc = lr({ name: "tiling-sprite-shader", bits: [Uh, uc, wr] })), fc ?? (fc = cr({ name: "tiling-sprite-shader", bits: [Bh, lc, Mr] })); const t = new Yi({ uMapCoord: { value: new w, type: "mat3x3<f32>" }, uClampFrame: { value: new Float32Array([0, 0, 1, 1]), type: "vec4<f32>" }, uClampOffset: { value: new Float32Array([0, 0]), type: "vec2<f32>" }, uTextureTransform: { value: new w, type: "mat3x3<f32>" }, uSizeAnchor: { value: new Float32Array([100, 100, .5, .5]), type: "vec4<f32>" } }); super({ glProgram: fc, gpuProgram: cc, resources: { localUniforms: new Yi({ uTransformMatrix: { value: new w, type: "mat3x3<f32>" }, uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" }, uRound: { value: 0, type: "f32" } }), tilingUniforms: t, uTexture: Z.EMPTY.source, uSampler: Z.EMPTY.source.style } }) } updateUniforms(t, s, i, e, n, r) { const o = this.resources.tilingUniforms, h = r.width, a = r.height, u = r.textureMatrix, l = o.uniforms.uTextureTransform; l.set(i.a * h / t, i.b * h / s, i.c * a / t, i.d * a / s, i.tx / t, i.ty / s), l.invert(), o.uniforms.uMapCoord = u.mapCoord, o.uniforms.uClampFrame = u.uClampFrame, o.uniforms.uClampOffset = u.uClampOffset, o.uniforms.uTextureTransform = l, o.uniforms.uSizeAnchor[0] = t, o.uniforms.uSizeAnchor[1] = s, o.uniforms.uSizeAnchor[2] = e, o.uniforms.uSizeAnchor[3] = n, r && (this.resources.uTexture = r.source, this.resources.uSampler = r.source.style) } } const pc = new class extends mh { constructor() { super({ positions: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]), uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]), indices: new Uint32Array([0, 1, 2, 0, 2, 3]) }) } }; class mc { constructor() { this.canBatch = !0, this.geometry = new mh({ indices: pc.indices.slice(), positions: pc.positions.slice(), uvs: pc.uvs.slice() }) } destroy() { this.geometry.destroy(), this.shader?.destroy() } } class gc { constructor(t) { this.je = se.default2d, this.Gi = t } validateRenderable(t) { const s = this.lc(t), i = s.canBatch; this.cc(t); const e = s.canBatch; if (e && e === i) { const { batchableMesh: i } = s; return !i.In.checkAndUpdateTexture(i, t.texture) } return i !== e } addRenderable(t, s) { const i = this.Gi.renderPipes.batch; this.cc(t); const e = this.lc(t), { geometry: n, canBatch: r } = e; if (r) { e.batchableMesh || (e.batchableMesh = new Hl); const r = e.batchableMesh; t.didViewUpdate && (this.fc(t), r.geometry = n, r.renderable = t, r.transform = t.groupTransform, r.setTexture(t.Y)), r.roundPixels = this.Gi.fs | t.fs, i.addToBatch(r, s) } else i.break(s), e.shader || (e.shader = new dc), this.updateRenderable(t), s.add(t) } execute(t) { const { shader: s } = this.lc(t); s.groups[0] = this.Gi.globalUniforms.bindGroup; const i = s.resources.localUniforms.uniforms; i.uTransformMatrix = t.groupTransform, i.uRound = this.Gi.fs | t.fs, Ou(t.groupColorAlpha, i.uColor, 0), this.je.blendMode = Pn(t.groupBlendMode, t.texture.K), this.Gi.encoder.draw({ geometry: pc, shader: s, state: this.je }) } updateRenderable(t) { const s = this.lc(t), { canBatch: i } = s; if (i) { const { batchableMesh: i } = s; t.didViewUpdate && this.fc(t), i.In.updateElement(i) } else if (t.didViewUpdate) { const { shader: i } = s; i.updateUniforms(t.width, t.height, t.dc.matrix, t.anchor.x, t.anchor.y, t.texture) } } lc(t) { return t.ps[this.Gi.uid] || this.mc(t) } mc(t) { const s = new mc; return s.renderable = t, t.ps[this.Gi.uid] = s, s } fc(t) { const s = this.lc(t), { geometry: i } = s, e = t.texture.source.style; "repeat" !== e.addressMode && (e.addressMode = "repeat", e.update()), function (t, s) { const i = t.texture, e = i.frame.width, n = i.frame.height; let r = 0, o = 0; t.applyAnchorToTexture && (r = t.anchor.x, o = t.anchor.y), s[0] = s[6] = -r, s[2] = s[4] = 1 - r, s[1] = s[3] = -o, s[5] = s[7] = 1 - o; const h = w.shared; h.copyFrom(t.dc.matrix), h.tx /= t.width, h.ty /= t.height, h.invert(), h.scale(t.width / e, t.height / n), function (t, s, i, e) { let n = 0; const r = t.length / 2, o = e.a, h = e.b, a = e.c, u = e.d, l = e.tx, c = e.ty; for (i *= 2; n < r;) { const s = t[i], e = t[i + 1]; t[i] = o * s + a * e + l, t[i + 1] = h * s + u * e + c, i += 2, n++ } }(s, 0, 0, h) }(t, i.uvs), function (t, s) { const i = t.anchor.x, e = t.anchor.y; s[0] = -i * t.width, s[1] = -e * t.height, s[2] = (1 - i) * t.width, s[3] = -e * t.height, s[4] = (1 - i) * t.width, s[5] = (1 - e) * t.height, s[6] = -i * t.width, s[7] = (1 - e) * t.height }(t, i.positions) } destroy() { this.Gi = null } cc(t) { const s = this.lc(t), i = t.texture; let e = !0; return this.Gi.type === Zi.WEBGL && (e = this.Gi.context.supports.nonPowOf2wrapping), s.canBatch = i.textureMatrix.isSimple && (e || i.source.isPowerOfTwo), s.canBatch } } gc.extension = { type: [r.WebGLPipes, r.WebGPUPipes, r.CanvasPipes], name: "tilingSprite" }; const vc = { name: "local-uniform-msdf-bit", vertex: { header: "\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32,\n                uRound:f32,\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        ", main: "\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        ", end: "\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        " }, fragment: { header: "\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n         ", main: "\n            outColor = vec4<f32>(calculateMSDFAlpha(outColor, localUniforms.uColor, localUniforms.uDistance));\n        " } }, bc = { name: "local-uniform-msdf-bit", vertex: { header: "\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        ", main: "\n            vColor *= uColor;\n            modelMatrix *= uTransformMatrix;\n        ", end: "\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        " }, fragment: { header: "\n            uniform float uDistance;\n         ", main: "\n            outColor = vec4(calculateMSDFAlpha(outColor, vColor, uDistance));\n        " } }, xc = { name: "msdf-bit", fragment: { header: "\n            fn calculateMSDFAlpha(msdfColor:vec4<f32>, shapeColor:vec4<f32>, distance:f32) -> f32 {\n\n                // MSDF\n                var median = msdfColor.r + msdfColor.g + msdfColor.b -\n                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n\n                // SDF\n                median = min(median, msdfColor.a);\n\n                var screenPxDistance = distance * (median - 0.5);\n                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                // Gamma correction for coverage-like alpha\n                var luma: f32 = dot(shapeColor.rgb, vec3<f32>(0.299, 0.587, 0.114));\n                var gamma: f32 = mix(1.0, 1.0 / 2.2, luma);\n                var coverage: f32 = pow(shapeColor.a * alpha, gamma);\n\n                return coverage;\n\n            }\n        " } }, yc = { name: "msdf-bit", fragment: { header: "\n            float calculateMSDFAlpha(vec4 msdfColor, vec4 shapeColor, float distance) {\n\n                // MSDF\n                float median = msdfColor.r + msdfColor.g + msdfColor.b -\n                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n\n                // SDF\n                median = min(median, msdfColor.a);\n\n                float screenPxDistance = distance * (median - 0.5);\n                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n\n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                // Gamma correction for coverage-like alpha\n                float luma = dot(shapeColor.rgb, vec3(0.299, 0.587, 0.114));\n                float gamma = mix(1.0, 1.0 / 2.2, luma);\n                float coverage = pow(shapeColor.a * alpha, gamma);\n\n                return coverage;\n            }\n        " } }; let wc, Mc; class Tc extends Qi { constructor(t) { const s = new Yi({ uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" }, uTransformMatrix: { value: new w, type: "mat3x3<f32>" }, uDistance: { value: 4, type: "f32" }, uRound: { value: 0, type: "f32" } }); wc ?? (wc = lr({ name: "sdf-shader", bits: [fr, vr(t), vc, xc, wr] })), Mc ?? (Mc = cr({ name: "sdf-shader", bits: [dr, yr(t), bc, yc, Mr] })), super({ glProgram: Mc, gpuProgram: wc, resources: { localUniforms: s, batchSamplers: Ar(t) } }) } } class Ac extends dh { destroy() { this.context.customShader && this.context.customShader.destroy(), super.destroy() } } class Cc { constructor(t) { this.Gi = t } validateRenderable(t) { const s = this.gc(t); return this.Gi.renderPipes.graphics.validateRenderable(s) } addRenderable(t, s) { const i = this.gc(t); _c(t, i), t.Ho && (t.Ho = !1, this.vc(t, i)), this.Gi.renderPipes.graphics.addRenderable(i, s), i.context.customShader && this.bc(t) } updateRenderable(t) { const s = this.gc(t); _c(t, s), this.Gi.renderPipes.graphics.updateRenderable(s), s.context.customShader && this.bc(t) } vc(t, s) { const { context: i } = s, e = Wo.getFont(t.text, t.L); i.clear(), "none" !== e.distanceField.type && (i.customShader || (i.customShader = new Tc(this.Gi.limits.maxBatchableTextures))); const n = rn.graphemeSegmenter(t.text), r = t.L; let o = e.baseLineOffset; const h = Vo(n, r, e, !0), a = r.padding, u = h.scale; let l = h.width, c = h.height + h.offsetY; r.un && (l += r.un.width / u, c += r.un.width / u), i.translate(-t.xs.M * l - a, -t.xs.T * c - a).scale(u, u); const f = e.applyFillAsTint ? r.kr.color : 16777215; let d = e.fontMetrics.fontSize, p = e.lineHeight; r.lineHeight && (d = r.fontSize / u, p = r.lineHeight / u); let m = (p - d) / 2; m - e.baseLineOffset < 0 && (m = 0); for (let g = 0; g < h.lines.length; g++) { const t = h.lines[g]; for (let s = 0; s < t.charPositions.length; s++) { const n = t.chars[s], r = e.chars[n]; if (r?.texture) { const e = r.texture; i.texture(e, f || "black", Math.round(t.charPositions[s] + r.xOffset), Math.round(o + r.yOffset + m), e.orig.width, e.orig.height) } } o += p } } gc(t) { return t.ps[this.Gi.uid] || this.initGpuText(t) } initGpuText(t) { const s = new Ac; return t.ps[this.Gi.uid] = s, this.vc(t, s), s } bc(t) { const s = this.gc(t).context, i = t.L.fontFamily, e = Ds.get(`${i}-bitmap`), { a: n, b: r, c: o, d: h } = t.groupTransform, a = Math.sqrt(n * n + r * r), u = Math.sqrt(o * o + h * h), l = (Math.abs(a) + Math.abs(u)) / 2, c = e.baseRenderedFontSize / t.L.fontSize, f = l * e.distanceField.range * (1 / c); s.customShader.resources.localUniforms.uniforms.uDistance = f } destroy() { this.Gi = null } } function _c(t, s) { s.groupTransform = t.groupTransform, s.groupColorAlpha = t.groupColorAlpha, s.groupColor = t.groupColor, s.groupBlendMode = t.groupBlendMode, s.globalDisplayStatus = t.globalDisplayStatus, s.groupTransform = t.groupTransform, s.localDisplayStatus = t.localDisplayStatus, s.groupAlpha = t.groupAlpha, s.fs = t.fs } Cc.extension = { type: [r.WebGLPipes, r.WebGPUPipes, r.CanvasPipes], name: "bitmapText" }; class Sc extends uu { constructor(t) { super(), this.generatingTexture = !1, this.currentKey = "--", this.Gi = t, t.runners.resolutionChange.add(this) } resolutionChange() { const t = this.renderable; t.Wo && t.onViewUpdate() } destroy() { const { htmlText: t } = this.Gi; null === t.getReferenceCount(this.currentKey) ? t.returnTexturePromise(this.texturePromise) : t.decreaseReferenceCount(this.currentKey), this.Gi.runners.resolutionChange.remove(this), this.texturePromise = null, this.Gi = null } } function Pc(t, s) { const { texture: i, bounds: e } = t, n = s.L.Er(); Q(e, s.xs, i); const r = s.xs.M * n * 2, o = s.xs.T * n * 2; e.minX -= n - r, e.minY -= n - o, e.maxX -= n - r, e.maxY -= n - o } class kc { constructor(t) { this.Gi = t } validateRenderable(t) { const s = this.xc(t), i = t.styleKey; return s.currentKey !== i } addRenderable(t, s) { const i = this.xc(t); if (t.Ho) { const s = t.Wo ? this.Gi.resolution : t.resolution; i.currentKey === t.styleKey && t.resolution === s || this.yc(t).catch(t => { }), t.Ho = !1, Pc(i, t) } this.Gi.renderPipes.batch.addToBatch(i, s) } updateRenderable(t) { const s = this.xc(t); s.In.updateElement(s) } async yc(t) { t.Ho = !1; const s = this.xc(t); if (s.generatingTexture) return; const i = s.texturePromise; s.texturePromise = null, s.generatingTexture = !0, t.G = t.Wo ? this.Gi.resolution : t.resolution; let e = this.Gi.htmlText.getTexturePromise(t); i && (e = e.finally(() => { this.Gi.htmlText.decreaseReferenceCount(s.currentKey), this.Gi.htmlText.returnTexturePromise(i) })), s.texturePromise = e, s.currentKey = t.styleKey, s.texture = await e; const n = t.renderGroup || t.parentRenderGroup; n && (n.structureDidChange = !0), s.generatingTexture = !1, Pc(s, t) } xc(t) { return t.ps[this.Gi.uid] || this.initGpuText(t) } initGpuText(t) { const s = new Sc(this.Gi); return s.renderable = t, s.transform = t.groupTransform, s.texture = Z.EMPTY, s.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 }, s.roundPixels = this.Gi.fs | t.fs, t.G = t.Wo ? this.Gi.resolution : t.resolution, t.ps[this.Gi.uid] = s, s } destroy() { this.Gi = null } } kc.extension = { type: [r.WebGLPipes, r.WebGPUPipes, r.CanvasPipes], name: "htmlText" }; const Fc = new tt; function Ec(t, s, i, e) { const n = Fc; n.minX = 0, n.minY = 0, n.maxX = t.width / e | 0, n.maxY = t.height / e | 0; const r = fs.getOptimalTexture(n.width, n.height, e, !1); return r.source.uploadMethodId = "image", r.source.resource = t, r.source.alphaMode = "premultiply-alpha-on-upload", r.frame.width = s / e, r.frame.height = i / e, r.source.emit("update", r.source), r.updateUvs(), r } const Rc = new Map; class Oc { constructor(t) { this.wc = {}, this.Gi = t, this.Mc = t.type === Zi.WEBGPU } getTexture(t) { return this.getTexturePromise(t) } getManagedTexture(t) { const s = t.styleKey; if (this.wc[s]) return this.Tc(s), this.wc[s].promise; const i = this.Ac(t).then(t => (this.wc[s].texture = t, t)); return this.wc[s] = { texture: null, promise: i, usageCount: 1 }, i } getReferenceCount(t) { return this.wc[t]?.usageCount ?? null } Tc(t) { this.wc[t].usageCount++ } decreaseReferenceCount(t) { const s = this.wc[t]; s && (s.usageCount--, 0 === s.usageCount && (s.texture ? this.Cc(s.texture) : s.promise.then(t => { s.texture = t, this.Cc(s.texture) }).catch(() => { Et() }), this.wc[t] = null)) } getTexturePromise(t) { return this.Ac(t) } async Ac(t) { const { text: s, style: i, resolution: e, textureStyle: n } = t, r = Ut.get(Sh), o = function (t, s) { const i = s.fontFamily, e = [], n = {}, r = t.match(/font-family:([^;"\s]+)/g); function o(t) { n[t] || (e.push(t), n[t] = !0) } if (Array.isArray(i)) for (let h = 0; h < i.length; h++)o(i[h]); else o(i); r && r.forEach(t => { o(t.split(":")[1].trim()) }); for (const h in s.tagStyles) o(s.tagStyles[h].fontFamily); return e }(s, i), h = await async function (t) { const s = t.filter(t => Ds.has(`${t}-and-url`)).map(t => { if (!Rc.has(t)) { const { entries: s } = Ds.get(`${t}-and-url`), i = []; s.forEach(s => { const e = s.url, n = s.faces.map(t => ({ weight: t.weight, style: t.style })); i.push(...n.map(s => async function (t, s) { const i = await async function (t) { const s = await ks.get().fetch(t), i = await s.blob(), e = new FileReader; return await new Promise((t, s) => { e.onloadend = () => t(e.result), e.onerror = s, e.readAsDataURL(i) }) }(s); return `@font-face {\n        font-family: "${t.fontFamily}";\n        font-weight: ${t.fontWeight};\n        font-style: ${t.fontStyle};\n        src: url('${i}');\n    }` }({ fontWeight: s.weight, fontStyle: s.style, fontFamily: t }, e))) }), Rc.set(t, Promise.all(i).then(t => t.join("\n"))) } return Rc.get(t) }); return (await Promise.all(s)).join("\n") }(o), a = function (t, s, i, e) { e || (e = Ph || (Ph = new Sh)); const { domElement: n, styleElement: r, svgRoot: o } = e; n.innerHTML = `<style>${s.cssStyle};</style><div style='padding:0'>${t}</div>`, n.setAttribute("style", "transform-origin: top left; display: inline-block"), i && (r.textContent = i), document.body.appendChild(o); const h = n.getBoundingClientRect(); o.remove(); const a = 2 * s.padding; return { width: h.width - a, height: h.height - a } }(s, i, h, r), u = Math.ceil(Math.ceil(Math.max(1, a.width) + 2 * i.padding) * e), l = Math.ceil(Math.ceil(Math.max(1, a.height) + 2 * i.padding) * e), c = r.image; c.width = 2 + (0 | u), c.height = 2 + (0 | l); const f = function (t, s, i, e, n) { const { domElement: r, styleElement: o, svgRoot: h } = n; r.innerHTML = `<style>${s.cssStyle}</style><div style='padding:0;'>${t}</div>`, r.setAttribute("style", `transform: scale(${i});transform-origin: top left; display: inline-block`), o.textContent = e; const { width: a, height: u } = n.image; return h.setAttribute("width", a.toString()), h.setAttribute("height", u.toString()), (new XMLSerializer).serializeToString(h) }(s, i, e, h, r); await function (t, s, i) { return new Promise(async e => { i && await new Promise(t => setTimeout(t, 100)), t.onload = () => { e() }, t.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(s)}`, t.crossOrigin = "anonymous" }) }(c, f, function () { const { userAgent: t } = ks.get().getNavigator(); return /^((?!chrome|android).)*safari/i.test(t) }() && o.length > 0); const d = c; let p; this.Mc && (p = function (t, s) { const i = $o.getOptimalCanvasAndContext(t.width, t.height, s), { context: e } = i; return e.clearRect(0, 0, t.width, t.height), e.drawImage(t, 0, 0), i }(c, e)); const m = Ec(p ? p.canvas : d, c.width - 2, c.height - 2, e); return n && (m.source.style = n), this.Mc && (this.Gi.texture.initSource(m.source), $o.returnCanvasAndContext(p)), Ut.return(r), m } returnTexturePromise(t) { t.then(t => { this.Cc(t) }).catch(() => { Et() }) } Cc(t) { fs.returnTexture(t, !0), t.source.resource = null, t.source.uploadMethodId = "unknown" } destroy() { this.Gi = null; for (const t in this.wc) this.wc[t] && this.returnTexturePromise(this.wc[t].promise); this.wc = null } } Oc.extension = { type: [r.WebGLSystem, r.WebGPUSystem, r.CanvasSystem], name: "htmlText" }; class Uc extends uu { constructor(t) { super(), this.Gi = t, t.runners.resolutionChange.add(this) } resolutionChange() { const t = this.renderable; t.Wo && t.onViewUpdate() } destroy() { const { canvasText: t } = this.Gi; t.getReferenceCount(this.currentKey) > 0 ? t.decreaseReferenceCount(this.currentKey) : this.texture && t.returnTexture(this.texture), this.Gi.runners.resolutionChange.remove(this), this.Gi = null } } class Ic { constructor(t) { this.Gi = t } validateRenderable(t) { const s = this.xc(t), i = t.styleKey; return s.currentKey !== i || t.Ho } addRenderable(t, s) { const i = this.xc(t); if (t.Ho) { const s = t.Wo ? this.Gi.resolution : t.resolution; i.currentKey === t.styleKey && t.resolution === s || this.yc(t), t.Ho = !1, Pc(i, t) } this.Gi.renderPipes.batch.addToBatch(i, s) } updateRenderable(t) { const s = this.xc(t); s.In.updateElement(s) } yc(t) { const s = this.xc(t); s.texture && this.Gi.canvasText.decreaseReferenceCount(s.currentKey), t.G = t.Wo ? this.Gi.resolution : t.resolution, s.texture = this.Gi.canvasText.getManagedTexture(t), s.currentKey = t.styleKey } xc(t) { return t.ps[this.Gi.uid] || this.initGpuText(t) } initGpuText(t) { const s = new Uc(this.Gi); return s.currentKey = "--", s.renderable = t, s.transform = t.groupTransform, s.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 }, s.roundPixels = this.Gi.fs | t.fs, t.ps[this.Gi.uid] = s, s } destroy() { this.Gi = null } } Ic.extension = { type: [r.WebGLPipes, r.WebGPUPipes, r.CanvasPipes], name: "text" }; class Bc { constructor(t) { this.wc = {}, this.Gi = t } getTexture(t, s, i, e) { "string" == typeof t && ($(0, "CanvasTextSystem.getTexture: Use object TextOptions instead of separate arguments"), t = { text: t, style: i, resolution: s }), t.style instanceof Go || (t.style = new Go(t.style)), t.textureStyle instanceof W || (t.textureStyle = new W(t.textureStyle)), "string" != typeof t.text && (t.text = t.text.toString()); const { text: n, style: r, textureStyle: o } = t, h = t.resolution ?? this.Gi.resolution, { frame: a, canvasAndContext: u } = Th.getCanvasAndContext({ text: n, style: r, resolution: h }), l = Ec(u.canvas, a.width, a.height, h); if (o && (l.source.style = o), r.trim && (a.pad(r.padding), l.frame.copyFrom(a), l.frame.scale(1 / h), l.updateUvs()), r.filters) { const t = this._c(l, r.filters); return this.returnTexture(l), Th.returnCanvasAndContext(u), t } return this.Gi.texture.initSource(l.K), Th.returnCanvasAndContext(u), l } returnTexture(t) { const s = t.source; s.resource = null, s.uploadMethodId = "unknown", s.alphaMode = "no-premultiply-alpha", fs.returnTexture(t, !0) } renderTextToCanvas() { $(0, "CanvasTextSystem.renderTextToCanvas: no longer supported, use CanvasTextSystem.getTexture instead") } getManagedTexture(t) { t.G = t.Wo ? this.Gi.resolution : t.resolution; const s = t.styleKey; if (this.wc[s]) return this.Tc(s), this.wc[s].texture; const i = this.getTexture({ text: t.text, style: t.style, resolution: t.G, textureStyle: t.textureStyle }); return this.wc[s] = { texture: i, usageCount: 1 }, i } decreaseReferenceCount(t) { const s = this.wc[t]; s.usageCount--, 0 === s.usageCount && (this.returnTexture(s.texture), this.wc[t] = null) } getReferenceCount(t) { return this.wc[t]?.usageCount ?? 0 } Tc(t) { this.wc[t].usageCount++ } _c(t, s) { const i = this.Gi.renderTarget.renderTarget, e = this.Gi.filter.generateFilteredTexture({ texture: t, filters: s }); return this.Gi.renderTarget.bind(i, !1), e } destroy() { this.Gi = null; for (const t in this.wc) this.wc[t] && this.returnTexture(this.wc[t].texture); this.wc = null } } Bc.extension = { type: [r.WebGLSystem, r.WebGPUSystem, r.CanvasSystem], name: "canvasText" }, a.add(u, l); var Gc = Object.defineProperty, $c = (t, s, i) => (((t, s, i) => { s in t ? Gc(t, s, { enumerable: !0, configurable: !0, writable: !0, value: i }) : t[s] = i })(t, "symbol" != typeof s ? s + "" : s, i), i); const zc = class t extends ee { constructor(s) { const i = (s = { ...t.DEFAULT_OPTIONS, ...s }).distance ?? 10, e = s.quality ?? .1; super({ gpuProgram: Ni.from({ vertex: { source: "struct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>\n  };\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \n}\n\nfn getSize() -> vec2<f32>\n{\n  return gfu.uGlobalFrame.zw;\n}\n  \n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition)\n  );\n}", entryPoint: "mainVertex" }, fragment: { source: "struct GlowUniforms {\n  uDistance: f32,\n  uStrength: vec2<f32>,\n  uColor: vec3<f32>,\n  uAlpha: f32,\n  uQuality: f32,\n  uKnockout: f32,\n};\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> glowUniforms : GlowUniforms;\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n  let quality = glowUniforms.uQuality;\n  let distance = glowUniforms.uDistance;\n\n  let dist: f32 = glowUniforms.uDistance;\n  let angleStepSize: f32 = min(1. / quality / distance, PI * 2.0);\n  let angleStepNum: f32 = ceil(PI * 2.0 / angleStepSize);\n\n  let px: vec2<f32> = vec2<f32>(1.0 / gfu.uInputSize.xy);\n\n  var totalAlpha: f32 = 0.0;\n\n  var direction: vec2<f32>;\n  var displaced: vec2<f32>;\n  var curColor: vec4<f32>;\n\n  for (var angle = 0.0; angle < PI * 2.0; angle += angleStepSize) {\n    direction = vec2<f32>(cos(angle), sin(angle)) * px;\n    for (var curDistance = 0.0; curDistance < dist; curDistance+=1) {\n      displaced = vec2<f32>(clamp(uv + direction * (curDistance + 1.0), gfu.uInputClamp.xy, gfu.uInputClamp.zw));\n      curColor = textureSample(uTexture, uSampler, displaced);\n      totalAlpha += (dist - curDistance) * curColor.a;\n    }\n  }\n    \n  curColor = textureSample(uTexture, uSampler, uv);\n\n  let glowColorRGB = glowUniforms.uColor;\n  let glowAlpha = glowUniforms.uAlpha;\n  let glowColor = vec4<f32>(glowColorRGB, glowAlpha);\n  let knockout: bool = glowUniforms.uKnockout > 0.5;\n  let innerStrength = glowUniforms.uStrength[0];\n  let outerStrength = glowUniforms.uStrength[1];\n\n  let alphaRatio: f32 = (totalAlpha / (angleStepNum * dist * (dist + 1.0) / 2.0));\n  let innerGlowAlpha: f32 = (1.0 - alphaRatio) * innerStrength * curColor.a * glowAlpha;\n  let innerGlowStrength: f32 = min(1.0, innerGlowAlpha);\n  \n  let innerColor: vec4<f32> = mix(curColor, glowColor, innerGlowStrength);\n  let outerGlowAlpha: f32 = alphaRatio * outerStrength * (1. - curColor.a) * glowAlpha;\n  let outerGlowStrength: f32 = min(1.0 - innerColor.a, outerGlowAlpha);\n  let outerGlowColor: vec4<f32> = outerGlowStrength * glowColor.rgba;\n  \n  if (knockout) {\n    let resultAlpha: f32 = outerGlowAlpha + innerGlowAlpha;\n    return vec4<f32>(glowColor.rgb * resultAlpha, resultAlpha);\n  }\n  else {\n    return innerColor + outerGlowColor;\n  }\n}\n\nconst PI: f32 = 3.14159265358979323846264;", entryPoint: "mainFragment" } }), glProgram: Gi.from({ vertex: "in vec2 aPosition;\nout vec2 vTextureCoord;\n\nuniform vec4 uInputSize;\nuniform vec4 uOutputFrame;\nuniform vec4 uOutputTexture;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\n    \n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n", fragment: "precision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform vec2 uStrength;\nuniform vec3 uColor;\nuniform float uKnockout;\nuniform float uAlpha;\n\nuniform vec4 uInputSize;\nuniform vec4 uInputClamp;\n\nconst float PI = 3.14159265358979323846264;\n\n// Hard-assignment of DIST and ANGLE_STEP_SIZE instead of using uDistance and uQuality to allow them to be use on GLSL loop conditions\nconst float DIST = __DIST__;\nconst float ANGLE_STEP_SIZE = min(__ANGLE_STEP_SIZE__, PI * 2.);\nconst float ANGLE_STEP_NUM = ceil(PI * 2. / ANGLE_STEP_SIZE);\nconst float MAX_TOTAL_ALPHA = ANGLE_STEP_NUM * DIST * (DIST + 1.) / 2.;\n\nvoid main(void) {\n    vec2 px = vec2(1.) / uInputSize.xy;\n\n    float totalAlpha = 0.;\n\n    vec2 direction;\n    vec2 displaced;\n    vec4 curColor;\n\n    for (float angle = 0.; angle < PI * 2.; angle += ANGLE_STEP_SIZE) {\n      direction = vec2(cos(angle), sin(angle)) * px;\n\n      for (float curDistance = 0.; curDistance < DIST; curDistance++) {\n          displaced = clamp(vTextureCoord + direction * (curDistance + 1.), uInputClamp.xy, uInputClamp.zw);\n          curColor = texture(uTexture, displaced);\n          totalAlpha += (DIST - curDistance) * curColor.a;\n      }\n    }\n    \n    curColor = texture(uTexture, vTextureCoord);\n\n    vec4 glowColor = vec4(uColor, uAlpha);\n    bool knockout = uKnockout > .5;\n    float innerStrength = uStrength[0];\n    float outerStrength = uStrength[1];\n\n    float alphaRatio = totalAlpha / MAX_TOTAL_ALPHA;\n    float innerGlowAlpha = (1. - alphaRatio) * innerStrength * curColor.a * uAlpha;\n    float innerGlowStrength = min(1., innerGlowAlpha);\n    \n    vec4 innerColor = mix(curColor, glowColor, innerGlowStrength);\n    float outerGlowAlpha = alphaRatio * outerStrength * (1. - curColor.a) * uAlpha;\n    float outerGlowStrength = min(1. - innerColor.a, outerGlowAlpha);\n    vec4 outerGlowColor = outerGlowStrength * glowColor.rgba;\n\n    if (knockout) {\n      float resultAlpha = outerGlowAlpha + innerGlowAlpha;\n      finalColor = vec4(glowColor.rgb * resultAlpha, resultAlpha);\n    }\n    else {\n      finalColor = innerColor + outerGlowColor;\n    }\n}\n".replace(/__ANGLE_STEP_SIZE__/gi, `${(1 / e / i).toFixed(7)}`).replace(/__DIST__/gi, `${i.toFixed(0)}.0`), name: "glow-filter" }), resources: { glowUniforms: { uDistance: { value: i, type: "f32" }, uStrength: { value: [s.innerStrength, s.outerStrength], type: "vec2<f32>" }, uColor: { value: new Float32Array(3), type: "vec3<f32>" }, uAlpha: { value: s.alpha, type: "f32" }, uQuality: { value: e, type: "f32" }, uKnockout: { value: s?.knockout ? 1 : 0, type: "f32" } } }, padding: i }), $c(this, "uniforms"), $c(this, "_color"), this.uniforms = this.resources.glowUniforms.uniforms, this.Sc = new kt, this.color = s.color ?? 16777215 } get distance() { return this.uniforms.uDistance } set distance(t) { this.uniforms.uDistance = this.padding = t } get innerStrength() { return this.uniforms.uStrength[0] } set innerStrength(t) { this.uniforms.uStrength[0] = t } get outerStrength() { return this.uniforms.uStrength[1] } set outerStrength(t) { this.uniforms.uStrength[1] = t } get color() { return this.Sc.value } set color(t) { this.Sc.setValue(t); const [s, i, e] = this.Sc.toArray(); this.uniforms.uColor[0] = s, this.uniforms.uColor[1] = i, this.uniforms.uColor[2] = e } get alpha() { return this.uniforms.uAlpha } set alpha(t) { this.uniforms.uAlpha = t } get quality() { return this.uniforms.uQuality } set quality(t) { this.uniforms.uQuality = t } get knockout() { return 1 === this.uniforms.uKnockout } set knockout(t) { this.uniforms.uKnockout = t ? 1 : 0 } }; $c(zc, "DEFAULT_OPTIONS", { distance: 10, outerStrength: 4, innerStrength: 0, color: 16777215, alpha: 1, quality: .1, knockout: !1 }); let Dc = zc; const jc = 22, Lc = "#00DB00", Vc = "#ffffff", Nc = "#ffffff", Wc = { background: "#000000", resizeTo: window, resolution: window.devicePixelRatio || 1, autoDensity: !0, antialias: !1 }, Hc = { distance: 4, outerStrength: 1, color: "#b6ffb6ff", quality: .5 }; function qc(t, s) { return Math.random() * (s - t) + t } class Xc { constructor(t, i, e, n, r) { s(this, "x"), s(this, "screenHeight"), s(this, "particles", []), s(this, "heads", []), s(this, "textures"), s(this, "headTextures"), s(this, "container"), s(this, "totalRows", 0), s(this, "screenRows", 0), s(this, "restartDelay", 0), s(this, "columnCompleted", !1), s(this, "maxLength", 0), s(this, "alphaStep", 0), s(this, "particleShuffleTimers", new Map), s(this, "minParticleShuffleTime", 6), s(this, "maxParticleShuffleTime", 60); const o = i * (qc(30, 80) / 100); this.x = t, this.screenHeight = i, this.container = e, this.textures = n, this.headTextures = r, this.screenRows = Math.floor(i / jc), this.maxLength = Math.floor(o / jc), this.alphaStep = 1 / this.maxLength, this.totalRows = this.screenRows + this.maxLength, this.particles = new Array(this.totalRows).fill(null), this.restartDelay = qc(0, 100) } getRandomTexture() { return this.textures[Math.floor(Math.random() * this.textures.length)] } getRandomHeadTexture() { return this.headTextures[Math.floor(Math.random() * this.headTextures.length)] } canCreateNewHead() { if (0 === this.heads.length) return !0; const t = this.heads.reduce((t, s) => !t || s.index < t.index ? s : t, null); if (!t) return !0; const s = Math.max(0, t.index - t.maxLength), i = Math.abs(0 - s); return i >= 1 && i <= 10 } createHead() { if (this.heads.length >= 2) return; if (!this.canCreateNewHead()) return; const t = this.getRandomHeadTexture(), s = new ys(t); s.x = this.x, s.y = -22, s.alpha = 1, s.tint = Vc, s.label = "head", this.container.addChild(s); const i = { sprite: s, index: 0, length: 1, moveCounter: 0, shuffleCounter: 0, moveDelay: 60 * qc(.02, .1), maxLength: Math.floor(this.screenHeight * qc(30, 80) / 100 / jc), alphaStep: 0, particles: new Array(this.totalRows).fill(null) }; i.alphaStep = 1 / i.maxLength, i.particles[0] = s, this.heads.push(i) } moveHead(t) { if (!t.sprite) return; const s = t.index + 1, i = this.heads.filter(s => s !== t); for (const r of i) { const i = Math.abs(s - r.index), e = Math.max(0, r.index - r.maxLength), n = Math.abs(s - e); if (i < 5 || n < 5) return void (t.moveDelay = Math.min(1.5 * t.moveDelay, 18)) } const e = t.index, n = t.sprite; if (e > 0) { const s = this.getRandomHeadTexture(), i = new ys(s), r = t.length - 1; i.x = this.x, i.y = n.y, i.tint = Lc, i.alpha = Math.max(0, 1 - t.alphaStep * r), this.particleShuffleTimers.set(i, qc(this.minParticleShuffleTime, this.maxParticleShuffleTime)), this.container.addChild(i), t.particles[e] = i } if (n.y += jc, t.index = s, n.tint = Vc, t.length >= t.maxLength) { const i = s - t.maxLength; i >= 0 && t.particles[i] && t.particles[i] !== t.sprite && (this.container.removeChild(t.particles[i]), t.particles[i] = null) } else t.length++; if (t.particles[s] && this.container.removeChild(t.particles[s]), t.particles[s] = n, s >= this.totalRows - 1) { this.container.removeChild(n); for (let s = 0; s < t.particles.length; s++)t.particles[s] && this.container.removeChild(t.particles[s]); this.heads = this.heads.filter(s => s !== t) } } update(t) { if (this.restartDelay > 0) this.restartDelay -= t.deltaTime; else { Math.random() < .005 && this.createHead(); for (let s = this.heads.length - 1; s >= 0; s--) { const i = this.heads[s]; i.shuffleCounter += t.deltaTime, i.shuffleCounter > 10 && (i.shuffleCounter = 0, i.sprite.texture = this.getRandomHeadTexture(), i.sprite.tint = Vc), i.moveCounter += t.deltaTime, i.moveCounter > i.moveDelay && (i.moveCounter = 0, this.moveHead(i), i.moveDelay = 60 * qc(.02, .1)); for (let s = 0; s < i.particles.length; s++) { const e = i.particles[s]; if (e && e !== i.sprite) { const n = i.index - s; if (n > 0 && (e.alpha = Math.max(.1, 1 - i.alphaStep * n)), this.particleShuffleTimers.has(e)) { let s = this.particleShuffleTimers.get(e) - t.deltaTime; s <= 0 && (e.texture = this.getRandomTexture(), e.tint = Lc, s = qc(this.minParticleShuffleTime, this.maxParticleShuffleTime)), this.particleShuffleTimers.set(e, s) } } } } this.cleanupShuffleTimers(), 0 !== this.heads.length || this.columnCompleted || (this.columnCompleted = !0, this.restartDelay = qc(30, 180)) } } cleanupShuffleTimers() { const t = []; this.particleShuffleTimers.forEach((s, i) => { let e = !1; for (const t of this.heads) if (t.particles.includes(i)) { e = !0; break } e || t.push(i) }), t.forEach(t => { this.particleShuffleTimers.delete(t) }) } } class Yc { constructor(t) { s(this, "app"), s(this, "particleContainer"), s(this, "columns", []), s(this, "textures", []), s(this, "headTextures", []), s(this, "update", t => { this.columns.forEach(s => s.update(t)) }), this.app = t, this.particleContainer = new bs, t.stage.addChild(this.particleContainer), this.generateTextures(), this.createColumns(), t.ticker.add(t => { this.update(t) }) } generateTextures() { const t = "      "; for (let s = 0; s < 100; s++) { const i = new Ah({ text: t[s], style: { fontFamily: "monospace", fontSize: jc, fill: Lc, dropShadow: { color: Nc, blur: 10, distance: 8, angle: Math.PI / 2 } } }); this.textures.push(this.app.renderer.generateTexture(i)) } for (let s = 0; s < 100; s++) { const i = new Ah({ text: t[s], style: { fontFamily: "monospace", fontSize: jc, fill: Vc, dropShadow: { color: Nc, blur: 10, distance: 8, angle: Math.PI / 2 } } }); this.headTextures.push(this.app.renderer.generateTexture(i)) } } createColumns() { const t = this.app.renderer.width, s = Math.floor(t / jc); for (let i = 0; i < s; i++) { const t = new Xc(i * jc, this.app.renderer.height, this.particleContainer, this.textures, this.headTextures); this.columns.push(t) } } reset() { this.particleContainer.removeChildren(), this.columns = [], this.createColumns() } } (async () => { const t = new Xe; await t.init(Wc), document.getElementById("matrix-rain").appendChild(t.canvas), t.stage.filters = [new Dc(Hc)]; const s = new Yc(t); window.addEventListener("keyup", t => { "r" !== t.key && "R" !== t.key || s.reset() }), window.addEventListener("resize", () => { s.reset() }) })(), a.add(Ai), a.mixin(bs, { accessible: !1, accessibleTitle: null, accessibleHint: null, tabIndex: 0, accessibleType: "button", accessibleText: null, accessiblePointerEvents: "auto", accessibleChildren: !0, de: !1, fe: null, Yi: -1 }), a.add(Ye), a.add(Ke), a.add(ih), a.mixin(bs, eh), a.add(Ho), a.add(Vl), a.add(Jr), a.add(Xl), a.add(ec), a.add(nc), a.add(Bc), a.add(Ic), a.add(Cc), a.add(Oc), a.add(kc), a.add(gc), a.add(ac), a.add(lh), a.add(oh); const Kc = Object.freeze(Object.defineProperty({ __proto__: null }, Symbol.toStringTag, { value: "Module" })), Zc = Object.freeze(Object.defineProperty({ __proto__: null }, Symbol.toStringTag, { value: "Module" }));
