var t = Object.defineProperty, s = (s, e, i) => ((s, e, i) => e in s ? t(s, e, { enumerable: !0, configurable: !0, writable: !0, value: i }) : s[e] = i)(s, "symbol" != typeof e ? e + "" : e, i); const e = function () { const t = "undefined" != typeof document && document.createElement("link").relList; return t && t.supports && t.supports("modulepreload") ? "modulepreload" : "preload" }(), i = {}, n = function (t, s, n) { let r = Promise.resolve(); if (s && s.length > 0) { let t = function (t) { return Promise.all(t.map(t => Promise.resolve(t).then(t => ({ status: "fulfilled", value: t }), t => ({ status: "rejected", reason: t })))) }; const o = document.getElementsByTagName("link"), h = document.querySelector("meta[property=csp-nonce]"), a = h?.nonce || h?.getAttribute("nonce"); r = t(s.map(t => { if (t = function (t, s) { return new URL(t, s).href }(t, n), t in i) return; i[t] = !0; const s = t.endsWith(".css"), r = s ? '[rel="stylesheet"]' : ""; if (n) for (let e = o.length - 1; e >= 0; e--) { const i = o[e]; if (i.href === t && (!s || "stylesheet" === i.rel)) return } else if (document.querySelector(`link[href="${t}"]${r}`)) return; const h = document.createElement("link"); return h.rel = s ? "stylesheet" : e, s || (h.as = "script"), h.crossOrigin = "", h.href = t, a && h.setAttribute("nonce", a), document.head.appendChild(h), s ? new Promise((s, e) => { h.addEventListener("load", s), h.addEventListener("error", () => e(new Error(`Unable to preload CSS for ${t}`))) }) : void 0 })) } function o(t) { const s = new Event("vite:preloadError", { cancelable: !0 }); if (s.payload = t, window.dispatchEvent(s), !s.defaultPrevented) throw t } return r.then(s => { for (const t of s || []) "rejected" === t.status && o(t.reason); return t().catch(o) }) }; var r = (t => (t.Application = "application", t.WebGLPipes = "webgl-pipes", t.WebGLPipesAdaptor = "webgl-pipes-adaptor", t.WebGLSystem = "webgl-system", t.WebGPUPipes = "webgpu-pipes", t.WebGPUPipesAdaptor = "webgpu-pipes-adaptor", t.WebGPUSystem = "webgpu-system", t.CanvasSystem = "canvas-system", t.CanvasPipesAdaptor = "canvas-pipes-adaptor", t.CanvasPipes = "canvas-pipes", t.Asset = "asset", t.LoadParser = "load-parser", t.ResolveParser = "resolve-parser", t.CacheParser = "cache-parser", t.DetectionParser = "detection-parser", t.MaskEffect = "mask-effect", t.BlendMode = "blend-mode", t.TextureSource = "texture-source", t.Environment = "environment", t.ShapeBuilder = "shape-builder", t.Batcher = "batcher", t))(r || {}); const o = t => { if ("function" == typeof t || "object" == typeof t && t.extension) { if (!t.extension) throw new Error("Extension class must have an extension object"); t = { ..."object" != typeof t.extension ? { type: t.extension } : t.extension, ref: t } } if ("object" != typeof t) throw new Error("Invalid extension type"); return "string" == typeof (t = { ...t }).type && (t.type = [t.type]), t }, h = (t, s) => o(t).priority ?? s, a = { o: {}, u: {}, p: {}, remove(...t) { return t.map(o).forEach(t => { t.type.forEach(s => this.u[s]?.(t)) }), this }, add(...t) { return t.map(o).forEach(t => { t.type.forEach(s => { const e = this.o, i = this.p; e[s] ? e[s]?.(t) : (i[s] = i[s] || [], i[s]?.push(t)) }) }), this }, handle(t, s, e) { const i = this.o, n = this.u; if (i[t] || n[t]) throw new Error(`Extension type ${t} already has a handler`); i[t] = s, n[t] = e; const r = this.p; return r[t] && (r[t]?.forEach(t => s(t)), delete r[t]), this }, handleByMap(t, s) { return this.handle(t, t => { t.name && (s[t.name] = t.ref) }, t => { t.name && delete s[t.name] }) }, handleByNamedList(t, s, e = -1) { return this.handle(t, t => { s.findIndex(s => s.name === t.name) >= 0 || (s.push({ name: t.name, value: t.ref }), s.sort((t, s) => h(s.value, e) - h(t.value, e))) }, t => { const e = s.findIndex(s => s.name === t.name); -1 !== e && s.splice(e, 1) }) }, handleByList(t, s, e = -1) { return this.handle(t, t => { s.includes(t.ref) || (s.push(t.ref), s.sort((t, s) => h(s, e) - h(t, e))) }, t => { const e = s.indexOf(t.ref); -1 !== e && s.splice(e, 1) }) }, mixin(t, ...s) { for (const e of s) Object.defineProperties(t.prototype, Object.getOwnPropertyDescriptors(e)) } }, l = { extension: { type: r.Environment, name: "browser", priority: -1 }, test: () => !0, load: async () => { await n(() => Promise.resolve().then(() => qc), void 0, import.meta.url) } }, u = { extension: { type: r.Environment, name: "webworker", priority: 0 }, test: () => "undefined" != typeof self && void 0 !== self.WorkerGlobalScope, load: async () => { await n(() => Promise.resolve().then(() => Xc), void 0, import.meta.url) } }; class c { constructor(t, s, e) { this.M = s || 0, this.T = e || 0, this.A = t } clone(t) { return new c(t ?? this.A, this.M, this.T) } set(t = 0, s = t) { return this.M === t && this.T === s || (this.M = t, this.T = s, this.A.C(this)), this } copyFrom(t) { return this.M === t.x && this.T === t.y || (this.M = t.x, this.T = t.y, this.A.C(this)), this } copyTo(t) { return t.set(this.M, this.T), t } equals(t) { return t.x === this.M && t.y === this.T } toString() { return `[pixi.js/math:ObservablePoint x=${this.M} y=${this.T} scope=${this.A}]` } get x() { return this.M } set x(t) { this.M !== t && (this.M = t, this.A.C(this)) } get y() { return this.T } set y(t) { this.T !== t && (this.T = t, this.A.C(this)) } } function f(t) { return t && t._ && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t } var d, p = { exports: {} }; const m = f((d || (d = 1, function (t) { var s = Object.prototype.hasOwnProperty, e = "~"; function i() { } function n(t, s, e) { this.fn = t, this.context = s, this.once = e || !1 } function r(t, s, i, r, o) { if ("function" != typeof i) throw new TypeError("The listener must be a function"); var h = new n(i, r || t, o), a = e ? e + s : s; return t.P[a] ? t.P[a].fn ? t.P[a] = [t.P[a], h] : t.P[a].push(h) : (t.P[a] = h, t.k++), t } function o(t, s) { 0 === --t.k ? t.P = new i : delete t.P[s] } function h() { this.P = new i, this.k = 0 } Object.create && (i.prototype = Object.create(null), (new i).__proto__ || (e = !1)), h.prototype.eventNames = function () { var t, i, n = []; if (0 === this.k) return n; for (i in t = this.P) s.call(t, i) && n.push(e ? i.slice(1) : i); return Object.getOwnPropertySymbols ? n.concat(Object.getOwnPropertySymbols(t)) : n }, h.prototype.listeners = function (t) { var s = e ? e + t : t, i = this.P[s]; if (!i) return []; if (i.fn) return [i.fn]; for (var n = 0, r = i.length, o = new Array(r); n < r; n++)o[n] = i[n].fn; return o }, h.prototype.listenerCount = function (t) { var s = e ? e + t : t, i = this.P[s]; return i ? i.fn ? 1 : i.length : 0 }, h.prototype.emit = function (t, s, i, n, r, o) { var h = e ? e + t : t; if (!this.P[h]) return !1; var a, l, u = this.P[h], c = arguments.length; if (u.fn) { switch (u.once && this.removeListener(t, u.fn, void 0, !0), c) { case 1: return u.fn.call(u.context), !0; case 2: return u.fn.call(u.context, s), !0; case 3: return u.fn.call(u.context, s, i), !0; case 4: return u.fn.call(u.context, s, i, n), !0; case 5: return u.fn.call(u.context, s, i, n, r), !0; case 6: return u.fn.call(u.context, s, i, n, r, o), !0 }for (l = 1, a = new Array(c - 1); l < c; l++)a[l - 1] = arguments[l]; u.fn.apply(u.context, a) } else { var f, d = u.length; for (l = 0; l < d; l++)switch (u[l].once && this.removeListener(t, u[l].fn, void 0, !0), c) { case 1: u[l].fn.call(u[l].context); break; case 2: u[l].fn.call(u[l].context, s); break; case 3: u[l].fn.call(u[l].context, s, i); break; case 4: u[l].fn.call(u[l].context, s, i, n); break; default: if (!a) for (f = 1, a = new Array(c - 1); f < c; f++)a[f - 1] = arguments[f]; u[l].fn.apply(u[l].context, a) } } return !0 }, h.prototype.on = function (t, s, e) { return r(this, t, s, e, !1) }, h.prototype.once = function (t, s, e) { return r(this, t, s, e, !0) }, h.prototype.removeListener = function (t, s, i, n) { var r = e ? e + t : t; if (!this.P[r]) return this; if (!s) return o(this, r), this; var h = this.P[r]; if (h.fn) h.fn !== s || n && !h.once || i && h.context !== i || o(this, r); else { for (var a = 0, l = [], u = h.length; a < u; a++)(h[a].fn !== s || n && !h[a].once || i && h[a].context !== i) && l.push(h[a]); l.length ? this.P[r] = 1 === l.length ? l[0] : l : o(this, r) } return this }, h.prototype.removeAllListeners = function (t) { var s; return t ? (s = e ? e + t : t, this.P[s] && o(this, s)) : (this.P = new i, this.k = 0), this }, h.prototype.off = h.prototype.removeListener, h.prototype.addListener = h.prototype.on, h.prefixed = e, h.EventEmitter = h, t.exports = h }(p)), p.exports)), g = 2 * Math.PI, v = 180 / Math.PI, b = Math.PI / 180; class x { constructor(t = 0, s = 0) { this.x = 0, this.y = 0, this.x = t, this.y = s } clone() { return new x(this.x, this.y) } copyFrom(t) { return this.set(t.x, t.y), this } copyTo(t) { return t.set(this.x, this.y), t } equals(t) { return t.x === this.x && t.y === this.y } set(t = 0, s = t) { return this.x = t, this.y = s, this } toString() { return `[pixi.js/math:Point x=${this.x} y=${this.y}]` } static get shared() { return y.x = 0, y.y = 0, y } } const y = new x; let w = class t { constructor(t = 1, s = 0, e = 0, i = 1, n = 0, r = 0) { this.array = null, this.a = t, this.b = s, this.c = e, this.d = i, this.tx = n, this.ty = r } fromArray(t) { this.a = t[0], this.b = t[1], this.c = t[3], this.d = t[4], this.tx = t[2], this.ty = t[5] } set(t, s, e, i, n, r) { return this.a = t, this.b = s, this.c = e, this.d = i, this.tx = n, this.ty = r, this } toArray(t, s) { this.array || (this.array = new Float32Array(9)); const e = s || this.array; return t ? (e[0] = this.a, e[1] = this.b, e[2] = 0, e[3] = this.c, e[4] = this.d, e[5] = 0, e[6] = this.tx, e[7] = this.ty, e[8] = 1) : (e[0] = this.a, e[1] = this.c, e[2] = this.tx, e[3] = this.b, e[4] = this.d, e[5] = this.ty, e[6] = 0, e[7] = 0, e[8] = 1), e } apply(t, s) { s = s || new x; const e = t.x, i = t.y; return s.x = this.a * e + this.c * i + this.tx, s.y = this.b * e + this.d * i + this.ty, s } applyInverse(t, s) { s = s || new x; const e = this.a, i = this.b, n = this.c, r = this.d, o = this.tx, h = this.ty, a = 1 / (e * r + n * -i), l = t.x, u = t.y; return s.x = r * a * l + -n * a * u + (h * n - o * r) * a, s.y = e * a * u + -i * a * l + (-h * e + o * i) * a, s } translate(t, s) { return this.tx += t, this.ty += s, this } scale(t, s) { return this.a *= t, this.d *= s, this.c *= t, this.b *= s, this.tx *= t, this.ty *= s, this } rotate(t) { const s = Math.cos(t), e = Math.sin(t), i = this.a, n = this.c, r = this.tx; return this.a = i * s - this.b * e, this.b = i * e + this.b * s, this.c = n * s - this.d * e, this.d = n * e + this.d * s, this.tx = r * s - this.ty * e, this.ty = r * e + this.ty * s, this } append(t) { const s = this.a, e = this.b, i = this.c, n = this.d; return this.a = t.a * s + t.b * i, this.b = t.a * e + t.b * n, this.c = t.c * s + t.d * i, this.d = t.c * e + t.d * n, this.tx = t.tx * s + t.ty * i + this.tx, this.ty = t.tx * e + t.ty * n + this.ty, this } appendFrom(t, s) { const e = t.a, i = t.b, n = t.c, r = t.d, o = t.tx, h = t.ty, a = s.a, l = s.b, u = s.c, c = s.d; return this.a = e * a + i * u, this.b = e * l + i * c, this.c = n * a + r * u, this.d = n * l + r * c, this.tx = o * a + h * u + s.tx, this.ty = o * l + h * c + s.ty, this } setTransform(t, s, e, i, n, r, o, h, a) { return this.a = Math.cos(o + a) * n, this.b = Math.sin(o + a) * n, this.c = -Math.sin(o - h) * r, this.d = Math.cos(o - h) * r, this.tx = t - (e * this.a + i * this.c), this.ty = s - (e * this.b + i * this.d), this } prepend(t) { const s = this.tx; if (1 !== t.a || 0 !== t.b || 0 !== t.c || 1 !== t.d) { const s = this.a, e = this.c; this.a = s * t.a + this.b * t.c, this.b = s * t.b + this.b * t.d, this.c = e * t.a + this.d * t.c, this.d = e * t.b + this.d * t.d } return this.tx = s * t.a + this.ty * t.c + t.tx, this.ty = s * t.b + this.ty * t.d + t.ty, this } decompose(t) { const s = this.a, e = this.b, i = this.c, n = this.d, r = t.pivot, o = -Math.atan2(-i, n), h = Math.atan2(e, s), a = Math.abs(o + h); return a < 1e-5 || Math.abs(g - a) < 1e-5 ? (t.rotation = h, t.skew.x = t.skew.y = 0) : (t.rotation = 0, t.skew.x = o, t.skew.y = h), t.scale.x = Math.sqrt(s * s + e * e), t.scale.y = Math.sqrt(i * i + n * n), t.position.x = this.tx + (r.x * s + r.y * i), t.position.y = this.ty + (r.x * e + r.y * n), t } invert() { const t = this.a, s = this.b, e = this.c, i = this.d, n = this.tx, r = t * i - s * e; return this.a = i / r, this.b = -s / r, this.c = -e / r, this.d = t / r, this.tx = (e * this.ty - i * n) / r, this.ty = -(t * this.ty - s * n) / r, this } isIdentity() { return 1 === this.a && 0 === this.b && 0 === this.c && 1 === this.d && 0 === this.tx && 0 === this.ty } identity() { return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.tx = 0, this.ty = 0, this } clone() { const s = new t; return s.a = this.a, s.b = this.b, s.c = this.c, s.d = this.d, s.tx = this.tx, s.ty = this.ty, s } copyTo(t) { return t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty, t } copyFrom(t) { return this.a = t.a, this.b = t.b, this.c = t.c, this.d = t.d, this.tx = t.tx, this.ty = t.ty, this } equals(t) { return t.a === this.a && t.b === this.b && t.c === this.c && t.d === this.d && t.tx === this.tx && t.ty === this.ty } toString() { return `[pixi.js:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]` } static get IDENTITY() { return T.identity() } static get shared() { return M.identity() } }; const M = new w, T = new w, A = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1], C = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1], _ = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1], S = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1], P = [], k = [], F = Math.sign; !function () { for (let t = 0; t < 16; t++) { const s = []; P.push(s); for (let e = 0; e < 16; e++) { const i = F(A[t] * A[e] + _[t] * C[e]), n = F(C[t] * A[e] + S[t] * C[e]), r = F(A[t] * _[e] + _[t] * S[e]), o = F(C[t] * _[e] + S[t] * S[e]); for (let t = 0; t < 16; t++)if (A[t] === i && C[t] === n && _[t] === r && S[t] === o) { s.push(t); break } } } for (let t = 0; t < 16; t++) { const s = new w; s.set(A[t], C[t], _[t], S[t], 0, 0), k.push(s) } }(); const E = { E: 0, SE: 1, S: 2, SW: 3, W: 4, NW: 5, N: 6, NE: 7, MIRROR_VERTICAL: 8, MAIN_DIAGONAL: 10, MIRROR_HORIZONTAL: 12, REVERSE_DIAGONAL: 14, uX: t => A[t], uY: t => C[t], vX: t => _[t], vY: t => S[t], inv: t => 8 & t ? 15 & t : 7 & -t, add: (t, s) => P[t][s], sub: (t, s) => P[t][E.inv(s)], rotate180: t => 4 ^ t, isVertical: t => 2 == (3 & t), byDirection: (t, s) => 2 * Math.abs(t) <= Math.abs(s) ? s >= 0 ? E.S : E.N : 2 * Math.abs(s) <= Math.abs(t) ? t > 0 ? E.E : E.W : s > 0 ? t > 0 ? E.SE : E.SW : t > 0 ? E.NE : E.NW, matrixAppendRotationInv: (t, s, e = 0, i = 0) => { const n = k[E.inv(s)]; n.tx = e, n.ty = i, t.append(n) }, transformRectCoords: (t, s, e, i) => { const { x: n, y: r, width: o, height: h } = t, { x: a, y: l, width: u, height: c } = s; return e === E.E ? (i.set(n + a, r + l, o, h), i) : e === E.S ? i.set(u - r - h + a, n + l, h, o) : e === E.W ? i.set(u - n - o + a, c - r - h + l, o, h) : e === E.N ? i.set(r + a, c - n - o + l, h, o) : i.set(n + a, r + l, o, h) } }, R = [new x, new x, new x, new x]; class O { constructor(t = 0, s = 0, e = 0, i = 0) { this.type = "rectangle", this.x = Number(t), this.y = Number(s), this.width = Number(e), this.height = Number(i) } get left() { return this.x } get right() { return this.x + this.width } get top() { return this.y } get bottom() { return this.y + this.height } isEmpty() { return this.left === this.right || this.top === this.bottom } static get EMPTY() { return new O(0, 0, 0, 0) } clone() { return new O(this.x, this.y, this.width, this.height) } copyFromBounds(t) { return this.x = t.minX, this.y = t.minY, this.width = t.maxX - t.minX, this.height = t.maxY - t.minY, this } copyFrom(t) { return this.x = t.x, this.y = t.y, this.width = t.width, this.height = t.height, this } copyTo(t) { return t.copyFrom(this), t } contains(t, s) { return !(this.width <= 0 || this.height <= 0) && t >= this.x && t < this.x + this.width && s >= this.y && s < this.y + this.height } strokeContains(t, s, e, i = .5) { const { width: n, height: r } = this; if (n <= 0 || r <= 0) return !1; const o = this.x, h = this.y, a = e * (1 - i), l = e - a; return t >= o - a && t <= o + n + a && s >= h - a && s <= h + r + a && !(t > o + l && t < o + n - l && s > h + l && s < h + r - l) } intersects(t, s) { if (!s) { const s = this.x < t.x ? t.x : this.x; if ((this.right > t.right ? t.right : this.right) <= s) return !1; const e = this.y < t.y ? t.y : this.y; return (this.bottom > t.bottom ? t.bottom : this.bottom) > e } const e = this.left, i = this.right, n = this.top, r = this.bottom; if (i <= e || r <= n) return !1; const o = R[0].set(t.left, t.top), h = R[1].set(t.left, t.bottom), a = R[2].set(t.right, t.top), l = R[3].set(t.right, t.bottom); if (a.x <= o.x || h.y <= o.y) return !1; const u = Math.sign(s.a * s.d - s.b * s.c); if (0 === u) return !1; if (s.apply(o, o), s.apply(h, h), s.apply(a, a), s.apply(l, l), Math.max(o.x, h.x, a.x, l.x) <= e || Math.min(o.x, h.x, a.x, l.x) >= i || Math.max(o.y, h.y, a.y, l.y) <= n || Math.min(o.y, h.y, a.y, l.y) >= r) return !1; const c = u * (h.y - o.y), f = u * (o.x - h.x), d = c * e + f * n, p = c * i + f * n, m = c * e + f * r, g = c * i + f * r; if (Math.max(d, p, m, g) <= c * o.x + f * o.y || Math.min(d, p, m, g) >= c * l.x + f * l.y) return !1; const v = u * (o.y - a.y), b = u * (a.x - o.x), x = v * e + b * n, y = v * i + b * n, w = v * e + b * r, M = v * i + b * r; return !(Math.max(x, y, w, M) <= v * o.x + b * o.y || Math.min(x, y, w, M) >= v * l.x + b * l.y) } pad(t = 0, s = t) { return this.x -= t, this.y -= s, this.width += 2 * t, this.height += 2 * s, this } fit(t) { const s = Math.max(this.x, t.x), e = Math.min(this.x + this.width, t.x + t.width), i = Math.max(this.y, t.y), n = Math.min(this.y + this.height, t.y + t.height); return this.x = s, this.width = Math.max(e - s, 0), this.y = i, this.height = Math.max(n - i, 0), this } ceil(t = 1, s = .001) { const e = Math.ceil((this.x + this.width - s) * t) / t, i = Math.ceil((this.y + this.height - s) * t) / t; return this.x = Math.floor((this.x + s) * t) / t, this.y = Math.floor((this.y + s) * t) / t, this.width = e - this.x, this.height = i - this.y, this } scale(t, s = t) { return this.x *= t, this.y *= s, this.width *= t, this.height *= s, this } enlarge(t) { const s = Math.min(this.x, t.x), e = Math.max(this.x + this.width, t.x + t.width), i = Math.min(this.y, t.y), n = Math.max(this.y + this.height, t.y + t.height); return this.x = s, this.width = e - s, this.y = i, this.height = n - i, this } getBounds(t) { return t || (t = new O), t.copyFrom(this), t } containsRect(t) { if (this.width <= 0 || this.height <= 0) return !1; const s = t.x, e = t.y, i = t.x + t.width, n = t.y + t.height; return s >= this.x && s < this.x + this.width && e >= this.y && e < this.y + this.height && i >= this.x && i < this.x + this.width && n >= this.y && n < this.y + this.height } set(t, s, e, i) { return this.x = t, this.y = s, this.width = e, this.height = i, this } toString() { return `[pixi.js/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]` } } const U = { default: -1 }; function I(t = "default") { return void 0 === U[t] && (U[t] = -1), ++U[t] } const B = new Set, $ = { quiet: !1, noColor: !1 }, G = (t, s, e = 3) => { if ($.quiet || B.has(s)) return; let i = (new Error).stack; "function" == typeof console.groupCollapsed && $.noColor, void 0 === i || (i = i.split("\n").splice(e).join("\n")), B.add(s) }; Object.defineProperties(G, { quiet: { get: () => $.quiet, set: t => { $.quiet = t }, enumerable: !0, configurable: !1 }, noColor: { get: () => $.noColor, set: t => { $.noColor = t }, enumerable: !0, configurable: !1 } }); const z = () => { }; function D(t) { return t += 0 === t ? 1 : 0, --t, t |= t >>> 1, t |= t >>> 2, t |= t >>> 4, 1 + ((t |= t >>> 8) | t >>> 16) } function j(t) { return !(t & t - 1 || !t) } function L(t) { const s = {}; for (const e in t) void 0 !== t[e] && (s[e] = t[e]); return s } const V = Object.create(null), N = class t extends m { constructor(s = {}) { super(), this.F = "textureSampler", this.R = 0, this.O = 1, this.destroyed = !1, s = { ...t.defaultOptions, ...s }, this.addressMode = s.addressMode, this.addressModeU = s.addressModeU ?? this.addressModeU, this.addressModeV = s.addressModeV ?? this.addressModeV, this.addressModeW = s.addressModeW ?? this.addressModeW, this.scaleMode = s.scaleMode, this.magFilter = s.magFilter ?? this.magFilter, this.minFilter = s.minFilter ?? this.minFilter, this.mipmapFilter = s.mipmapFilter ?? this.mipmapFilter, this.lodMinClamp = s.lodMinClamp, this.lodMaxClamp = s.lodMaxClamp, this.compare = s.compare, this.maxAnisotropy = s.maxAnisotropy ?? 1 } set addressMode(t) { this.addressModeU = t, this.addressModeV = t, this.addressModeW = t } get addressMode() { return this.addressModeU } set wrapMode(t) { G(0, "TextureStyle.wrapMode is now TextureStyle.addressMode"), this.addressMode = t } get wrapMode() { return this.addressMode } set scaleMode(t) { this.magFilter = t, this.minFilter = t, this.mipmapFilter = t } get scaleMode() { return this.magFilter } set maxAnisotropy(t) { this.O = Math.min(t, 16), this.O > 1 && (this.scaleMode = "linear") } get maxAnisotropy() { return this.O } get U() { return this.I || this.B() } update() { this.emit("change", this), this.I = null } B() { const t = `${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this.O}`; return this.I = function (t) { const s = V[t]; return void 0 === s && (V[t] = I("resource")), s }(t), this.U } destroy() { this.destroyed = !0, this.emit("destroy", this), this.emit("change", this), this.removeAllListeners() } }; N.defaultOptions = { addressMode: "clamp-to-edge", scaleMode: "linear" }; let W = N; const H = class t extends m { constructor(s = {}) { super(), this.options = s, this.uid = I("textureSource"), this.F = "textureSource", this.U = I("resource"), this.uploadMethodId = "unknown", this.$ = 1, this.pixelWidth = 1, this.pixelHeight = 1, this.width = 1, this.height = 1, this.sampleCount = 1, this.mipLevelCount = 1, this.autoGenerateMipmaps = !1, this.format = "rgba8unorm", this.dimension = "2d", this.antialias = !1, this.R = 0, this.G = -1, this.D = -1, s = { ...t.defaultOptions, ...s }, this.label = s.label ?? "", this.resource = s.resource, this.autoGarbageCollect = s.autoGarbageCollect, this.$ = s.resolution, s.width ? this.pixelWidth = s.width * this.$ : this.pixelWidth = this.resource ? this.resourceWidth ?? 1 : 1, s.height ? this.pixelHeight = s.height * this.$ : this.pixelHeight = this.resource ? this.resourceHeight ?? 1 : 1, this.width = this.pixelWidth / this.$, this.height = this.pixelHeight / this.$, this.format = s.format, this.dimension = s.dimensions, this.mipLevelCount = s.mipLevelCount, this.autoGenerateMipmaps = s.autoGenerateMipmaps, this.sampleCount = s.sampleCount, this.antialias = s.antialias, this.alphaMode = s.alphaMode, this.style = new W(L(s)), this.destroyed = !1, this.j() } get source() { return this } get style() { return this.L } set style(t) { this.style !== t && (this.L?.off("change", this.V, this), this.L = t, this.L?.on("change", this.V, this), this.V()) } set maxAnisotropy(t) { this.L.maxAnisotropy = t } get maxAnisotropy() { return this.L.maxAnisotropy } get addressMode() { return this.L.addressMode } set addressMode(t) { this.L.addressMode = t } get repeatMode() { return this.L.addressMode } set repeatMode(t) { this.L.addressMode = t } get magFilter() { return this.L.magFilter } set magFilter(t) { this.L.magFilter = t } get minFilter() { return this.L.minFilter } set minFilter(t) { this.L.minFilter = t } get mipmapFilter() { return this.L.mipmapFilter } set mipmapFilter(t) { this.L.mipmapFilter = t } get lodMinClamp() { return this.L.lodMinClamp } set lodMinClamp(t) { this.L.lodMinClamp = t } get lodMaxClamp() { return this.L.lodMaxClamp } set lodMaxClamp(t) { this.L.lodMaxClamp = t } V() { this.emit("styleChange", this) } update() { if (this.resource) { const t = this.$; if (this.resize(this.resourceWidth / t, this.resourceHeight / t)) return } this.emit("update", this) } destroy() { this.destroyed = !0, this.emit("destroy", this), this.emit("change", this), this.L && (this.L.destroy(), this.L = null), this.uploadMethodId = null, this.resource = null, this.removeAllListeners() } unload() { this.U = I("resource"), this.emit("change", this), this.emit("unload", this) } get resourceWidth() { const { resource: t } = this; return t.naturalWidth || t.videoWidth || t.displayWidth || t.width } get resourceHeight() { const { resource: t } = this; return t.naturalHeight || t.videoHeight || t.displayHeight || t.height } get resolution() { return this.$ } set resolution(t) { this.$ !== t && (this.$ = t, this.width = this.pixelWidth / t, this.height = this.pixelHeight / t) } resize(t, s, e) { e || (e = this.$), t || (t = this.width), s || (s = this.height); const i = Math.round(t * e), n = Math.round(s * e); return this.width = i / e, this.height = n / e, this.$ = e, (this.pixelWidth !== i || this.pixelHeight !== n) && (this.j(), this.pixelWidth = i, this.pixelHeight = n, this.emit("resize", this), this.U = I("resource"), this.emit("change", this), !0) } updateMipmaps() { this.autoGenerateMipmaps && this.mipLevelCount > 1 && this.emit("updateMipmaps", this) } set wrapMode(t) { this.L.wrapMode = t } get wrapMode() { return this.L.wrapMode } set scaleMode(t) { this.L.scaleMode = t } get scaleMode() { return this.L.scaleMode } j() { this.isPowerOfTwo = j(this.pixelWidth) && j(this.pixelHeight) } static test(t) { throw new Error("Unimplemented") } }; H.defaultOptions = { resolution: 1, format: "bgra8unorm", alphaMode: "premultiply-alpha-on-upload", dimensions: "2d", mipLevelCount: 1, autoGenerateMipmaps: !1, sampleCount: 1, antialias: !1, autoGarbageCollect: !1 }; let q = H; class X extends q { constructor(t) { const s = t.resource || new Float32Array(t.width * t.height * 4); let e = t.format; e || (e = s instanceof Float32Array ? "rgba32float" : s instanceof Int32Array || s instanceof Uint32Array ? "rgba32uint" : s instanceof Int16Array || s instanceof Uint16Array ? "rgba16uint" : (Int8Array, "bgra8unorm")), super({ ...t, resource: s, format: e }), this.uploadMethodId = "buffer" } static test(t) { return t instanceof Int8Array || t instanceof Uint8Array || t instanceof Uint8ClampedArray || t instanceof Int16Array || t instanceof Uint16Array || t instanceof Int32Array || t instanceof Uint32Array || t instanceof Float32Array } } X.extension = r.TextureSource; const Y = new w; class K { constructor(t, s) { this.mapCoord = new w, this.uClampFrame = new Float32Array(4), this.uClampOffset = new Float32Array(2), this.H = -1, this.X = 0, this.clampOffset = 0, this.clampMargin = void 0 === s ? t.width < 10 ? 0 : .5 : s, this.isSimple = !1, this.texture = t } get texture() { return this.Y } set texture(t) { this.texture !== t && (this.Y?.removeListener("update", this.update, this), this.Y = t, this.Y.addListener("update", this.update, this), this.update()) } multiplyUvs(t, s) { void 0 === s && (s = t); const e = this.mapCoord; for (let i = 0; i < t.length; i += 2) { const n = t[i], r = t[i + 1]; s[i] = n * e.a + r * e.c + e.tx, s[i + 1] = n * e.b + r * e.d + e.ty } return s } update() { const t = this.Y; this.X++; const s = t.uvs; this.mapCoord.set(s.x1 - s.x0, s.y1 - s.y0, s.x3 - s.x0, s.y3 - s.y0, s.x0, s.y0); const e = t.orig, i = t.trim; i && (Y.set(e.width / i.width, 0, 0, e.height / i.height, -i.x / i.width, -i.y / i.height), this.mapCoord.append(Y)); const n = t.source, r = this.uClampFrame, o = this.clampMargin / n.$, h = this.clampOffset / n.$; return r[0] = (t.frame.x + o + h) / n.width, r[1] = (t.frame.y + o + h) / n.height, r[2] = (t.frame.x + t.frame.width - o + h) / n.width, r[3] = (t.frame.y + t.frame.height - o + h) / n.height, this.uClampOffset[0] = this.clampOffset / n.pixelWidth, this.uClampOffset[1] = this.clampOffset / n.pixelHeight, this.isSimple = t.frame.width === n.width && t.frame.height === n.height && 0 === t.rotate, !0 } } class Z extends m { constructor({ source: t, label: s, frame: e, orig: i, trim: n, defaultAnchor: r, defaultBorders: o, rotate: h, dynamic: a } = {}) { if (super(), this.uid = I("texture"), this.uvs = { x0: 0, y0: 0, x1: 0, y1: 0, x2: 0, y2: 0, x3: 0, y3: 0 }, this.frame = new O, this.noFrame = !1, this.dynamic = !1, this.isTexture = !0, this.label = s, this.source = t?.source ?? new q, this.noFrame = !e, e) this.frame.copyFrom(e); else { const { width: t, height: s } = this.K; this.frame.width = t, this.frame.height = s } this.orig = i || this.frame, this.trim = n, this.rotate = h ?? 0, this.defaultAnchor = r, this.defaultBorders = o, this.destroyed = !1, this.dynamic = a || !1, this.updateUvs() } set source(t) { this.K && this.K.off("resize", this.update, this), this.K = t, t.on("resize", this.update, this), this.emit("update", this) } get source() { return this.K } get textureMatrix() { return this.Z || (this.Z = new K(this)), this.Z } get width() { return this.orig.width } get height() { return this.orig.height } updateUvs() { const { uvs: t, frame: s } = this, { width: e, height: i } = this.K, n = s.x / e, r = s.y / i, o = s.width / e, h = s.height / i; let a = this.rotate; if (a) { const s = o / 2, e = h / 2, i = n + s, l = r + e; a = E.add(a, E.NW), t.x0 = i + s * E.uX(a), t.y0 = l + e * E.uY(a), a = E.add(a, 2), t.x1 = i + s * E.uX(a), t.y1 = l + e * E.uY(a), a = E.add(a, 2), t.x2 = i + s * E.uX(a), t.y2 = l + e * E.uY(a), a = E.add(a, 2), t.x3 = i + s * E.uX(a), t.y3 = l + e * E.uY(a) } else t.x0 = n, t.y0 = r, t.x1 = n + o, t.y1 = r, t.x2 = n + o, t.y2 = r + h, t.x3 = n, t.y3 = r + h } destroy(t = !1) { this.K && (this.K.off("resize", this.update, this), t && (this.K.destroy(), this.K = null)), this.Z = null, this.destroyed = !0, this.emit("destroy", this), this.removeAllListeners() } update() { this.noFrame && (this.frame.width = this.K.width, this.frame.height = this.K.height), this.updateUvs(), this.emit("update", this) } get baseTexture() { return G(0, "Texture.baseTexture is now Texture.source"), this.K } } function Q(t, s, e) { const { width: i, height: n } = e.orig, r = e.trim; if (r) { const e = r.width, o = r.height; t.minX = r.x - s.M * i, t.maxX = t.minX + e, t.minY = r.y - s.T * n, t.maxY = t.minY + o } else t.minX = -s.M * i, t.maxX = t.minX + i, t.minY = -s.T * n, t.maxY = t.minY + n } Z.EMPTY = new Z({ label: "EMPTY", source: new q({ label: "EMPTY" }) }), Z.EMPTY.destroy = z, Z.WHITE = new Z({ source: new X({ resource: new Uint8Array([255, 255, 255, 255]), width: 1, height: 1, alphaMode: "premultiply-alpha-on-upload", label: "WHITE" }), label: "WHITE" }), Z.WHITE.destroy = z; const J = new w; class tt { constructor(t = 1 / 0, s = 1 / 0, e = -1 / 0, i = -1 / 0) { this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.matrix = J, this.minX = t, this.minY = s, this.maxX = e, this.maxY = i } isEmpty() { return this.minX > this.maxX || this.minY > this.maxY } get rectangle() { this.J || (this.J = new O); const t = this.J; return this.minX > this.maxX || this.minY > this.maxY ? (t.x = 0, t.y = 0, t.width = 0, t.height = 0) : t.copyFromBounds(this), t } clear() { return this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.matrix = J, this } set(t, s, e, i) { this.minX = t, this.minY = s, this.maxX = e, this.maxY = i } addFrame(t, s, e, i, n) { n || (n = this.matrix); const r = n.a, o = n.b, h = n.c, a = n.d, l = n.tx, u = n.ty; let c = this.minX, f = this.minY, d = this.maxX, p = this.maxY, m = r * t + h * s + l, g = o * t + a * s + u; m < c && (c = m), g < f && (f = g), m > d && (d = m), g > p && (p = g), m = r * e + h * s + l, g = o * e + a * s + u, m < c && (c = m), g < f && (f = g), m > d && (d = m), g > p && (p = g), m = r * t + h * i + l, g = o * t + a * i + u, m < c && (c = m), g < f && (f = g), m > d && (d = m), g > p && (p = g), m = r * e + h * i + l, g = o * e + a * i + u, m < c && (c = m), g < f && (f = g), m > d && (d = m), g > p && (p = g), this.minX = c, this.minY = f, this.maxX = d, this.maxY = p } addRect(t, s) { this.addFrame(t.x, t.y, t.x + t.width, t.y + t.height, s) } addBounds(t, s) { this.addFrame(t.minX, t.minY, t.maxX, t.maxY, s) } addBoundsMask(t) { this.minX = this.minX > t.minX ? this.minX : t.minX, this.minY = this.minY > t.minY ? this.minY : t.minY, this.maxX = this.maxX < t.maxX ? this.maxX : t.maxX, this.maxY = this.maxY < t.maxY ? this.maxY : t.maxY } applyMatrix(t) { const s = this.minX, e = this.minY, i = this.maxX, n = this.maxY, { a: r, b: o, c: h, d: a, tx: l, ty: u } = t; let c = r * s + h * e + l, f = o * s + a * e + u; this.minX = c, this.minY = f, this.maxX = c, this.maxY = f, c = r * i + h * e + l, f = o * i + a * e + u, this.minX = c < this.minX ? c : this.minX, this.minY = f < this.minY ? f : this.minY, this.maxX = c > this.maxX ? c : this.maxX, this.maxY = f > this.maxY ? f : this.maxY, c = r * s + h * n + l, f = o * s + a * n + u, this.minX = c < this.minX ? c : this.minX, this.minY = f < this.minY ? f : this.minY, this.maxX = c > this.maxX ? c : this.maxX, this.maxY = f > this.maxY ? f : this.maxY, c = r * i + h * n + l, f = o * i + a * n + u, this.minX = c < this.minX ? c : this.minX, this.minY = f < this.minY ? f : this.minY, this.maxX = c > this.maxX ? c : this.maxX, this.maxY = f > this.maxY ? f : this.maxY } fit(t) { return this.minX < t.left && (this.minX = t.left), this.maxX > t.right && (this.maxX = t.right), this.minY < t.top && (this.minY = t.top), this.maxY > t.bottom && (this.maxY = t.bottom), this } fitBounds(t, s, e, i) { return this.minX < t && (this.minX = t), this.maxX > s && (this.maxX = s), this.minY < e && (this.minY = e), this.maxY > i && (this.maxY = i), this } pad(t, s = t) { return this.minX -= t, this.maxX += t, this.minY -= s, this.maxY += s, this } ceil() { return this.minX = Math.floor(this.minX), this.minY = Math.floor(this.minY), this.maxX = Math.ceil(this.maxX), this.maxY = Math.ceil(this.maxY), this } clone() { return new tt(this.minX, this.minY, this.maxX, this.maxY) } scale(t, s = t) { return this.minX *= t, this.minY *= s, this.maxX *= t, this.maxY *= s, this } get x() { return this.minX } set x(t) { const s = this.maxX - this.minX; this.minX = t, this.maxX = t + s } get y() { return this.minY } set y(t) { const s = this.maxY - this.minY; this.minY = t, this.maxY = t + s } get width() { return this.maxX - this.minX } set width(t) { this.maxX = this.minX + t } get height() { return this.maxY - this.minY } set height(t) { this.maxY = this.minY + t } get left() { return this.minX } get right() { return this.maxX } get top() { return this.minY } get bottom() { return this.maxY } get isPositive() { return this.maxX - this.minX > 0 && this.maxY - this.minY > 0 } get isValid() { return this.minX + this.minY !== 1 / 0 } addVertexData(t, s, e, i) { let n = this.minX, r = this.minY, o = this.maxX, h = this.maxY; i || (i = this.matrix); const a = i.a, l = i.b, u = i.c, c = i.d, f = i.tx, d = i.ty; for (let p = s; p < e; p += 2) { const s = t[p], e = t[p + 1], i = a * s + u * e + f, m = l * s + c * e + d; n = i < n ? i : n, r = m < r ? m : r, o = i > o ? i : o, h = m > h ? m : h } this.minX = n, this.minY = r, this.maxX = o, this.maxY = h } containsPoint(t, s) { return this.minX <= t && this.minY <= s && this.maxX >= t && this.maxY >= s } toString() { return `[pixi.js:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]` } copyFrom(t) { return this.minX = t.minX, this.minY = t.minY, this.maxX = t.maxX, this.maxY = t.maxY, this } } var st = { grad: .9, turn: 360, rad: 360 / (2 * Math.PI) }, et = function (t) { return "string" == typeof t ? t.length > 0 : "number" == typeof t }, it = function (t, s, e) { return void 0 === s && (s = 0), void 0 === e && (e = Math.pow(10, s)), Math.round(e * t) / e + 0 }, nt = function (t, s, e) { return void 0 === s && (s = 0), void 0 === e && (e = 1), t > e ? e : t > s ? t : s }, rt = function (t) { return (t = isFinite(t) ? t % 360 : 0) > 0 ? t : t + 360 }, ot = function (t) { return { r: nt(t.r, 0, 255), g: nt(t.g, 0, 255), b: nt(t.b, 0, 255), a: nt(t.a) } }, ht = function (t) { return { r: it(t.r), g: it(t.g), b: it(t.b), a: it(t.a, 3) } }, at = /^#([0-9a-f]{3,8})$/i, lt = function (t) { var s = t.toString(16); return s.length < 2 ? "0" + s : s }, ut = function (t) { var s = t.r, e = t.g, i = t.b, n = t.a, r = Math.max(s, e, i), o = r - Math.min(s, e, i), h = o ? r === s ? (e - i) / o : r === e ? 2 + (i - s) / o : 4 + (s - e) / o : 0; return { h: 60 * (h < 0 ? h + 6 : h), s: r ? o / r * 100 : 0, v: r / 255 * 100, a: n } }, ct = function (t) { var s = t.h, e = t.s, i = t.v, n = t.a; s = s / 360 * 6, e /= 100, i /= 100; var r = Math.floor(s), o = i * (1 - e), h = i * (1 - (s - r) * e), a = i * (1 - (1 - s + r) * e), l = r % 6; return { r: 255 * [i, h, o, o, a, i][l], g: 255 * [a, i, i, h, o, o][l], b: 255 * [o, o, a, i, i, h][l], a: n } }, ft = function (t) { return { h: rt(t.h), s: nt(t.s, 0, 100), l: nt(t.l, 0, 100), a: nt(t.a) } }, dt = function (t) { return { h: it(t.h), s: it(t.s), l: it(t.l), a: it(t.a, 3) } }, pt = function (t) { return ct((e = (s = t).s, { h: s.h, s: (e *= ((i = s.l) < 50 ? i : 100 - i) / 100) > 0 ? 2 * e / (i + e) * 100 : 0, v: i + e, a: s.a })); var s, e, i }, mt = function (t) { return { h: (s = ut(t)).h, s: (n = (200 - (e = s.s)) * (i = s.v) / 100) > 0 && n < 200 ? e * i / 100 / (n <= 100 ? n : 200 - n) * 100 : 0, l: n / 2, a: s.a }; var s, e, i, n }, gt = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, vt = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, bt = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, xt = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, yt = { string: [[function (t) { var s = at.exec(t); return s ? (t = s[1]).length <= 4 ? { r: parseInt(t[0] + t[0], 16), g: parseInt(t[1] + t[1], 16), b: parseInt(t[2] + t[2], 16), a: 4 === t.length ? it(parseInt(t[3] + t[3], 16) / 255, 2) : 1 } : 6 === t.length || 8 === t.length ? { r: parseInt(t.substr(0, 2), 16), g: parseInt(t.substr(2, 2), 16), b: parseInt(t.substr(4, 2), 16), a: 8 === t.length ? it(parseInt(t.substr(6, 2), 16) / 255, 2) : 1 } : null : null }, "hex"], [function (t) { var s = bt.exec(t) || xt.exec(t); return s ? s[2] !== s[4] || s[4] !== s[6] ? null : ot({ r: Number(s[1]) / (s[2] ? 100 / 255 : 1), g: Number(s[3]) / (s[4] ? 100 / 255 : 1), b: Number(s[5]) / (s[6] ? 100 / 255 : 1), a: void 0 === s[7] ? 1 : Number(s[7]) / (s[8] ? 100 : 1) }) : null }, "rgb"], [function (t) { var s = gt.exec(t) || vt.exec(t); if (!s) return null; var e, i, n = ft({ h: (e = s[1], i = s[2], void 0 === i && (i = "deg"), Number(e) * (st[i] || 1)), s: Number(s[3]), l: Number(s[4]), a: void 0 === s[5] ? 1 : Number(s[5]) / (s[6] ? 100 : 1) }); return pt(n) }, "hsl"]], object: [[function (t) { var s = t.r, e = t.g, i = t.b, n = t.a, r = void 0 === n ? 1 : n; return et(s) && et(e) && et(i) ? ot({ r: Number(s), g: Number(e), b: Number(i), a: Number(r) }) : null }, "rgb"], [function (t) { var s = t.h, e = t.s, i = t.l, n = t.a, r = void 0 === n ? 1 : n; if (!et(s) || !et(e) || !et(i)) return null; var o = ft({ h: Number(s), s: Number(e), l: Number(i), a: Number(r) }); return pt(o) }, "hsl"], [function (t) { var s = t.h, e = t.s, i = t.v, n = t.a, r = void 0 === n ? 1 : n; if (!et(s) || !et(e) || !et(i)) return null; var o, h = (o = { h: Number(s), s: Number(e), v: Number(i), a: Number(r) }, { h: rt(o.h), s: nt(o.s, 0, 100), v: nt(o.v, 0, 100), a: nt(o.a) }); return ct(h) }, "hsv"]] }, wt = function (t, s) { for (var e = 0; e < s.length; e++) { var i = s[e][0](t); if (i) return [i, s[e][1]] } return [null, void 0] }, Mt = function (t, s) { var e = mt(t); return { h: e.h, s: nt(e.s + 100 * s, 0, 100), l: e.l, a: e.a } }, Tt = function (t) { return (299 * t.r + 587 * t.g + 114 * t.b) / 1e3 / 255 }, At = function (t, s) { var e = mt(t); return { h: e.h, s: e.s, l: nt(e.l + 100 * s, 0, 100), a: e.a } }, Ct = function () { function t(t) { this.parsed = function (t) { return "string" == typeof t ? wt(t.trim(), yt.string) : "object" == typeof t && null !== t ? wt(t, yt.object) : [null, void 0] }(t)[0], this.rgba = this.parsed || { r: 0, g: 0, b: 0, a: 1 } } return t.prototype.isValid = function () { return null !== this.parsed }, t.prototype.brightness = function () { return it(Tt(this.rgba), 2) }, t.prototype.isDark = function () { return Tt(this.rgba) < .5 }, t.prototype.isLight = function () { return Tt(this.rgba) >= .5 }, t.prototype.toHex = function () { return s = (t = ht(this.rgba)).r, e = t.g, i = t.b, r = (n = t.a) < 1 ? lt(it(255 * n)) : "", "#" + lt(s) + lt(e) + lt(i) + r; var t, s, e, i, n, r }, t.prototype.toRgb = function () { return ht(this.rgba) }, t.prototype.toRgbString = function () { return s = (t = ht(this.rgba)).r, e = t.g, i = t.b, (n = t.a) < 1 ? "rgba(" + s + ", " + e + ", " + i + ", " + n + ")" : "rgb(" + s + ", " + e + ", " + i + ")"; var t, s, e, i, n }, t.prototype.toHsl = function () { return dt(mt(this.rgba)) }, t.prototype.toHslString = function () { return s = (t = dt(mt(this.rgba))).h, e = t.s, i = t.l, (n = t.a) < 1 ? "hsla(" + s + ", " + e + "%, " + i + "%, " + n + ")" : "hsl(" + s + ", " + e + "%, " + i + "%)"; var t, s, e, i, n }, t.prototype.toHsv = function () { return t = ut(this.rgba), { h: it(t.h), s: it(t.s), v: it(t.v), a: it(t.a, 3) }; var t }, t.prototype.invert = function () { return _t({ r: 255 - (t = this.rgba).r, g: 255 - t.g, b: 255 - t.b, a: t.a }); var t }, t.prototype.saturate = function (t) { return void 0 === t && (t = .1), _t(Mt(this.rgba, t)) }, t.prototype.desaturate = function (t) { return void 0 === t && (t = .1), _t(Mt(this.rgba, -t)) }, t.prototype.grayscale = function () { return _t(Mt(this.rgba, -1)) }, t.prototype.lighten = function (t) { return void 0 === t && (t = .1), _t(At(this.rgba, t)) }, t.prototype.darken = function (t) { return void 0 === t && (t = .1), _t(At(this.rgba, -t)) }, t.prototype.rotate = function (t) { return void 0 === t && (t = 15), this.hue(this.hue() + t) }, t.prototype.alpha = function (t) { return "number" == typeof t ? _t({ r: (s = this.rgba).r, g: s.g, b: s.b, a: t }) : it(this.rgba.a, 3); var s }, t.prototype.hue = function (t) { var s = mt(this.rgba); return "number" == typeof t ? _t({ h: t, s: s.s, l: s.l, a: s.a }) : it(s.h) }, t.prototype.isEqual = function (t) { return this.toHex() === _t(t).toHex() }, t }(), _t = function (t) { return t instanceof Ct ? t : new Ct(t) }, St = [];[function (t, s) { var e = { white: "#ffffff", bisque: "#ffe4c4", blue: "#0000ff", cadetblue: "#5f9ea0", chartreuse: "#7fff00", chocolate: "#d2691e", coral: "#ff7f50", antiquewhite: "#faebd7", aqua: "#00ffff", azure: "#f0ffff", whitesmoke: "#f5f5f5", papayawhip: "#ffefd5", plum: "#dda0dd", blanchedalmond: "#ffebcd", black: "#000000", gold: "#ffd700", goldenrod: "#daa520", gainsboro: "#dcdcdc", cornsilk: "#fff8dc", cornflowerblue: "#6495ed", burlywood: "#deb887", aquamarine: "#7fffd4", beige: "#f5f5dc", crimson: "#dc143c", cyan: "#00ffff", darkblue: "#00008b", darkcyan: "#008b8b", darkgoldenrod: "#b8860b", darkkhaki: "#bdb76b", darkgray: "#a9a9a9", darkgreen: "#006400", darkgrey: "#a9a9a9", peachpuff: "#ffdab9", darkmagenta: "#8b008b", darkred: "#8b0000", darkorchid: "#9932cc", darkorange: "#ff8c00", darkslateblue: "#483d8b", gray: "#808080", darkslategray: "#2f4f4f", darkslategrey: "#2f4f4f", deeppink: "#ff1493", deepskyblue: "#00bfff", wheat: "#f5deb3", firebrick: "#b22222", floralwhite: "#fffaf0", ghostwhite: "#f8f8ff", darkviolet: "#9400d3", magenta: "#ff00ff", green: "#008000", dodgerblue: "#1e90ff", grey: "#808080", honeydew: "#f0fff0", hotpink: "#ff69b4", blueviolet: "#8a2be2", forestgreen: "#228b22", lawngreen: "#7cfc00", indianred: "#cd5c5c", indigo: "#4b0082", fuchsia: "#ff00ff", brown: "#a52a2a", maroon: "#800000", mediumblue: "#0000cd", lightcoral: "#f08080", darkturquoise: "#00ced1", lightcyan: "#e0ffff", ivory: "#fffff0", lightyellow: "#ffffe0", lightsalmon: "#ffa07a", lightseagreen: "#20b2aa", linen: "#faf0e6", mediumaquamarine: "#66cdaa", lemonchiffon: "#fffacd", lime: "#00ff00", khaki: "#f0e68c", mediumseagreen: "#3cb371", limegreen: "#32cd32", mediumspringgreen: "#00fa9a", lightskyblue: "#87cefa", lightblue: "#add8e6", midnightblue: "#191970", lightpink: "#ffb6c1", mistyrose: "#ffe4e1", moccasin: "#ffe4b5", mintcream: "#f5fffa", lightslategray: "#778899", lightslategrey: "#778899", navajowhite: "#ffdead", navy: "#000080", mediumvioletred: "#c71585", powderblue: "#b0e0e6", palegoldenrod: "#eee8aa", oldlace: "#fdf5e6", paleturquoise: "#afeeee", mediumturquoise: "#48d1cc", mediumorchid: "#ba55d3", rebeccapurple: "#663399", lightsteelblue: "#b0c4de", mediumslateblue: "#7b68ee", thistle: "#d8bfd8", tan: "#d2b48c", orchid: "#da70d6", mediumpurple: "#9370db", purple: "#800080", pink: "#ffc0cb", skyblue: "#87ceeb", springgreen: "#00ff7f", palegreen: "#98fb98", red: "#ff0000", yellow: "#ffff00", slateblue: "#6a5acd", lavenderblush: "#fff0f5", peru: "#cd853f", palevioletred: "#db7093", violet: "#ee82ee", teal: "#008080", slategray: "#708090", slategrey: "#708090", aliceblue: "#f0f8ff", darkseagreen: "#8fbc8f", darkolivegreen: "#556b2f", greenyellow: "#adff2f", seagreen: "#2e8b57", seashell: "#fff5ee", tomato: "#ff6347", silver: "#c0c0c0", sienna: "#a0522d", lavender: "#e6e6fa", lightgreen: "#90ee90", orange: "#ffa500", orangered: "#ff4500", steelblue: "#4682b4", royalblue: "#4169e1", turquoise: "#40e0d0", yellowgreen: "#9acd32", salmon: "#fa8072", saddlebrown: "#8b4513", sandybrown: "#f4a460", rosybrown: "#bc8f8f", darksalmon: "#e9967a", lightgoldenrodyellow: "#fafad2", snow: "#fffafa", lightgrey: "#d3d3d3", lightgray: "#d3d3d3", dimgray: "#696969", dimgrey: "#696969", olivedrab: "#6b8e23", olive: "#808000" }, i = {}; for (var n in e) i[e[n]] = n; var r = {}; t.prototype.toName = function (s) { if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b)) return "transparent"; var n, o, h = i[this.toHex()]; if (h) return h; if (null == s ? void 0 : s.closest) { var a = this.toRgb(), l = 1 / 0, u = "black"; if (!r.length) for (var c in e) r[c] = new t(e[c]).toRgb(); for (var f in e) { var d = (n = a, o = r[f], Math.pow(n.r - o.r, 2) + Math.pow(n.g - o.g, 2) + Math.pow(n.b - o.b, 2)); d < l && (l = d, u = f) } return u } }, s.string.push([function (s) { var i = s.toLowerCase(), n = "transparent" === i ? "#0000" : e[i]; return n ? new t(n).toRgb() : null }, "name"]) }].forEach(function (t) { St.indexOf(t) < 0 && (t(Ct, yt), St.push(t)) }); const Pt = class t { constructor(t = 16777215) { this.tt = null, this.st = new Float32Array(4), this.st.fill(1), this.et = 16777215, this.value = t } get red() { return this.st[0] } get green() { return this.st[1] } get blue() { return this.st[2] } get alpha() { return this.st[3] } setValue(t) { return this.value = t, this } set value(s) { if (s instanceof t) this.tt = this.it(s.tt), this.et = s.et, this.st.set(s.st); else { if (null === s) throw new Error("Cannot set Color#value to null"); null !== this.tt && this.nt(this.tt, s) || (this.tt = this.it(s), this.rt(this.tt)) } } get value() { return this.tt } it(t) { return "string" == typeof t || "number" == typeof t || t instanceof Number || null === t ? t : Array.isArray(t) || ArrayBuffer.isView(t) ? t.slice(0) : "object" == typeof t && null !== t ? { ...t } : t } nt(t, s) { const e = typeof t; if (e !== typeof s) return !1; if ("number" === e || "string" === e || t instanceof Number) return t === s; if (Array.isArray(t) && Array.isArray(s) || ArrayBuffer.isView(t) && ArrayBuffer.isView(s)) return t.length === s.length && t.every((t, e) => t === s[e]); if (null !== t && null !== s) { const e = Object.keys(t), i = Object.keys(s); return e.length === i.length && e.every(e => t[e] === s[e]) } return t === s } toRgba() { const [t, s, e, i] = this.st; return { r: t, g: s, b: e, a: i } } toRgb() { const [t, s, e] = this.st; return { r: t, g: s, b: e } } toRgbaString() { const [t, s, e] = this.toUint8RgbArray(); return `rgba(${t},${s},${e},${this.alpha})` } toUint8RgbArray(t) { const [s, e, i] = this.st; return this.ot || (this.ot = []), t || (t = this.ot), t[0] = Math.round(255 * s), t[1] = Math.round(255 * e), t[2] = Math.round(255 * i), t } toArray(t) { this.ht || (this.ht = []), t || (t = this.ht); const [s, e, i, n] = this.st; return t[0] = s, t[1] = e, t[2] = i, t[3] = n, t } toRgbArray(t) { this.ot || (this.ot = []), t || (t = this.ot); const [s, e, i] = this.st; return t[0] = s, t[1] = e, t[2] = i, t } toNumber() { return this.et } toBgrNumber() { const [t, s, e] = this.toUint8RgbArray(); return (e << 16) + (s << 8) + t } toLittleEndianNumber() { const t = this.et; return (t >> 16) + (65280 & t) + ((255 & t) << 16) } multiply(s) { const [e, i, n, r] = t.lt.setValue(s).st; return this.st[0] *= e, this.st[1] *= i, this.st[2] *= n, this.st[3] *= r, this.ut(), this.tt = null, this } premultiply(t, s = !0) { return s && (this.st[0] *= t, this.st[1] *= t, this.st[2] *= t), this.st[3] = t, this.ut(), this.tt = null, this } toPremultiplied(t, s = !0) { if (1 === t) return (255 << 24) + this.et; if (0 === t) return s ? 0 : this.et; let e = this.et >> 16 & 255, i = this.et >> 8 & 255, n = 255 & this.et; return s && (e = e * t + .5 | 0, i = i * t + .5 | 0, n = n * t + .5 | 0), (255 * t << 24) + (e << 16) + (i << 8) + n } toHex() { const t = this.et.toString(16); return `#${"000000".substring(0, 6 - t.length) + t}` } toHexa() { const t = Math.round(255 * this.st[3]).toString(16); return this.toHex() + "00".substring(0, 2 - t.length) + t } setAlpha(t) { return this.st[3] = this.ct(t), this } rt(s) { let e, i, n, r; if (("number" == typeof s || s instanceof Number) && s >= 0 && s <= 16777215) e = (s >> 16 & 255) / 255, i = (s >> 8 & 255) / 255, n = (255 & s) / 255, r = 1; else if ((Array.isArray(s) || s instanceof Float32Array) && s.length >= 3 && s.length <= 4) s = this.ct(s), [e, i, n, r = 1] = s; else if ((s instanceof Uint8Array || s instanceof Uint8ClampedArray) && s.length >= 3 && s.length <= 4) s = this.ct(s, 0, 255), [e, i, n, r = 255] = s, e /= 255, i /= 255, n /= 255, r /= 255; else if ("string" == typeof s || "object" == typeof s) { if ("string" == typeof s) { const e = t.HEX_PATTERN.exec(s); e && (s = `#${e[2]}`) } const o = _t(s); o.isValid() && (({ r: e, g: i, b: n, a: r } = o.rgba), e /= 255, i /= 255, n /= 255) } if (void 0 === e) throw new Error(`Unable to convert color ${s}`); this.st[0] = e, this.st[1] = i, this.st[2] = n, this.st[3] = r, this.ut() } ut() { this.ct(this.st); const [t, s, e] = this.st; this.et = (255 * t << 16) + (255 * s << 8) + (255 * e | 0) } ct(t, s = 0, e = 1) { return "number" == typeof t ? Math.min(Math.max(t, s), e) : (t.forEach((i, n) => { t[n] = Math.min(Math.max(i, s), e) }), t) } static isColorLike(s) { return "number" == typeof s || "string" == typeof s || s instanceof Number || s instanceof t || Array.isArray(s) || s instanceof Uint8Array || s instanceof Uint8ClampedArray || s instanceof Float32Array || void 0 !== s.r && void 0 !== s.g && void 0 !== s.b || void 0 !== s.r && void 0 !== s.g && void 0 !== s.b && void 0 !== s.a || void 0 !== s.h && void 0 !== s.s && void 0 !== s.l || void 0 !== s.h && void 0 !== s.s && void 0 !== s.l && void 0 !== s.a || void 0 !== s.h && void 0 !== s.s && void 0 !== s.v || void 0 !== s.h && void 0 !== s.s && void 0 !== s.v && void 0 !== s.a } }; Pt.shared = new Pt, Pt.lt = new Pt, Pt.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i; let kt = Pt, Ft = 0; function Et(...t) { 500 !== Ft && Ft++ } const Rt = { ft: new Set, register(t) { this.ft.add(t) }, unregister(t) { this.ft.delete(t) }, release() { this.ft.forEach(t => t.clear()) }, get registeredCount() { return this.ft.size }, isRegistered(t) { return this.ft.has(t) }, reset() { this.ft.clear() } }; class Ot { constructor(t, s) { this.dt = [], this.gt = 0, this.vt = 0, this.bt = t, s && this.prepopulate(s) } prepopulate(t) { for (let s = 0; s < t; s++)this.dt[this.vt++] = new this.bt; this.gt += t } get(t) { let s; return this.vt > 0 ? s = this.dt[--this.vt] : (s = new this.bt, this.gt++), s.init?.(t), s } return(t) { t.reset?.(), this.dt[this.vt++] = t } get totalSize() { return this.gt } get totalFree() { return this.vt } get totalUsed() { return this.gt - this.vt } clear() { if (this.dt.length > 0 && this.dt[0].destroy) for (let t = 0; t < this.vt; t++)this.dt[t].destroy(); this.dt.length = 0, this.gt = 0, this.vt = 0 } } const Ut = new class { constructor() { this.xt = new Map } prepopulate(t, s) { this.getPool(t).prepopulate(s) } get(t, s) { return this.getPool(t).get(s) } return(t) { this.getPool(t.constructor).return(t) } getPool(t) { return this.xt.has(t) || this.xt.set(t, new Ot(t)), this.xt.get(t) } stats() { const t = {}; return this.xt.forEach(s => { const e = t[s.bt.name] ? s.bt.name + s.bt.ID : s.bt.name; t[e] = { free: s.totalFree, used: s.totalUsed, size: s.totalSize } }), t } clear() { this.xt.forEach(t => t.clear()), this.xt.clear() } }; Rt.register(Ut); const It = { get isCachedAsTexture() { return !!this.renderGroup?.isCachedAsTexture }, cacheAsTexture(t) { "boolean" == typeof t && !1 === t ? this.disableRenderGroup() : (this.enableRenderGroup(), this.renderGroup.enableCacheAsTexture(!0 === t ? {} : t)) }, updateCacheTexture() { this.renderGroup?.updateCacheTexture() }, get cacheAsBitmap() { return this.isCachedAsTexture }, set cacheAsBitmap(t) { G(0, "cacheAsBitmap is deprecated, use cacheAsTexture instead."), this.cacheAsTexture(t) } }; function Bt(t, s, e) { const i = t.length; let n; if (s >= i || 0 === e) return; const r = i - (e = s + e > i ? i - s : e); for (n = s; n < r; ++n)t[n] = t[n + e]; t.length = r } const $t = { allowChildren: !0, removeChildren(t = 0, s) { const e = s ?? this.children.length, i = e - t, n = []; if (i > 0 && i <= e) { for (let i = e - 1; i >= t; i--) { const t = this.children[i]; t && (n.push(t), t.parent = null) } Bt(this.children, t, e); const s = this.renderGroup || this.parentRenderGroup; s && s.removeChildren(n); for (let t = 0; t < n.length; ++t) { const s = n[t]; s.parentRenderLayer?.detach(s), this.emit("childRemoved", s, this, t), n[t].emit("removed", this) } return n.length > 0 && this.yt++, n } if (0 === i && 0 === this.children.length) return n; throw new RangeError("removeChildren: numeric values are outside the acceptable range.") }, removeChildAt(t) { const s = this.getChildAt(t); return this.removeChild(s) }, getChildAt(t) { if (t < 0 || t >= this.children.length) throw new Error(`getChildAt: Index (${t}) does not exist.`); return this.children[t] }, setChildIndex(t, s) { if (s < 0 || s >= this.children.length) throw new Error(`The index ${s} supplied is out of bounds ${this.children.length}`); this.getChildIndex(t), this.addChildAt(t, s) }, getChildIndex(t) { const s = this.children.indexOf(t); if (-1 === s) throw new Error("The supplied Container must be a child of the caller"); return s }, addChildAt(t, s) { this.allowChildren || G(0, "addChildAt: Only Containers will be allowed to add children in v8.0.0"); const { children: e } = this; if (s < 0 || s > e.length) throw new Error(`${t}addChildAt: The index ${s} supplied is out of bounds ${e.length}`); if (t.parent) { const e = t.parent.children.indexOf(t); if (t.parent === this && e === s) return t; -1 !== e && t.parent.children.splice(e, 1) } s === e.length ? e.push(t) : e.splice(s, 0, t), t.parent = this, t.didChange = !0, t.wt = 15; const i = this.renderGroup || this.parentRenderGroup; return i && i.addChild(t), this.sortableChildren && (this.sortDirty = !0), this.emit("childAdded", t, this, s), t.emit("added", this), t }, swapChildren(t, s) { if (t === s) return; const e = this.getChildIndex(t), i = this.getChildIndex(s); this.children[e] = s, this.children[i] = t; const n = this.renderGroup || this.parentRenderGroup; n && (n.structureDidChange = !0), this.Mt++ }, removeFromParent() { this.parent?.removeChild(this) }, reparentChild(...t) { return 1 === t.length ? this.reparentChildAt(t[0], this.children.length) : (t.forEach(t => this.reparentChildAt(t, this.children.length)), t[0]) }, reparentChildAt(t, s) { if (t.parent === this) return this.setChildIndex(t, s), t; const e = t.worldTransform.clone(); t.removeFromParent(), this.addChildAt(t, s); const i = this.worldTransform.clone(); return i.invert(), e.prepend(i), t.setFromMatrix(e), t }, replaceChild(t, s) { t.updateLocalTransform(), this.addChildAt(s, this.getChildIndex(t)), s.setFromMatrix(t.localTransform), s.updateLocalTransform(), this.removeChild(t) } }, Gt = { collectRenderables(t, s, e) { this.parentRenderLayer && this.parentRenderLayer !== e || this.globalDisplayStatus < 7 || !this.includeInBuild || (this.sortableChildren && this.sortChildren(), this.isSimple ? this.collectRenderablesSimple(t, s, e) : this.renderGroup ? s.renderPipes.renderGroup.addRenderGroup(this.renderGroup, t) : this.collectRenderablesWithEffects(t, s, e)) }, collectRenderablesSimple(t, s, e) { const i = this.children, n = i.length; for (let r = 0; r < n; r++)i[r].collectRenderables(t, s, e) }, collectRenderablesWithEffects(t, s, e) { const { renderPipes: i } = s; for (let n = 0; n < this.effects.length; n++) { const s = this.effects[n]; i[s.pipe].push(s, this, t) } this.collectRenderablesSimple(t, s, e); for (let n = this.effects.length - 1; n >= 0; n--) { const s = this.effects[n]; i[s.pipe].pop(s, this, t) } } }; class zt { constructor() { this.pipe = "filter", this.priority = 1 } destroy() { for (let t = 0; t < this.filters.length; t++)this.filters[t].destroy(); this.filters = null, this.filterArea = null } } const Dt = new class { constructor() { this.Tt = [], this.At = [], this.Ct = !1 } init() { this.Ct || (this.Ct = !0, this.Tt.forEach(t => { this.add({ test: t.test, maskClass: t }) })) } add(t) { this.At.push(t) } getMaskEffect(t) { this.Ct || this.init(); for (let s = 0; s < this.At.length; s++) { const e = this.At[s]; if (e.test(t)) return Ut.get(e.maskClass, t) } return t } returnMaskEffect(t) { Ut.return(t) } }; a.handleByList(r.MaskEffect, Dt.Tt); const jt = { _t: null, St: { inverse: !1 }, Pt: null, effects: [], kt() { const t = this.renderGroup || this.parentRenderGroup; t && (t.structureDidChange = !0) }, addEffect(t) { -1 === this.effects.indexOf(t) && (this.effects.push(t), this.effects.sort((t, s) => t.priority - s.priority), this.kt(), this.Ft()) }, removeEffect(t) { const s = this.effects.indexOf(t); -1 !== s && (this.effects.splice(s, 1), this.kt(), this.Ft()) }, set mask(t) { const s = this._t; s?.mask !== t && (s && (this.removeEffect(s), Dt.returnMaskEffect(s), this._t = null), null != t && (this._t = Dt.getMaskEffect(t), this.addEffect(this._t))) }, get mask() { return this._t?.mask }, setMask(t) { this.St = { ...this.St, ...t }, t.mask && (this.mask = t.mask), this.kt() }, set filters(t) { !Array.isArray(t) && t && (t = [t]); const s = this.Pt || (this.Pt = new zt), e = t?.length > 0, i = e !== s.filters?.length > 0; t = Array.isArray(t) ? t.slice(0) : t, s.filters = Object.freeze(t), i && (e ? this.addEffect(s) : (this.removeEffect(s), s.filters = t ?? null)) }, get filters() { return this.Pt?.filters }, set filterArea(t) { this.Pt || (this.Pt = new zt), this.Pt.filterArea = t }, get filterArea() { return this.Pt?.filterArea } }, Lt = { label: null, get name() { return G(0, "Container.name property has been removed, use Container.label instead"), this.label }, set name(t) { G(0, "Container.name property has been removed, use Container.label instead"), this.label = t }, getChildByName(t, s = !1) { return this.getChildByLabel(t, s) }, getChildByLabel(t, s = !1) { const e = this.children; for (let i = 0; i < e.length; i++) { const s = e[i]; if (s.label === t || t instanceof RegExp && t.test(s.label)) return s } if (s) for (let i = 0; i < e.length; i++) { const s = e[i].getChildByLabel(t, !0); if (s) return s } return null }, getChildrenByLabel(t, s = !1, e = []) { const i = this.children; for (let n = 0; n < i.length; n++) { const s = i[n]; (s.label === t || t instanceof RegExp && t.test(s.label)) && e.push(s) } if (s) for (let n = 0; n < i.length; n++)i[n].getChildrenByLabel(t, !0, e); return e } }, Vt = Ut.getPool(w), Nt = Ut.getPool(tt), Wt = new w, Ht = { getFastGlobalBounds(t, s) { s || (s = new tt), s.clear(), this.Et(!!t, s, this.parentRenderLayer), s.isValid || s.set(0, 0, 0, 0); const e = this.renderGroup || this.parentRenderGroup; return s.applyMatrix(e.worldTransform), s }, Et(t, s, e) { let i = s; if (t && this.parentRenderLayer && this.parentRenderLayer !== e) return; if (7 !== this.localDisplayStatus || !this.measurable) return; const n = !!this.effects.length; if ((this.renderGroup || n) && (i = Nt.get().clear()), this.boundsArea) s.addRect(this.boundsArea, this.worldTransform); else { if (this.renderPipeId) { const t = this.bounds; i.addFrame(t.minX, t.minY, t.maxX, t.maxY, this.groupTransform) } const s = this.children; for (let n = 0; n < s.length; n++)s[n].Et(t, i, e) } if (n) { let t = !1; const e = this.renderGroup || this.parentRenderGroup; for (let s = 0; s < this.effects.length; s++)this.effects[s].addBounds && (t || (t = !0, i.applyMatrix(e.worldTransform)), this.effects[s].addBounds(i, !0)); t && i.applyMatrix(e.worldTransform.copyTo(Wt).invert()), s.addBounds(i), Nt.return(i) } else this.renderGroup && (s.addBounds(i, this.relativeGroupTransform), Nt.return(i)) } }; function qt(t, s, e) { let i, n; return e.clear(), t.parent ? s ? i = t.parent.worldTransform : (n = Vt.get().identity(), i = Yt(t, n)) : i = w.IDENTITY, Xt(t, e, i, s), n && Vt.return(n), e.isValid || e.set(0, 0, 0, 0), e } function Xt(t, s, e, i) { if (!t.visible || !t.measurable) return; let n; i ? n = t.worldTransform : (t.updateLocalTransform(), n = Vt.get(), n.appendFrom(t.localTransform, e)); const r = s, o = !!t.effects.length; if (o && (s = Nt.get().clear()), t.boundsArea) s.addRect(t.boundsArea, n); else { const e = t.bounds; e && !e.isEmpty() && (s.matrix = n, s.addBounds(e)); for (let r = 0; r < t.children.length; r++)Xt(t.children[r], s, n, i) } if (o) { for (let e = 0; e < t.effects.length; e++)t.effects[e].addBounds?.(s); r.addBounds(s, w.IDENTITY), Nt.return(s) } i || Vt.return(n) } function Yt(t, s) { const e = t.parent; return e && (Yt(e, s), e.updateLocalTransform(), s.append(e.localTransform)), s } function Kt(t, s) { return 16777215 !== t && s ? 16777215 !== s && t ? ((t >> 16 & 255) * (s >> 16 & 255) / 255 << 16) + ((t >> 8 & 255) * (s >> 8 & 255) / 255 << 8) + ((255 & t) * (255 & s) / 255 | 0) : t : s } const Zt = 16777215; function Qt(t, s) { return t === Zt ? s : s === Zt ? t : Kt(t, s) } function Jt(t) { return ((255 & t) << 16) + (65280 & t) + (t >> 16 & 255) } const ts = { getGlobalAlpha(t) { if (t) return this.renderGroup ? this.renderGroup.worldAlpha : this.parentRenderGroup ? this.parentRenderGroup.worldAlpha * this.alpha : this.alpha; let s = this.alpha, e = this.parent; for (; e;)s *= e.alpha, e = e.parent; return s }, getGlobalTransform(t = new w, s) { if (s) return t.copyFrom(this.worldTransform); this.updateLocalTransform(); const e = Yt(this, Vt.get().identity()); return t.appendFrom(this.localTransform, e), Vt.return(e), t }, getGlobalTint(t) { if (t) return this.renderGroup ? Jt(this.renderGroup.worldColor) : this.parentRenderGroup ? Jt(Qt(this.localColor, this.parentRenderGroup.worldColor)) : this.tint; let s = this.localColor, e = this.parent; for (; e;)s = Qt(s, e.localColor), e = e.parent; return Jt(s) } }; function ss(t, s, e) { return s.clear(), e || (e = w.IDENTITY), es(t, s, e, t, !0), s.isValid || s.set(0, 0, 0, 0), s } function es(t, s, e, i, n) { let r; if (n) r = Vt.get(), r = e.copyTo(r); else { if (!t.visible || !t.measurable) return; t.updateLocalTransform(); const s = t.localTransform; r = Vt.get(), r.appendFrom(s, e) } const o = s, h = !!t.effects.length; if (h && (s = Nt.get().clear()), t.boundsArea) s.addRect(t.boundsArea, r); else { t.renderPipeId && (s.matrix = r, s.addBounds(t.bounds)); const e = t.children; for (let t = 0; t < e.length; t++)es(e[t], s, r, i, !1) } if (h) { for (let e = 0; e < t.effects.length; e++)t.effects[e].addLocalBounds?.(s, i); o.addBounds(s, w.IDENTITY), Nt.return(s) } Vt.return(r) } function is(t, s) { const e = t.children; for (let i = 0; i < e.length; i++) { const t = e[i], n = t.uid, r = (65535 & t.yt) << 16 | 65535 & t.Mt, o = s.index; s.data[o] === n && s.data[o + 1] === r || (s.data[s.index] = n, s.data[s.index + 1] = r, s.didChange = !0), s.index = o + 2, t.children.length && is(t, s) } return s.didChange } const ns = new w, rs = { Rt: -1, Ot: null, Ut(t, s) { const e = Math.sign(this.scale.x) || 1; this.scale.x = 0 !== s ? t / s * e : e }, It(t, s) { const e = Math.sign(this.scale.y) || 1; this.scale.y = 0 !== s ? t / s * e : e }, getLocalBounds() { this.Ot || (this.Ot = { data: [], index: 1, didChange: !1, localBounds: new tt }); const t = this.Ot; return t.index = 1, t.didChange = !1, t.data[0] !== this.yt && (t.didChange = !0, t.data[0] = this.yt), is(this, t), t.didChange && ss(this, t.localBounds, ns), t.localBounds }, getBounds(t, s) { return qt(this, t, s || new tt) } }, os = { Bt: null, set onRender(t) { const s = this.renderGroup || this.parentRenderGroup; if (!t) return this.Bt && s?.removeOnRender(this), void (this.Bt = null); this.Bt || s?.addOnRender(this), this.Bt = t }, get onRender() { return this.Bt } }, hs = { $t: 0, sortDirty: !1, sortableChildren: !1, get zIndex() { return this.$t }, set zIndex(t) { this.$t !== t && (this.$t = t, this.depthOfChildModified()) }, depthOfChildModified() { this.parent && (this.parent.sortableChildren = !0, this.parent.sortDirty = !0), this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0) }, sortChildren() { this.sortDirty && (this.sortDirty = !1, this.children.sort(as)) } }; function as(t, s) { return t.$t - s.$t } const ls = { getGlobalPosition(t = new x, s = !1) { return this.parent ? this.parent.toGlobal(this.Gt, t, s) : (t.x = this.Gt.x, t.y = this.Gt.y), t }, toGlobal(t, s, e = !1) { const i = this.getGlobalTransform(Vt.get(), e); return s = i.apply(t, s), Vt.return(i), s }, toLocal(t, s, e, i) { s && (t = s.toGlobal(t, e, i)); const n = this.getGlobalTransform(Vt.get(), i); return e = n.applyInverse(t, e), Vt.return(n), e } }; class us { constructor() { this.uid = I("instructionSet"), this.instructions = [], this.instructionSize = 0, this.renderables = [], this.gcTick = 0 } reset() { this.instructionSize = 0 } destroy() { this.instructions.length = 0, this.renderables.length = 0, this.renderPipes = null, this.gcTick = 0 } add(t) { this.instructions[this.instructionSize++] = t } log() { this.instructions.length = this.instructionSize } } let cs = 0; const fs = new class { constructor(t) { this.zt = Object.create(null), this.Dt = {}, this.textureOptions = t || {}, this.enableFullScreen = !1, this.textureStyle = new W(this.textureOptions) } createTexture(t, s, e) { const i = new q({ ...this.textureOptions, width: t, height: s, resolution: 1, antialias: e, autoGarbageCollect: !1 }); return new Z({ source: i, label: "texturePool_" + cs++ }) } getOptimalTexture(t, s, e = 1, i) { let n = Math.ceil(t * e - 1e-6), r = Math.ceil(s * e - 1e-6); n = D(n), r = D(r); const o = (n << 17) + (r << 1) + (i ? 1 : 0); this.Dt[o] || (this.Dt[o] = []); let h = this.Dt[o].pop(); return h || (h = this.createTexture(n, r, i)), h.source.$ = e, h.source.width = n / e, h.source.height = r / e, h.source.pixelWidth = n, h.source.pixelHeight = r, h.frame.x = 0, h.frame.y = 0, h.frame.width = t, h.frame.height = s, h.updateUvs(), this.zt[h.uid] = o, h } getSameSizeTexture(t, s = !1) { const e = t.source; return this.getOptimalTexture(t.width, t.height, e.$, s) } returnTexture(t, s = !1) { const e = this.zt[t.uid]; s && (t.source.style = this.textureStyle), this.Dt[e].push(t) } clear(t) { if (t = !1 !== t) for (const s in this.Dt) { const t = this.Dt[s]; if (t) for (let s = 0; s < t.length; s++)t[s].destroy(!0) } this.Dt = {} } }; Rt.register(fs); class ds { constructor() { this.renderPipeId = "renderGroup", this.root = null, this.canBundle = !1, this.renderGroupParent = null, this.renderGroupChildren = [], this.worldTransform = new w, this.worldColorAlpha = 4294967295, this.worldColor = 16777215, this.worldAlpha = 1, this.childrenToUpdate = Object.create(null), this.updateTick = 0, this.gcTick = 0, this.childrenRenderablesToUpdate = { list: [], index: 0 }, this.structureDidChange = !0, this.instructionSet = new us, this.jt = [], this.textureNeedsUpdate = !0, this.isCachedAsTexture = !1, this.Lt = 7 } init(t) { this.root = t, t.Bt && this.addOnRender(t), t.didChange = !0; const s = t.children; for (let e = 0; e < s.length; e++) { const t = s[e]; t.wt = 15, this.addChild(t) } } enableCacheAsTexture(t = {}) { this.textureOptions = t, this.isCachedAsTexture = !0, this.textureNeedsUpdate = !0 } disableCacheAsTexture() { this.isCachedAsTexture = !1, this.texture && (fs.returnTexture(this.texture, !0), this.texture = null) } updateCacheTexture() { this.textureNeedsUpdate = !0; const t = this.Vt; t && !t.textureNeedsUpdate && t.updateCacheTexture() } reset() { this.renderGroupChildren.length = 0; for (const t in this.childrenToUpdate) { const s = this.childrenToUpdate[t]; s.list.fill(null), s.index = 0 } this.childrenRenderablesToUpdate.index = 0, this.childrenRenderablesToUpdate.list.fill(null), this.root = null, this.updateTick = 0, this.structureDidChange = !0, this.jt.length = 0, this.renderGroupParent = null, this.disableCacheAsTexture() } get localTransform() { return this.root.localTransform } addRenderGroupChild(t) { t.renderGroupParent && t.renderGroupParent.Nt(t), t.renderGroupParent = this, this.renderGroupChildren.push(t) } Nt(t) { const s = this.renderGroupChildren.indexOf(t); s > -1 && this.renderGroupChildren.splice(s, 1), t.renderGroupParent = null } addChild(t) { if (this.structureDidChange = !0, t.parentRenderGroup = this, t.updateTick = -1, t.parent === this.root ? t.relativeRenderGroupDepth = 1 : t.relativeRenderGroupDepth = t.parent.relativeRenderGroupDepth + 1, t.didChange = !0, this.onChildUpdate(t), t.renderGroup) return void this.addRenderGroupChild(t.renderGroup); t.Bt && this.addOnRender(t); const s = t.children; for (let e = 0; e < s.length; e++)this.addChild(s[e]) } removeChild(t) { if (this.structureDidChange = !0, t.Bt && (t.renderGroup || this.removeOnRender(t)), t.parentRenderGroup = null, t.renderGroup) return void this.Nt(t.renderGroup); const s = t.children; for (let e = 0; e < s.length; e++)this.removeChild(s[e]) } removeChildren(t) { for (let s = 0; s < t.length; s++)this.removeChild(t[s]) } onChildUpdate(t) { let s = this.childrenToUpdate[t.relativeRenderGroupDepth]; s || (s = this.childrenToUpdate[t.relativeRenderGroupDepth] = { index: 0, list: [] }), s.list[s.index++] = t } updateRenderable(t) { t.globalDisplayStatus < 7 || (this.instructionSet.renderPipes[t.renderPipeId].updateRenderable(t), t.didViewUpdate = !1) } onChildViewUpdate(t) { this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = t } get isRenderable() { return 7 === this.root.localDisplayStatus && this.worldAlpha > 0 } addOnRender(t) { this.jt.push(t) } removeOnRender(t) { this.jt.splice(this.jt.indexOf(t), 1) } runOnRender(t) { for (let s = 0; s < this.jt.length; s++)this.jt[s].Bt(t) } destroy() { this.disableCacheAsTexture(), this.renderGroupParent = null, this.root = null, this.childrenRenderablesToUpdate = null, this.childrenToUpdate = null, this.renderGroupChildren = null, this.jt = null, this.instructionSet = null } getChildren(t = []) { const s = this.root.children; for (let e = 0; e < s.length; e++)this.Wt(s[e], t); return t } Wt(t, s = []) { if (s.push(t), t.renderGroup) return s; const e = t.children; for (let i = 0; i < e.length; i++)this.Wt(e[i], s); return s } invalidateMatrices() { this.Lt = 7 } get inverseWorldTransform() { return 1 & this.Lt ? (this.Lt &= -2, this.Ht || (this.Ht = new w), this.Ht.copyFrom(this.worldTransform).invert()) : this.Ht } get textureOffsetInverseTransform() { return 2 & this.Lt ? (this.Lt &= -3, this.qt || (this.qt = new w), this.qt.copyFrom(this.inverseWorldTransform).translate(-this.Xt.x, -this.Xt.y)) : this.qt } get inverseParentTextureTransform() { if (!(4 & this.Lt)) return this.Yt; this.Lt &= -5; const t = this.Vt; return t ? (this.Yt || (this.Yt = new w), this.Yt.copyFrom(this.worldTransform).prepend(t.inverseWorldTransform).translate(-t.Xt.x, -t.Xt.y)) : this.worldTransform } get cacheToLocalTransform() { return this.isCachedAsTexture ? this.textureOffsetInverseTransform : this.Vt ? this.Vt.textureOffsetInverseTransform : null } } const ps = new c(null), ms = new c(null), gs = new c(null, 1, 1), vs = new c(null); class bs extends m { constructor(t = {}) { super(), this.uid = I("renderable"), this.wt = 15, this.renderGroup = null, this.parentRenderGroup = null, this.parentRenderGroupIndex = 0, this.didChange = !1, this.didViewUpdate = !1, this.relativeRenderGroupDepth = 0, this.children = [], this.parent = null, this.includeInBuild = !0, this.measurable = !0, this.isSimple = !0, this.parentRenderLayer = null, this.updateTick = -1, this.localTransform = new w, this.relativeGroupTransform = new w, this.groupTransform = this.relativeGroupTransform, this.destroyed = !1, this.Gt = new c(this, 0, 0), this.Kt = gs, this.Zt = ms, this.Qt = vs, this.Jt = ps, this.ts = 1, this.ss = 0, this.es = 0, this.ns = 1, this.rs = 0, this.localColor = 16777215, this.localAlpha = 1, this.groupAlpha = 1, this.groupColor = 16777215, this.groupColorAlpha = 4294967295, this.localBlendMode = "inherit", this.groupBlendMode = "normal", this.localDisplayStatus = 7, this.globalDisplayStatus = 7, this.Mt = 0, this.yt = 0, this.hs = -1, this.effects = [], function (t, s, e = {}) { for (const i in s) e[i] || void 0 === s[i] || (t[i] = s[i]) }(this, t, { children: !0, parent: !0, effects: !0 }), t.children?.forEach(t => this.addChild(t)), t.parent?.addChild(this) } static mixin(t) { G(0, "Container.mixin is deprecated, please use extensions.mixin instead."), a.mixin(bs, t) } set ls(t) { this.yt = t >> 12 & 4095, this.Mt = 4095 & t } get ls() { return 4095 & this.Mt | (4095 & this.yt) << 12 } addChild(...t) { if (this.allowChildren || G(0, "addChild: Only Containers will be allowed to add children in v8.0.0"), t.length > 1) { for (let s = 0; s < t.length; s++)this.addChild(t[s]); return t[0] } const s = t[0], e = this.renderGroup || this.parentRenderGroup; return s.parent === this ? (this.children.splice(this.children.indexOf(s), 1), this.children.push(s), e && (e.structureDidChange = !0), s) : (s.parent && s.parent.removeChild(s), this.children.push(s), this.sortableChildren && (this.sortDirty = !0), s.parent = this, s.didChange = !0, s.wt = 15, e && e.addChild(s), this.emit("childAdded", s, this, this.children.length - 1), s.emit("added", this), this.yt++, 0 !== s.$t && s.depthOfChildModified(), s) } removeChild(...t) { if (t.length > 1) { for (let s = 0; s < t.length; s++)this.removeChild(t[s]); return t[0] } const s = t[0], e = this.children.indexOf(s); return e > -1 && (this.yt++, this.children.splice(e, 1), this.renderGroup ? this.renderGroup.removeChild(s) : this.parentRenderGroup && this.parentRenderGroup.removeChild(s), s.parentRenderLayer && s.parentRenderLayer.detach(s), s.parent = null, this.emit("childRemoved", s, this, e), s.emit("removed", this)), s } C(t) { t && t === this.Jt && this.us(), this.Mt++, this.didChange || (this.didChange = !0, this.parentRenderGroup && this.parentRenderGroup.onChildUpdate(this)) } set isRenderGroup(t) { !!this.renderGroup !== t && (t ? this.enableRenderGroup() : this.disableRenderGroup()) } get isRenderGroup() { return !!this.renderGroup } enableRenderGroup() { if (this.renderGroup) return; const t = this.parentRenderGroup; t?.removeChild(this), this.renderGroup = Ut.get(ds, this), this.groupTransform = w.IDENTITY, t?.addChild(this), this.Ft() } disableRenderGroup() { if (!this.renderGroup) return; const t = this.parentRenderGroup; t?.removeChild(this), Ut.return(this.renderGroup), this.renderGroup = null, this.groupTransform = this.relativeGroupTransform, t?.addChild(this), this.Ft() } Ft() { this.isSimple = !this.renderGroup && 0 === this.effects.length } get worldTransform() { return this.cs || (this.cs = new w), this.renderGroup ? this.cs.copyFrom(this.renderGroup.worldTransform) : this.parentRenderGroup && this.cs.appendFrom(this.relativeGroupTransform, this.parentRenderGroup.worldTransform), this.cs } get x() { return this.Gt.x } set x(t) { this.Gt.x = t } get y() { return this.Gt.y } set y(t) { this.Gt.y = t } get position() { return this.Gt } set position(t) { this.Gt.copyFrom(t) } get rotation() { return this.rs } set rotation(t) { this.rs !== t && (this.rs = t, this.C(this.Jt)) } get angle() { return this.rotation * v } set angle(t) { this.rotation = t * b } get pivot() { return this.Zt === ms && (this.Zt = new c(this, 0, 0)), this.Zt } set pivot(t) { this.Zt === ms && (this.Zt = new c(this, 0, 0), this.Qt !== vs && Et()), "number" == typeof t ? this.Zt.set(t) : this.Zt.copyFrom(t) } get skew() { return this.Jt === ps && (this.Jt = new c(this, 0, 0)), this.Jt } set skew(t) { this.Jt === ps && (this.Jt = new c(this, 0, 0)), this.Jt.copyFrom(t) } get scale() { return this.Kt === gs && (this.Kt = new c(this, 1, 1)), this.Kt } set scale(t) { this.Kt === gs && (this.Kt = new c(this, 0, 0)), "string" == typeof t && (t = parseFloat(t)), "number" == typeof t ? this.Kt.set(t) : this.Kt.copyFrom(t) } get origin() { return this.Qt === vs && (this.Qt = new c(this, 0, 0)), this.Qt } set origin(t) { this.Qt === vs && (this.Qt = new c(this, 0, 0), this.Zt !== ms && Et()), "number" == typeof t ? this.Qt.set(t) : this.Qt.copyFrom(t) } get width() { return Math.abs(this.scale.x * this.getLocalBounds().width) } set width(t) { const s = this.getLocalBounds().width; this.Ut(t, s) } get height() { return Math.abs(this.scale.y * this.getLocalBounds().height) } set height(t) { const s = this.getLocalBounds().height; this.It(t, s) } getSize(t) { t || (t = {}); const s = this.getLocalBounds(); return t.width = Math.abs(this.scale.x * s.width), t.height = Math.abs(this.scale.y * s.height), t } setSize(t, s) { const e = this.getLocalBounds(); "object" == typeof t ? (s = t.height ?? t.width, t = t.width) : s ?? (s = t), void 0 !== t && this.Ut(t, e.width), void 0 !== s && this.It(s, e.height) } us() { const t = this.rs, s = this.Jt; this.ts = Math.cos(t + s.T), this.ss = Math.sin(t + s.T), this.es = -Math.sin(t - s.M), this.ns = Math.cos(t - s.M) } updateTransform(t) { return this.position.set("number" == typeof t.x ? t.x : this.position.x, "number" == typeof t.y ? t.y : this.position.y), this.scale.set("number" == typeof t.scaleX ? t.scaleX || 1 : this.scale.x, "number" == typeof t.scaleY ? t.scaleY || 1 : this.scale.y), this.rotation = "number" == typeof t.rotation ? t.rotation : this.rotation, this.skew.set("number" == typeof t.skewX ? t.skewX : this.skew.x, "number" == typeof t.skewY ? t.skewY : this.skew.y), this.pivot.set("number" == typeof t.pivotX ? t.pivotX : this.pivot.x, "number" == typeof t.pivotY ? t.pivotY : this.pivot.y), this.origin.set("number" == typeof t.originX ? t.originX : this.origin.x, "number" == typeof t.originY ? t.originY : this.origin.y), this } setFromMatrix(t) { t.decompose(this) } updateLocalTransform() { const t = this.Mt; if (this.hs === t) return; this.hs = t; const s = this.localTransform, e = this.Kt, i = this.Zt, n = this.Qt, r = this.Gt, o = e.M, h = e.T, a = i.M, l = i.T, u = -n.M, c = -n.T; s.a = this.ts * o, s.b = this.ss * o, s.c = this.es * h, s.d = this.ns * h, s.tx = r.M - (a * s.a + l * s.c) + (u * s.a + c * s.c) - u, s.ty = r.T - (a * s.b + l * s.d) + (u * s.b + c * s.d) - c } set alpha(t) { t !== this.localAlpha && (this.localAlpha = t, this.wt |= 1, this.C()) } get alpha() { return this.localAlpha } set tint(t) { const s = kt.shared.setValue(t ?? 16777215).toBgrNumber(); s !== this.localColor && (this.localColor = s, this.wt |= 1, this.C()) } get tint() { return Jt(this.localColor) } set blendMode(t) { this.localBlendMode !== t && (this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0), this.wt |= 2, this.localBlendMode = t, this.C()) } get blendMode() { return this.localBlendMode } get visible() { return !!(2 & this.localDisplayStatus) } set visible(t) { const s = t ? 2 : 0; (2 & this.localDisplayStatus) !== s && (this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0), this.wt |= 4, this.localDisplayStatus ^= 2, this.C()) } get culled() { return !(4 & this.localDisplayStatus) } set culled(t) { const s = t ? 0 : 4; (4 & this.localDisplayStatus) !== s && (this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0), this.wt |= 4, this.localDisplayStatus ^= 4, this.C()) } get renderable() { return !!(1 & this.localDisplayStatus) } set renderable(t) { const s = t ? 1 : 0; (1 & this.localDisplayStatus) !== s && (this.wt |= 4, this.localDisplayStatus ^= 1, this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0), this.C()) } get isRenderable() { return 7 === this.localDisplayStatus && this.groupAlpha > 0 } destroy(t = !1) { if (this.destroyed) return; let s; if (this.destroyed = !0, this.children.length && (s = this.removeChildren(0, this.children.length)), this.removeFromParent(), this.parent = null, this._t = null, this.Pt = null, this.effects = null, this.Gt = null, this.Kt = null, this.Zt = null, this.Qt = null, this.Jt = null, this.emit("destroyed", this), this.removeAllListeners(), ("boolean" == typeof t ? t : t?.children) && s) for (let e = 0; e < s.length; ++e)s[e].destroy(t); this.renderGroup?.destroy(), this.renderGroup = null } } a.mixin(bs, $t, Ht, ls, os, rs, jt, Lt, hs, { cullArea: null, cullable: !1, cullableChildren: !0 }, It, ts, Gt); class xs extends bs { constructor(t) { super(t), this.canBundle = !0, this.allowChildren = !1, this.fs = 0, this.ds = -1, this.ps = Object.create(null), this.gs = new tt(0, 1, 0, 0), this.vs = !0 } get bounds() { return this.vs ? (this.updateBounds(), this.vs = !1, this.gs) : this.gs } get roundPixels() { return !!this.fs } set roundPixels(t) { this.fs = t ? 1 : 0 } containsPoint(t) { const s = this.bounds, { x: e, y: i } = t; return e >= s.minX && e <= s.maxX && i >= s.minY && i <= s.maxY } onViewUpdate() { if (this.yt++, this.vs = !0, this.didViewUpdate) return; this.didViewUpdate = !0; const t = this.renderGroup || this.parentRenderGroup; t && t.onChildViewUpdate(this) } destroy(t) { super.destroy(t), this.gs = null; for (const s in this.ps) this.ps[s].destroy?.(); this.ps = null } collectRenderablesSimple(t, s, e) { const { renderPipes: i } = s; i.blendMode.pushBlendMode(this, this.groupBlendMode, t), i[this.renderPipeId].addRenderable(this, t), this.didViewUpdate = !1; const n = this.children, r = n.length; for (let o = 0; o < r; o++)n[o].collectRenderables(t, s, e); i.blendMode.popBlendMode(t) } } class ys extends xs { constructor(t = Z.EMPTY) { t instanceof Z && (t = { texture: t }); const { texture: s = Z.EMPTY, anchor: e, roundPixels: i, width: n, height: r, ...o } = t; super({ label: "Sprite", ...o }), this.renderPipeId = "sprite", this.batched = !0, this.bs = { minX: 0, maxX: 1, minY: 0, maxY: 0 }, this.xs = new c({ C: () => { this.onViewUpdate() } }), e ? this.anchor = e : s.defaultAnchor && (this.anchor = s.defaultAnchor), this.texture = s, this.allowChildren = !1, this.roundPixels = i ?? !1, void 0 !== n && (this.width = n), void 0 !== r && (this.height = r) } static from(t, s = !1) { return new ys(t instanceof Z ? t : Z.from(t, s)) } set texture(t) { t || (t = Z.EMPTY); const s = this.Y; s !== t && (s && s.dynamic && s.off("update", this.onViewUpdate, this), t.dynamic && t.on("update", this.onViewUpdate, this), this.Y = t, this.ys && this.Ut(this.ys, this.Y.orig.width), this.ws && this.It(this.ws, this.Y.orig.height), this.onViewUpdate()) } get texture() { return this.Y } get visualBounds() { return Q(this.bs, this.xs, this.Y), this.bs } get sourceBounds() { return G(0, "Sprite.sourceBounds is deprecated, use visualBounds instead."), this.visualBounds } updateBounds() { const t = this.xs, s = this.Y, e = this.gs, { width: i, height: n } = s.orig; e.minX = -t.M * i, e.maxX = e.minX + i, e.minY = -t.T * n, e.maxY = e.minY + n } destroy(t = !1) { if (super.destroy(t), "boolean" == typeof t ? t : t?.texture) { const s = "boolean" == typeof t ? t : t?.textureSource; this.Y.destroy(s) } this.Y = null, this.bs = null, this.gs = null, this.xs = null, this.ps = null } get anchor() { return this.xs } set anchor(t) { "number" == typeof t ? this.xs.set(t) : this.xs.copyFrom(t) } get width() { return Math.abs(this.scale.x) * this.Y.orig.width } set width(t) { this.Ut(t, this.Y.orig.width), this.ys = t } get height() { return Math.abs(this.scale.y) * this.Y.orig.height } set height(t) { this.It(t, this.Y.orig.height), this.ws = t } getSize(t) { return t || (t = {}), t.width = Math.abs(this.scale.x) * this.Y.orig.width, t.height = Math.abs(this.scale.y) * this.Y.orig.height, t } setSize(t, s) { "object" == typeof t ? (s = t.height ?? t.width, t = t.width) : s ?? (s = t), void 0 !== t && this.Ut(t, this.Y.orig.width), void 0 !== s && this.It(s, this.Y.orig.height) } } const ws = new tt; function Ms(t, s, e) { const i = ws; t.measurable = !0, qt(t, e, i), s.addBoundsMask(i), t.measurable = !1 } function Ts(t, s, e) { const i = Nt.get(); t.measurable = !0; const n = Vt.get().identity(); ss(t, i, As(t, e, n)), t.measurable = !1, s.addBoundsMask(i), Vt.return(n), Nt.return(i) } function As(t, s, e) { return t ? (t !== s && (As(t.parent, s, e), t.updateLocalTransform(), e.append(t.localTransform)), e) : (Et(), e) } class Cs { constructor(t) { this.priority = 0, this.inverse = !1, this.pipe = "alphaMask", t?.mask && this.init(t.mask) } init(t) { this.mask = t, this.renderMaskToTexture = !(t instanceof ys), this.mask.renderable = this.renderMaskToTexture, this.mask.includeInBuild = !this.renderMaskToTexture, this.mask.measurable = !1 } reset() { null !== this.mask && (this.mask.measurable = !0, this.mask = null) } addBounds(t, s) { this.inverse || Ms(this.mask, t, s) } addLocalBounds(t, s) { Ts(this.mask, t, s) } containsPoint(t, s) { return s(this.mask, t) } destroy() { this.reset() } static test(t) { return t instanceof ys } } Cs.extension = r.MaskEffect; class _s { constructor(t) { this.priority = 0, this.pipe = "colorMask", t?.mask && this.init(t.mask) } init(t) { this.mask = t } destroy() { } static test(t) { return "number" == typeof t } } _s.extension = r.MaskEffect; class Ss { constructor(t) { this.priority = 0, this.pipe = "stencilMask", t?.mask && this.init(t.mask) } init(t) { this.mask = t, this.mask.includeInBuild = !1, this.mask.measurable = !1 } reset() { null !== this.mask && (this.mask.measurable = !0, this.mask.includeInBuild = !0, this.mask = null) } addBounds(t, s) { Ms(this.mask, t, s) } addLocalBounds(t, s) { Ts(this.mask, t, s) } containsPoint(t, s) { return s(this.mask, t) } destroy() { this.reset() } static test(t) { return t instanceof bs } } Ss.extension = r.MaskEffect; let Ps = { createCanvas: (t, s) => { const e = document.createElement("canvas"); return e.width = t, e.height = s, e }, createImage: () => new Image, getCanvasRenderingContext2D: () => CanvasRenderingContext2D, getWebGLRenderingContext: () => WebGLRenderingContext, getNavigator: () => navigator, getBaseUrl: () => document.baseURI ?? window.location.href, getFontFaceSet: () => document.fonts, fetch: (t, s) => fetch(t, s), parseXML: t => (new DOMParser).parseFromString(t, "text/xml") }; const ks = { get: () => Ps, set(t) { Ps = t } }; class Fs extends q { constructor(t) { t.resource || (t.resource = ks.get().createCanvas()), t.width || (t.width = t.resource.width, t.autoDensity || (t.width /= t.resolution)), t.height || (t.height = t.resource.height, t.autoDensity || (t.height /= t.resolution)), super(t), this.uploadMethodId = "image", this.autoDensity = t.autoDensity, this.resizeCanvas(), this.transparent = !!t.transparent } resizeCanvas() { this.autoDensity && "style" in this.resource && (this.resource.style.width = `${this.width}px`, this.resource.style.height = `${this.height}px`), this.resource.width === this.pixelWidth && this.resource.height === this.pixelHeight || (this.resource.width = this.pixelWidth, this.resource.height = this.pixelHeight) } resize(t = this.width, s = this.height, e = this.$) { const i = super.resize(t, s, e); return i && this.resizeCanvas(), i } static test(t) { return globalThis.HTMLCanvasElement && t instanceof HTMLCanvasElement || globalThis.OffscreenCanvas && t instanceof OffscreenCanvas } get context2D() { return this.Ms || (this.Ms = this.resource.getContext("2d")) } } Fs.extension = r.TextureSource; class Es extends q { constructor(t) { super(t), this.uploadMethodId = "image", this.autoGarbageCollect = !0 } static test(t) { return globalThis.HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap || globalThis.VideoFrame && t instanceof VideoFrame } } Es.extension = r.TextureSource; var Rs = (t => (t[t.INTERACTION = 50] = "INTERACTION", t[t.HIGH = 25] = "HIGH", t[t.NORMAL = 0] = "NORMAL", t[t.LOW = -25] = "LOW", t[t.UTILITY = -50] = "UTILITY", t))(Rs || {}); class Os { constructor(t, s = null, e = 0, i = !1) { this.next = null, this.previous = null, this.Ts = !1, this.As = t, this.Cs = s, this.priority = e, this._s = i } match(t, s = null) { return this.As === t && this.Cs === s } emit(t) { this.As && (this.Cs ? this.As.call(this.Cs, t) : this.As(t)); const s = this.next; return this._s && this.destroy(!0), this.Ts && (this.next = null), s } connect(t) { this.previous = t, t.next && (t.next.previous = this), this.next = t.next, t.next = this } destroy(t = !1) { this.Ts = !0, this.As = null, this.Cs = null, this.previous && (this.previous.next = this.next), this.next && (this.next.previous = this.previous); const s = this.next; return this.next = t ? null : s, this.previous = null, s } } const Us = class t { constructor() { this.autoStart = !1, this.deltaTime = 1, this.lastTime = -1, this.speed = 1, this.started = !1, this.Ss = null, this.Ps = 100, this.ks = 0, this.Fs = !1, this.Es = -1, this.Rs = new Os(null, null, 1 / 0), this.deltaMS = 1 / t.targetFPMS, this.elapsedMS = 1 / t.targetFPMS, this.Os = t => { this.Ss = null, this.started && (this.update(t), this.started && null === this.Ss && this.Rs.next && (this.Ss = requestAnimationFrame(this.Os))) } } Us() { null === this.Ss && this.Rs.next && (this.lastTime = performance.now(), this.Es = this.lastTime, this.Ss = requestAnimationFrame(this.Os)) } Is() { null !== this.Ss && (cancelAnimationFrame(this.Ss), this.Ss = null) } Bs() { this.started ? this.Us() : this.autoStart && this.start() } add(t, s, e = Rs.NORMAL) { return this.$s(new Os(t, s, e)) } addOnce(t, s, e = Rs.NORMAL) { return this.$s(new Os(t, s, e, !0)) } $s(t) { let s = this.Rs.next, e = this.Rs; if (s) { for (; s;) { if (t.priority > s.priority) { t.connect(e); break } e = s, s = s.next } t.previous || t.connect(e) } else t.connect(e); return this.Bs(), this } remove(t, s) { let e = this.Rs.next; for (; e;)e = e.match(t, s) ? e.destroy() : e.next; return this.Rs.next || this.Is(), this } get count() { if (!this.Rs) return 0; let t = 0, s = this.Rs; for (; s = s.next;)t++; return t } start() { this.started || (this.started = !0, this.Us()) } stop() { this.started && (this.started = !1, this.Is()) } destroy() { if (!this.Fs) { this.stop(); let t = this.Rs.next; for (; t;)t = t.destroy(!0); this.Rs.destroy(), this.Rs = null } } update(s = performance.now()) { let e; if (s > this.lastTime) { if (e = this.elapsedMS = s - this.lastTime, e > this.Ps && (e = this.Ps), e *= this.speed, this.ks) { const t = s - this.Es | 0; if (t < this.ks) return; this.Es = s - t % this.ks } this.deltaMS = e, this.deltaTime = this.deltaMS * t.targetFPMS; const i = this.Rs; let n = i.next; for (; n;)n = n.emit(this); i.next || this.Is() } else this.deltaTime = this.deltaMS = this.elapsedMS = 0; this.lastTime = s } get FPS() { return 1e3 / this.elapsedMS } get minFPS() { return 1e3 / this.Ps } set minFPS(s) { const e = Math.min(this.maxFPS, s), i = Math.min(Math.max(0, e) / 1e3, t.targetFPMS); this.Ps = 1 / i } get maxFPS() { return this.ks ? Math.round(1e3 / this.ks) : 0 } set maxFPS(t) { if (0 === t) this.ks = 0; else { const s = Math.max(this.minFPS, t); this.ks = 1 / (s / 1e3) } } static get shared() { if (!t.Gs) { const s = t.Gs = new t; s.autoStart = !0, s.Fs = !0 } return t.Gs } static get system() { if (!t.zs) { const s = t.zs = new t; s.autoStart = !0, s.Fs = !0 } return t.zs } }; Us.targetFPMS = .06; let Is, Bs = Us; const $s = class t extends q { constructor(s) { super(s), this.isReady = !1, this.uploadMethodId = "video", s = { ...t.defaultOptions, ...s }, this.Ds = !0, this.js = !1, this.Ls = s.updateFPS || 0, this.Vs = 0, this.autoPlay = !1 !== s.autoPlay, this.alphaMode = s.alphaMode ?? "premultiply-alpha-on-upload", this.Ns = this.Ns.bind(this), this.Ws = null, this.Hs = null, this.qs = null, this.Xs = null, this.Ys = this.Ys.bind(this), this.Ks = this.Ks.bind(this), this.Zs = this.Zs.bind(this), this.Qs = this.Qs.bind(this), this.Js = this.Js.bind(this), this.te = this.te.bind(this), !1 !== s.autoLoad && this.load() } updateFrame() { if (!this.destroyed) { if (this.Ls) { const t = Bs.shared.elapsedMS * this.resource.playbackRate; this.Vs = Math.floor(this.Vs - t) } (!this.Ls || this.Vs <= 0) && (this.Vs = this.Ls ? Math.floor(1e3 / this.Ls) : 0), this.isValid && this.update() } } Ns() { this.updateFrame(), this.destroyed ? this.Ws = null : this.Ws = this.resource.requestVideoFrameCallback(this.Ns) } get isValid() { return !!this.resource.videoWidth && !!this.resource.videoHeight } async load() { if (this.Hs) return this.Hs; const t = this.resource, s = this.options; return (t.readyState === t.HAVE_ENOUGH_DATA || t.readyState === t.HAVE_FUTURE_DATA) && t.width && t.height && (t.complete = !0), t.addEventListener("play", this.Qs), t.addEventListener("pause", this.Js), t.addEventListener("seeked", this.te), this.se() ? this.ee() : (s.preload || t.addEventListener("canplay", this.Ys), t.addEventListener("canplaythrough", this.Ks), t.addEventListener("error", this.Zs, !0)), this.alphaMode = await async function () { return Is ?? (Is = (async () => { const t = ks.get().createCanvas(1, 1).getContext("webgl"); if (!t) return "premultiply-alpha-on-upload"; const s = await new Promise(t => { const s = document.createElement("video"); s.onloadeddata = () => t(s), s.onerror = () => t(null), s.autoplay = !1, s.crossOrigin = "anonymous", s.preload = "auto", s.src = "data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=", s.load() }); if (!s) return "premultiply-alpha-on-upload"; const e = t.createTexture(); t.bindTexture(t.TEXTURE_2D, e); const i = t.createFramebuffer(); t.bindFramebuffer(t.FRAMEBUFFER, i), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, e, 0), t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1), t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, t.NONE), t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, s); const n = new Uint8Array(4); return t.readPixels(0, 0, 1, 1, t.RGBA, t.UNSIGNED_BYTE, n), t.deleteFramebuffer(i), t.deleteTexture(e), t.getExtension("WEBGL_lose_context")?.loseContext(), n[0] <= n[3] ? "premultiplied-alpha" : "premultiply-alpha-on-upload" })()), Is }(), this.Hs = new Promise((e, i) => { this.isValid ? e(this) : (this.qs = e, this.Xs = i, void 0 !== s.preloadTimeoutMs && (this.ie = setTimeout(() => { this.Zs(new ErrorEvent(`Preload exceeded timeout of ${s.preloadTimeoutMs}ms`)) })), t.load()) }), this.Hs } Zs(t) { this.resource.removeEventListener("error", this.Zs, !0), this.emit("error", t), this.Xs && (this.Xs(t), this.Xs = null, this.qs = null) } ne() { const t = this.resource; return !t.paused && !t.ended } se() { return this.resource.readyState > 2 } Qs() { this.isValid || this.ee(), this.re() } Js() { this.re() } te() { this.Ds && !this.ne() && (this.Vs = 0, this.updateFrame(), this.Vs = 0) } Ys() { this.resource.removeEventListener("canplay", this.Ys), this.ee() } Ks() { this.resource.removeEventListener("canplaythrough", this.Ys), this.ie && (clearTimeout(this.ie), this.ie = void 0), this.ee() } ee() { const t = this.resource; this.isValid && (this.isReady = !0, this.resize(t.videoWidth, t.videoHeight)), this.Vs = 0, this.updateFrame(), this.Vs = 0, this.qs && (this.qs(this), this.qs = null, this.Xs = null), this.ne() ? this.Qs() : this.autoPlay && this.resource.play() } destroy() { this.re(); const t = this.resource; t && (t.removeEventListener("play", this.Qs), t.removeEventListener("pause", this.Js), t.removeEventListener("seeked", this.te), t.removeEventListener("canplay", this.Ys), t.removeEventListener("canplaythrough", this.Ks), t.removeEventListener("error", this.Zs, !0), t.pause(), t.src = "", t.load()), super.destroy() } get autoUpdate() { return this.Ds } set autoUpdate(t) { t !== this.Ds && (this.Ds = t, this.re()) } get updateFPS() { return this.Ls } set updateFPS(t) { t !== this.Ls && (this.Ls = t, this.re()) } re() { this.Ds && this.ne() ? !this.Ls && this.resource.requestVideoFrameCallback ? (this.js && (Bs.shared.remove(this.updateFrame, this), this.js = !1, this.Vs = 0), null === this.Ws && (this.Ws = this.resource.requestVideoFrameCallback(this.Ns))) : (null !== this.Ws && (this.resource.cancelVideoFrameCallback(this.Ws), this.Ws = null), this.js || (Bs.shared.add(this.updateFrame, this), this.js = !0, this.Vs = 0)) : (null !== this.Ws && (this.resource.cancelVideoFrameCallback(this.Ws), this.Ws = null), this.js && (Bs.shared.remove(this.updateFrame, this), this.js = !1, this.Vs = 0)) } static test(t) { return globalThis.HTMLVideoElement && t instanceof HTMLVideoElement } }; $s.extension = r.TextureSource, $s.defaultOptions = { ...q.defaultOptions, autoLoad: !0, autoPlay: !0, updateFPS: 0, crossorigin: !0, loop: !1, muted: !0, playsinline: !0, preload: !1 }, $s.MIME_TYPES = { ogv: "video/ogg", mov: "video/quicktime", m4v: "video/mp4" }; let Gs = $s; const zs = (t, s, e = !1) => (Array.isArray(t) || (t = [t]), s ? t.map(t => "string" == typeof t || e ? s(t) : t) : t), Ds = new class { constructor() { this.oe = [], this.he = new Map, this.ae = new Map } reset() { this.ae.clear(), this.he.clear() } has(t) { return this.he.has(t) } get(t) { const s = this.he.get(t); return s || Et(), s } set(t, s) { const e = zs(t); let i; for (let h = 0; h < this.parsers.length; h++) { const t = this.parsers[h]; if (t.test(s)) { i = t.getCacheableAssets(e, s); break } } const n = new Map(Object.entries(i || {})); i || e.forEach(t => { n.set(t, s) }); const r = [...n.keys()], o = { cacheKeys: r, keys: e }; e.forEach(t => { this.ae.set(t, o) }), r.forEach(t => { const e = i ? i[t] : s; this.he.has(t) && this.he.get(t) !== e && Et(), this.he.set(t, n.get(t)) }) } remove(t) { if (!this.ae.has(t)) return void Et(); const s = this.ae.get(t); s.cacheKeys.forEach(t => { this.he.delete(t) }), s.keys.forEach(t => { this.ae.delete(t) }) } get parsers() { return this.oe } }, js = []; function Ls(t = {}) { const s = t && t.resource, e = s ? t.resource : t, i = s ? t : { resource: t }; for (let n = 0; n < js.length; n++) { const t = js[n]; if (t.test(e)) return new t(i) } throw new Error(`Could not find a source type for resource: ${i.resource}`) } a.handleByList(r.TextureSource, js), Z.from = function (t, s = !1) { return "string" == typeof t ? Ds.get(t) : t instanceof q ? new Z({ source: t }) : function (t = {}, s = !1) { const e = t && t.resource, i = e ? t.resource : t, n = e ? t : { resource: t }; if (!s && Ds.has(i)) return Ds.get(i); const r = new Z({ source: Ls(n) }); return r.on("destroy", () => { Ds.has(i) && Ds.remove(i) }), s || Ds.set(i, r), r }(t, s) }, q.from = Ls, a.add(Cs, _s, Ss, Gs, Es, Fs, X); var Vs = (t => (t[t.Low = 0] = "Low", t[t.Normal = 1] = "Normal", t[t.High = 2] = "High", t))(Vs || {}); function Ns(t) { if ("string" != typeof t) throw new TypeError(`Path must be a string. Received ${JSON.stringify(t)}`) } function Ws(t) { return t.split("?")[0].split("#")[0] } const Hs = { toPosix: t => t.replace(new RegExp("\\".replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "g"), "/"), isUrl(t) { return /^https?:/.test(this.toPosix(t)) }, isDataUrl: t => /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(t), isBlobUrl: t => t.startsWith("blob:"), hasProtocol(t) { return /^[^/:]+:/.test(this.toPosix(t)) }, getProtocol(t) { Ns(t), t = this.toPosix(t); const s = /^file:\/\/\//.exec(t); if (s) return s[0]; const e = /^[^/:]+:\/{0,2}/.exec(t); return e ? e[0] : "" }, toAbsolute(t, s, e) { if (Ns(t), this.isDataUrl(t) || this.isBlobUrl(t)) return t; const i = Ws(this.toPosix(s ?? ks.get().getBaseUrl())), n = Ws(this.toPosix(e ?? this.rootname(i))); return (t = this.toPosix(t)).startsWith("/") ? Hs.join(n, t.slice(1)) : this.isAbsolute(t) ? t : this.join(i, t) }, normalize(t) { if (Ns(t), 0 === t.length) return "."; if (this.isDataUrl(t) || this.isBlobUrl(t)) return t; let s = ""; const e = (t = this.toPosix(t)).startsWith("/"); this.hasProtocol(t) && (s = this.rootname(t), t = t.slice(s.length)); const i = t.endsWith("/"); return (t = function (t) { let s = "", e = 0, i = -1, n = 0, r = -1; for (let o = 0; o <= t.length; ++o) { if (o < t.length) r = t.charCodeAt(o); else { if (47 === r) break; r = 47 } if (47 === r) { if (i === o - 1 || 1 === n); else if (i !== o - 1 && 2 === n) { if (s.length < 2 || 2 !== e || 46 !== s.charCodeAt(s.length - 1) || 46 !== s.charCodeAt(s.length - 2)) if (s.length > 2) { const t = s.lastIndexOf("/"); if (t !== s.length - 1) { -1 === t ? (s = "", e = 0) : (s = s.slice(0, t), e = s.length - 1 - s.lastIndexOf("/")), i = o, n = 0; continue } } else if (2 === s.length || 1 === s.length) { s = "", e = 0, i = o, n = 0; continue } } else s.length > 0 ? s += `/${t.slice(i + 1, o)}` : s = t.slice(i + 1, o), e = o - i - 1; i = o, n = 0 } else 46 === r && -1 !== n ? ++n : n = -1 } return s }(t)).length > 0 && i && (t += "/"), e ? `/${t}` : s + t }, isAbsolute(t) { return Ns(t), t = this.toPosix(t), !!this.hasProtocol(t) || t.startsWith("/") }, join(...t) { if (0 === t.length) return "."; let s; for (let e = 0; e < t.length; ++e) { const i = t[e]; if (Ns(i), i.length > 0) if (void 0 === s) s = i; else { const n = t[e - 1] ?? ""; this.joinExtensions.includes(this.extname(n).toLowerCase()) ? s += `/../${i}` : s += `/${i}` } } return void 0 === s ? "." : this.normalize(s) }, dirname(t) { if (Ns(t), 0 === t.length) return "."; let s = (t = this.toPosix(t)).charCodeAt(0); const e = 47 === s; let i = -1, n = !0; const r = this.getProtocol(t), o = t; for (let h = (t = t.slice(r.length)).length - 1; h >= 1; --h)if (s = t.charCodeAt(h), 47 === s) { if (!n) { i = h; break } } else n = !1; return -1 === i ? e ? "/" : this.isUrl(o) ? r + t : r : e && 1 === i ? "//" : r + t.slice(0, i) }, rootname(t) { Ns(t); let s = ""; if (s = (t = this.toPosix(t)).startsWith("/") ? "/" : this.getProtocol(t), this.isUrl(t)) { const e = t.indexOf("/", s.length); s = -1 !== e ? t.slice(0, e) : t, s.endsWith("/") || (s += "/") } return s }, basename(t, s) { Ns(t), s && Ns(s), t = Ws(this.toPosix(t)); let e, i = 0, n = -1, r = !0; if (void 0 !== s && s.length > 0 && s.length <= t.length) { if (s.length === t.length && s === t) return ""; let o = s.length - 1, h = -1; for (e = t.length - 1; e >= 0; --e) { const a = t.charCodeAt(e); if (47 === a) { if (!r) { i = e + 1; break } } else -1 === h && (r = !1, h = e + 1), o >= 0 && (a === s.charCodeAt(o) ? -1 === --o && (n = e) : (o = -1, n = h)) } return i === n ? n = h : -1 === n && (n = t.length), t.slice(i, n) } for (e = t.length - 1; e >= 0; --e)if (47 === t.charCodeAt(e)) { if (!r) { i = e + 1; break } } else -1 === n && (r = !1, n = e + 1); return -1 === n ? "" : t.slice(i, n) }, extname(t) { Ns(t); let s = -1, e = 0, i = -1, n = !0, r = 0; for (let o = (t = Ws(this.toPosix(t))).length - 1; o >= 0; --o) { const h = t.charCodeAt(o); if (47 !== h) -1 === i && (n = !1, i = o + 1), 46 === h ? -1 === s ? s = o : 1 !== r && (r = 1) : -1 !== s && (r = -1); else if (!n) { e = o + 1; break } } return -1 === s || -1 === i || 0 === r || 1 === r && s === i - 1 && s === e + 1 ? "" : t.slice(s, i) }, parse(t) { Ns(t); const s = { root: "", dir: "", base: "", ext: "", name: "" }; if (0 === t.length) return s; let e = (t = Ws(this.toPosix(t))).charCodeAt(0); const i = this.isAbsolute(t); let n; s.root = this.rootname(t), n = i || this.hasProtocol(t) ? 1 : 0; let r = -1, o = 0, h = -1, a = !0, l = t.length - 1, u = 0; for (; l >= n; --l)if (e = t.charCodeAt(l), 47 !== e) -1 === h && (a = !1, h = l + 1), 46 === e ? -1 === r ? r = l : 1 !== u && (u = 1) : -1 !== r && (u = -1); else if (!a) { o = l + 1; break } return -1 === r || -1 === h || 0 === u || 1 === u && r === h - 1 && r === o + 1 ? -1 !== h && (s.base = s.name = 0 === o && i ? t.slice(1, h) : t.slice(o, h)) : (0 === o && i ? (s.name = t.slice(1, r), s.base = t.slice(1, h)) : (s.name = t.slice(o, r), s.base = t.slice(o, h)), s.ext = t.slice(r, h)), s.dir = this.dirname(t), s }, sep: "/", delimiter: ":", joinExtensions: [".html"] }; function qs(t, s, e, i, n) { const r = s[e]; for (let o = 0; o < r.length; o++) { const h = r[o]; e < s.length - 1 ? qs(t.replace(i[e], h), s, e + 1, i, n) : n.push(t.replace(i[e], h)) } } function Xs(t) { const s = t.match(/\{(.*?)\}/g), e = []; if (s) { const i = []; s.forEach(t => { const s = t.substring(1, t.length - 1).split(","); i.push(s) }), qs(t, i, 0, s, e) } else e.push(t); return e } const Ys = t => !Array.isArray(t); class Ks { constructor() { this.le = { connector: "-", createBundleAssetId: (t, s) => `${t}${this.ue}${s}`, extractAssetIdFromBundle: (t, s) => s.replace(`${t}${this.ue}`, "") }, this.ue = this.le.connector, this.ce = this.le.createBundleAssetId, this.fe = this.le.extractAssetIdFromBundle, this.de = {}, this.pe = [], this.oe = [], this.me = {}, this.ge = {} } setBundleIdentifier(t) { if (this.ue = t.connector ?? this.ue, this.ce = t.createBundleAssetId ?? this.ce, this.fe = t.extractAssetIdFromBundle ?? this.fe, "bar" !== this.fe("foo", this.ce("foo", "bar"))) throw new Error("[Resolver] GenerateBundleAssetId are not working correctly") } prefer(...t) { t.forEach(t => { this.pe.push(t), t.priority || (t.priority = Object.keys(t.params)) }), this.me = {} } set basePath(t) { this.ve = t } get basePath() { return this.ve } set rootPath(t) { this.be = t } get rootPath() { return this.be } get parsers() { return this.oe } reset() { this.setBundleIdentifier(this.le), this.de = {}, this.pe = [], this.me = {}, this.be = null, this.ve = null, this.xe = null, this.ge = {}, this.ye = null } setDefaultSearchParams(t) { if ("string" == typeof t) this.ye = t; else { const s = t; this.ye = Object.keys(s).map(t => `${encodeURIComponent(t)}=${encodeURIComponent(s[t])}`).join("&") } } getAlias(t) { const { alias: s, src: e } = t; return zs(s || e, t => "string" == typeof t ? t : Array.isArray(t) ? t.map(t => t?.src ?? t) : t?.src ? t.src : t, !0) } addManifest(t) { this.xe && Et(), this.xe = t, t.bundles.forEach(t => { this.addBundle(t.name, t.assets) }) } addBundle(t, s) { const e = []; let i = s; Array.isArray(s) || (i = Object.entries(s).map(([t, s]) => "string" == typeof s || Array.isArray(s) ? { alias: t, src: s } : { alias: t, ...s })), i.forEach(s => { const i = s.src, n = s.alias; let r; if ("string" == typeof n) { const s = this.ce(t, n); e.push(s), r = [n, s] } else { const s = n.map(s => this.ce(t, s)); e.push(...s), r = [...n, ...s] } this.add({ ...s, alias: r, src: i }) }), this.ge[t] = e } add(t) { const s = []; let e; Array.isArray(t) ? s.push(...t) : s.push(t), e = t => { this.hasKey(t) && Et() }, zs(s).forEach(t => { const { src: s } = t; let { data: i, format: n, loadParser: r, parser: o } = t; const h = zs(s).map(t => "string" == typeof t ? Xs(t) : Array.isArray(t) ? t : [t]), a = this.getAlias(t); Array.isArray(a) ? a.forEach(e) : e(a); const l = [], u = t => { const s = this.oe.find(s => s.test(t)); return { ...s?.parse(t), src: t } }; h.forEach(s => { s.forEach(s => { let e = {}; if ("object" != typeof s ? e = u(s) : (i = s.data ?? i, n = s.format ?? n, (s.loadParser || s.parser) && (r = s.loadParser ?? r, o = s.parser ?? o), e = { ...u(s.src), ...s }), !a) throw new Error(`[Resolver] alias is undefined for this asset: ${e.src}`); e = this.we(e, { aliases: a, data: i, format: n, loadParser: r, parser: o, progressSize: t.progressSize }), l.push(e) }) }), a.forEach(t => { this.de[t] = l }) }) } resolveBundle(t) { const s = Ys(t); t = zs(t); const e = {}; return t.forEach(t => { const s = this.ge[t]; if (s) { const i = this.resolve(s), n = {}; for (const s in i) { const e = i[s]; n[this.fe(t, s)] = e } e[t] = n } }), s ? e[t[0]] : e } resolveUrl(t) { const s = this.resolve(t); if ("string" != typeof t) { const t = {}; for (const e in s) t[e] = s[e].src; return t } return s.src } resolve(t) { const s = Ys(t); t = zs(t); const e = {}; return t.forEach(t => { if (!this.me[t]) if (this.de[t]) { let s = this.de[t]; const e = this.Me(s); e?.priority.forEach(t => { e.params[t].forEach(e => { const i = s.filter(s => !!s[t] && s[t] === e); i.length && (s = i) }) }), this.me[t] = s[0] } else this.me[t] = this.we({ alias: [t], src: t }, {}); e[t] = this.me[t] }), s ? e[t[0]] : e } hasKey(t) { return !!this.de[t] } hasBundle(t) { return !!this.ge[t] } Me(t) { for (let s = 0; s < t.length; s++) { const e = t[s], i = this.pe.find(t => t.params.format.includes(e.format)); if (i) return i } return this.pe[0] } Te(t) { return this.ye ? `${t}${/\?/.test(t) ? "&" : "?"}${this.ye}` : t } we(t, s) { const { aliases: e, data: i, loadParser: n, parser: r, format: o, progressSize: h } = s; return (this.ve || this.be) && (t.src = Hs.toAbsolute(t.src, this.ve, this.be)), t.alias = e ?? t.alias ?? [t.src], t.src = this.Te(t.src), t.data = { ...i || {}, ...t.data }, t.loadParser = n ?? t.loadParser, t.parser = r ?? t.parser, t.format = o ?? t.format ?? t.src.split(".").pop().split("?").shift().split("#").shift(), void 0 !== h && (t.progressSize = h), t } } Ks.RETINA_PREFIX = /@([0-9\.]+)x/; const Zs = (t, s) => { const e = s.split("?")[1]; return e && (t += `?${e}`), t }, Qs = class t { constructor(t, s) { this.linkedSheets = []; let e = t; t?.source instanceof q && (e = { texture: t, data: s }); const { texture: i, data: n, cachePrefix: r = "" } = e; this.cachePrefix = r, this.Y = i instanceof Z ? i : null, this.textureSource = i.source, this.textures = {}, this.animations = {}, this.data = n; const o = parseFloat(n.meta.scale); o ? (this.resolution = o, i.source.resolution = this.resolution) : this.resolution = i.source.$, this.Ae = this.data.frames, this.Ce = Object.keys(this.Ae), this._e = 0, this.Se = null } parse() { return new Promise(s => { this.Se = s, this._e = 0, this.Ce.length <= t.BATCH_SIZE ? (this.Pe(0), this.ke(), this.Fe()) : this.Ee() }) } Pe(s) { let e = s; const i = t.BATCH_SIZE; for (; e - s < i && e < this.Ce.length;) { const t = this.Ce[e], s = this.Ae[t], i = s.frame; if (i) { let e = null, n = null; const r = !1 !== s.trimmed && s.sourceSize ? s.sourceSize : s.frame, o = new O(0, 0, Math.floor(r.w) / this.resolution, Math.floor(r.h) / this.resolution); e = s.rotated ? new O(Math.floor(i.x) / this.resolution, Math.floor(i.y) / this.resolution, Math.floor(i.h) / this.resolution, Math.floor(i.w) / this.resolution) : new O(Math.floor(i.x) / this.resolution, Math.floor(i.y) / this.resolution, Math.floor(i.w) / this.resolution, Math.floor(i.h) / this.resolution), !1 !== s.trimmed && s.spriteSourceSize && (n = new O(Math.floor(s.spriteSourceSize.x) / this.resolution, Math.floor(s.spriteSourceSize.y) / this.resolution, Math.floor(i.w) / this.resolution, Math.floor(i.h) / this.resolution)), this.textures[t] = new Z({ source: this.textureSource, frame: e, orig: o, trim: n, rotate: s.rotated ? 2 : 0, defaultAnchor: s.anchor, defaultBorders: s.borders, label: t.toString() }) } e++ } } ke() { const t = this.data.animations || {}; for (const s in t) { this.animations[s] = []; for (let e = 0; e < t[s].length; e++) { const i = t[s][e]; this.animations[s].push(this.textures[i]) } } } Fe() { const t = this.Se; this.Se = null, this._e = 0, t.call(this, this.textures) } Ee() { this.Pe(this._e * t.BATCH_SIZE), this._e++, setTimeout(() => { this._e * t.BATCH_SIZE < this.Ce.length ? this.Ee() : (this.ke(), this.Fe()) }, 0) } destroy(t = !1) { for (const s in this.textures) this.textures[s].destroy(); this.Ae = null, this.Ce = null, this.data = null, this.textures = null, t && (this.Y?.destroy(), this.textureSource.destroy()), this.Y = null, this.textureSource = null, this.linkedSheets = [] } }; Qs.BATCH_SIZE = 1e3; let Js = Qs; const te = ["jpg", "png", "jpeg", "avif", "webp", "basis", "etc2", "bc7", "bc6h", "bc5", "bc4", "bc3", "bc2", "bc1", "eac", "astc"]; function se(t, s, e) { const i = {}; if (t.forEach(t => { i[t] = s }), Object.keys(s.textures).forEach(t => { i[`${s.cachePrefix}${t}`] = s.textures[t] }), !e) { const e = Hs.dirname(t[0]); s.linkedSheets.forEach((t, n) => { const r = se([`${e}/${s.data.meta.related_multi_packs[n]}`], t, !0); Object.assign(i, r) }) } return i } const ee = { extension: r.Asset, cache: { test: t => t instanceof Js, getCacheableAssets: (t, s) => se(t, s, !1) }, resolver: { extension: { type: r.ResolveParser, name: "resolveSpritesheet" }, test: t => { const s = t.split("?")[0].split("."), e = s.pop(), i = s.pop(); return "json" === e && te.includes(i) }, parse: t => { const s = t.split("."); return { resolution: parseFloat(Ks.RETINA_PREFIX.exec(t)?.[1] ?? "1"), format: s[s.length - 2], src: t } } }, loader: { name: "spritesheetLoader", id: "spritesheet", extension: { type: r.LoadParser, priority: Vs.Normal, name: "spritesheetLoader" }, testParse: async (t, s) => ".json" === Hs.extname(s.src).toLowerCase() && !!t.frames, async parse(t, s, e) { const { texture: i, imageFilename: n, textureOptions: r, cachePrefix: o } = s?.data ?? {}; let h, a = Hs.dirname(s.src); if (a && a.lastIndexOf("/") !== a.length - 1 && (a += "/"), i instanceof Z) h = i; else { const i = Zs(a + (n ?? t.meta.image), s.src); h = (await e.load([{ src: i, data: r }]))[i] } const l = new Js({ texture: h.source, data: t, cachePrefix: o }); await l.parse(); const u = t?.meta?.related_multi_packs; if (Array.isArray(u)) { const t = []; for (const n of u) { if ("string" != typeof n) continue; let i = a + n; s.data?.ignoreMultiPack || (i = Zs(i, s.src), t.push(e.load({ src: i, data: { textureOptions: r, ignoreMultiPack: !0 } }))) } const i = await Promise.all(t); l.linkedSheets = i, i.forEach(t => { t.linkedSheets = [l].concat(l.linkedSheets.filter(s => s !== t)) }) } return l }, async unload(t, s, e) { await e.unload(t.textureSource.Re), t.destroy(!1) } } }; a.add(ee); class ie { constructor(t) { this.Oe = "", this.A = null, this.Ue = !1, this.updateTranslation = () => { if (!this.Ie) return; const t = this.Ie.getBoundingClientRect(), s = this.Ie.width, e = this.Ie.height, i = t.width / s * this.Be.resolution, n = t.height / e * this.Be.resolution, r = `translate(${t.left}px, ${t.top}px) scale(${i}, ${n})`; r !== this.Oe && (this.$e.style.transform = r, this.Oe = r) }, this.$e = t.domElement, this.Be = t.renderer, globalThis.OffscreenCanvas && this.Be.canvas instanceof OffscreenCanvas || (this.Ie = this.Be.canvas, this.Ge()) } get canvas() { return this.Ie } ensureAttached() { !this.$e.parentNode && this.Ie.parentNode && (this.Ie.parentNode.appendChild(this.$e), this.updateTranslation()) } Ge() { "ResizeObserver" in globalThis ? (this.A && (this.A.disconnect(), this.A = null), this.A = new ResizeObserver(t => { for (const s of t) { if (s.target !== this.Ie) continue; const t = this.canvas.width, e = this.canvas.height, i = s.contentRect.width / t * this.Be.resolution, n = s.contentRect.height / e * this.Be.resolution; (this.ze !== i || this.De !== n) && (this.updateTranslation(), this.ze = i, this.De = n) } }), this.A.observe(this.Ie)) : this.Ue || Bs.shared.add(this.updateTranslation, this, Rs.HIGH) } destroy() { this.A ? (this.A.disconnect(), this.A = null) : this.Ue && Bs.shared.remove(this.updateTranslation), this.$e = null, this.Be = null, this.Ie = null, this.Ue = !1, this.Oe = "", this.ze = null, this.De = null } } class ne { constructor(t) { this.bubbles = !0, this.cancelBubble = !0, this.cancelable = !1, this.composed = !1, this.defaultPrevented = !1, this.eventPhase = ne.prototype.NONE, this.propagationStopped = !1, this.propagationImmediatelyStopped = !1, this.layer = new x, this.page = new x, this.NONE = 0, this.CAPTURING_PHASE = 1, this.AT_TARGET = 2, this.BUBBLING_PHASE = 3, this.manager = t } get layerX() { return this.layer.x } get layerY() { return this.layer.y } get pageX() { return this.page.x } get pageY() { return this.page.y } get data() { return this } composedPath() { return !this.manager || this.path && this.path[this.path.length - 1] === this.target || (this.path = this.target ? this.manager.propagationPath(this.target) : []), this.path } initEvent(t, s, e) { throw new Error("initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.") } initUIEvent(t, s, e, i, n) { throw new Error("initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.") } preventDefault() { this.nativeEvent instanceof Event && this.nativeEvent.cancelable && this.nativeEvent.preventDefault(), this.defaultPrevented = !0 } stopImmediatePropagation() { this.propagationImmediatelyStopped = !0 } stopPropagation() { this.propagationStopped = !0 } } var re = /iPhone/i, oe = /iPod/i, he = /iPad/i, ae = /\biOS-universal(?:.+)Mac\b/i, le = /\bAndroid(?:.+)Mobile\b/i, ue = /Android/i, ce = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i, fe = /Silk/i, de = /Windows Phone/i, pe = /\bWindows(?:.+)ARM\b/i, me = /BlackBerry/i, ge = /BB10/i, ve = /Opera Mini/i, be = /\b(CriOS|Chrome)(?:.+)Mobile/i, xe = /Mobile(?:.+)Firefox\b/i, ye = function (t) { return void 0 !== t && "MacIntel" === t.platform && "number" == typeof t.maxTouchPoints && t.maxTouchPoints > 1 && "undefined" == typeof MSStream }; function we(t) { var s = { userAgent: "", platform: "", maxTouchPoints: 0 }; t || "undefined" == typeof navigator ? "string" == typeof t ? s.userAgent = t : t && t.userAgent && (s = { userAgent: t.userAgent, platform: t.platform, maxTouchPoints: t.maxTouchPoints || 0 }) : s = { userAgent: navigator.userAgent, platform: navigator.platform, maxTouchPoints: navigator.maxTouchPoints || 0 }; var e = s.userAgent, i = e.split("[FBAN"); void 0 !== i[1] && (e = i[0]), void 0 !== (i = e.split("Twitter"))[1] && (e = i[0]); var n = function (t) { return function (s) { return s.test(t) } }(e), r = { apple: { phone: n(re) && !n(de), ipod: n(oe), tablet: !n(re) && (n(he) || ye(s)) && !n(de), universal: n(ae), device: (n(re) || n(oe) || n(he) || n(ae) || ye(s)) && !n(de) }, amazon: { phone: n(ce), tablet: !n(ce) && n(fe), device: n(ce) || n(fe) }, android: { phone: !n(de) && n(ce) || !n(de) && n(le), tablet: !n(de) && !n(ce) && !n(le) && (n(fe) || n(ue)), device: !n(de) && (n(ce) || n(fe) || n(le) || n(ue)) || n(/\bokhttp\b/i) }, windows: { phone: n(de), tablet: n(pe), device: n(de) || n(pe) }, other: { blackberry: n(me), blackberry10: n(ge), opera: n(ve), firefox: n(xe), chrome: n(be), device: n(me) || n(ge) || n(ve) || n(xe) || n(be) }, any: !1, phone: !1, tablet: !1 }; return r.any = r.apple.device || r.android.device || r.windows.device || r.other.device, r.phone = r.apple.phone || r.android.phone || r.windows.phone, r.tablet = r.apple.tablet || r.android.tablet || r.windows.tablet, r } const Me = (we.default ?? we)(globalThis.navigator), Te = class t { constructor(t, s = Me) { this.je = s, this.debug = !1, this.Le = !0, this.Ve = !0, this.Ne = !1, this.We = !1, this.He = null, this.qe = {}, this.Xe = 0, this.Ye = [], this.Ke = 0, this.Ze = 500, this.Qe = !1, this.Je = this.ti.bind(this), this.si = this.ei.bind(this), this.ii = null, (s.tablet || s.phone) && this.ni(), this.Be = t } get isActive() { return this.Ne } get isMobileAccessibility() { return this.We } get hookDiv() { return this.ii } get div() { return this.He } ni() { const t = document.createElement("button"); t.style.width = "1px", t.style.height = "1px", t.style.position = "absolute", t.style.top = "-1000px", t.style.left = "-1000px", t.style.zIndex = 2..toString(), t.style.backgroundColor = "#FF0000", t.title = "select to enable accessibility for this content", t.addEventListener("focus", () => { this.We = !0, this.ri(), this.oi() }), document.body.appendChild(t), this.ii = t } oi() { this.ii && (document.body.removeChild(this.ii), this.ii = null) } ri() { if (this.Ne) return; this.Ne = !0, this.He || (this.He = document.createElement("div"), this.He.style.position = "absolute", this.He.style.top = "0px", this.He.style.left = "0px", this.He.style.pointerEvents = "none", this.He.style.zIndex = 2..toString(), this.hi = new ie({ domElement: this.He, renderer: this.Be })), this.Le && globalThis.addEventListener("keydown", this.Je, !1), this.Ve && globalThis.document.addEventListener("mousemove", this.si, !0); const t = this.Be.view.canvas; if (t.parentNode) this.hi.ensureAttached(), this.ai(); else { const s = new MutationObserver(() => { t.parentNode && (s.disconnect(), this.hi.ensureAttached(), this.ai()) }); s.observe(document.body, { childList: !0, subtree: !0 }) } } ai() { this.Be.runners.postrender.add(this), this.Be.lastObjectRendered && this.li(this.Be.lastObjectRendered) } ui() { if (this.Ne && !this.We) { this.Ne = !1, globalThis.document.removeEventListener("mousemove", this.si, !0), this.Le && globalThis.addEventListener("keydown", this.Je, !1), this.Be.runners.postrender.remove(this); for (const t of this.Ye) t.ci?.parentNode && (t.ci.parentNode.removeChild(t.ci), t.ci = null), t.fi = !1; for (const t in this.qe) this.qe[t].forEach(t => { t.parentNode && t.parentNode.removeChild(t) }), delete this.qe[t]; this.He?.parentNode && this.He.parentNode.removeChild(this.He), this.qe = {}, this.Ye = [] } } li(t) { if (!t.visible || !t.accessibleChildren) return; t.accessible && (t.fi || this.di(t), t.Xe = this.Xe); const s = t.children; if (s) for (let e = 0; e < s.length; e++)this.li(s[e]) } init(s) { const e = { accessibilityOptions: { ...t.defaultOptions, ...s?.accessibilityOptions || {} } }; this.debug = e.accessibilityOptions.debug, this.Le = e.accessibilityOptions.activateOnTab, this.Ve = e.accessibilityOptions.deactivateOnMouseMove, e.accessibilityOptions.enabledByDefault && this.ri(), this.Be.runners.postrender.remove(this) } postrender() { const t = performance.now(); if (this.je.android.device && t < this.Ke) return; if (this.Ke = t + this.Ze, !(this.Be.renderingToScreen && this.Be.view.canvas || this.Qe)) return; const s = new Set; if (this.Be.lastObjectRendered) { this.li(this.Be.lastObjectRendered); for (const t of this.Ye) t.Xe === this.Xe && s.add(this.Ye.indexOf(t)) } for (let e = this.Ye.length - 1; e >= 0; e--) { const t = this.Ye[e]; s.has(e) || (t.ci && t.ci.parentNode && (t.ci.parentNode.removeChild(t.ci), this.pi(t.accessibleType).push(t.ci), t.ci = null), t.fi = !1, Bt(this.Ye, e, 1)) } this.Be.renderingToScreen && this.hi.ensureAttached(); for (let e = 0; e < this.Ye.length; e++) { const t = this.Ye[e]; if (!t.fi || !t.ci) continue; const s = t.ci, i = t.hitArea || t.getBounds().rectangle; if (t.hitArea) { const e = t.worldTransform; s.style.left = `${e.tx + i.x * e.a}px`, s.style.top = `${e.ty + i.y * e.d}px`, s.style.width = i.width * e.a + "px", s.style.height = i.height * e.d + "px" } else this.mi(i), s.style.left = `${i.x}px`, s.style.top = `${i.y}px`, s.style.width = `${i.width}px`, s.style.height = `${i.height}px` } this.Xe++ } gi(t) { t.innerHTML = `type: ${t.type}</br> title : ${t.title}</br> tabIndex: ${t.tabIndex}` } mi(t) { t.x < 0 && (t.width += t.x, t.x = 0), t.y < 0 && (t.height += t.y, t.y = 0); const { width: s, height: e } = this.Be; t.x + t.width > s && (t.width = s - t.x), t.y + t.height > e && (t.height = e - t.y) } di(t) { let s = this.pi(t.accessibleType).pop(); s ? (s.innerHTML = "", s.removeAttribute("title"), s.removeAttribute("aria-label"), s.tabIndex = 0) : ("button" === t.accessibleType ? s = document.createElement("button") : (s = document.createElement(t.accessibleType), s.style.cssText = "\n                        color: transparent;\n                        pointer-events: none;\n                        padding: 0;\n                        margin: 0;\n                        border: 0;\n                        outline: 0;\n                        background: transparent;\n                        box-sizing: border-box;\n                        user-select: none;\n                        -webkit-user-select: none;\n                        -moz-user-select: none;\n                        -ms-user-select: none;\n                    ", t.accessibleText && (s.innerText = t.accessibleText)), s.style.width = "100px", s.style.height = "100px", s.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent", s.style.position = "absolute", s.style.zIndex = 2..toString(), s.style.borderStyle = "none", navigator.userAgent.toLowerCase().includes("chrome") ? s.setAttribute("aria-live", "off") : s.setAttribute("aria-live", "polite"), navigator.userAgent.match(/rv:.*Gecko\//) ? s.setAttribute("aria-relevant", "additions") : s.setAttribute("aria-relevant", "text"), s.addEventListener("click", this.bi.bind(this)), s.addEventListener("focus", this.xi.bind(this)), s.addEventListener("focusout", this.yi.bind(this))), s.style.pointerEvents = t.accessiblePointerEvents, s.type = t.accessibleType, t.accessibleTitle && null !== t.accessibleTitle ? s.title = t.accessibleTitle : t.accessibleHint && null !== t.accessibleHint || (s.title = `container ${t.tabIndex}`), t.accessibleHint && null !== t.accessibleHint && s.setAttribute("aria-label", t.accessibleHint), t.interactive ? s.tabIndex = t.tabIndex : s.tabIndex = 0, this.debug && this.gi(s), t.fi = !0, t.ci = s, s.container = t, this.Ye.push(t), this.He.appendChild(t.ci) } wi(t, s) { const { container: e } = t.target, i = this.Be.events.rootBoundary, n = Object.assign(new ne(i), { target: e }); i.rootTarget = this.Be.lastObjectRendered, s.forEach(t => i.dispatchEvent(n, t)) } bi(t) { this.wi(t, ["click", "pointertap", "tap"]) } xi(t) { t.target.getAttribute("aria-live") || t.target.setAttribute("aria-live", "assertive"), this.wi(t, ["mouseover"]) } yi(t) { t.target.getAttribute("aria-live") || t.target.setAttribute("aria-live", "polite"), this.wi(t, ["mouseout"]) } ti(t) { 9 === t.keyCode && this.Le && this.ri() } ei(t) { 0 === t.movementX && 0 === t.movementY || this.ui() } destroy() { this.ui(), this.oi(), this.hi?.destroy(), this.hi = null, this.He = null, this.qe = null, this.Ye = null, this.Be = null, this.ii = null, globalThis.removeEventListener("keydown", this.Je), this.Je = null, globalThis.document.removeEventListener("mousemove", this.si, !0), this.si = null } setAccessibilityEnabled(t) { t ? this.ri() : this.ui() } pi(t) { return this.qe[t] || (this.qe[t] = []), this.qe[t] } }; Te.extension = { type: [r.WebGLSystem, r.WebGPUSystem], name: "accessibility" }, Te.defaultOptions = { enabledByDefault: !1, debug: !1, activateOnTab: !0, deactivateOnMouseMove: !0 }; let Ae = Te; const Ce = Object.create(null), _e = Object.create(null); function Se(t, s) { let e = _e[t]; return void 0 === e && (void 0 === Ce[s] && (Ce[s] = 1), _e[t] = e = Ce[s]++), e } let Pe, ke; function Fe() { if (!Pe || Pe?.isContextLost()) { const t = ks.get().createCanvas(); Pe = t.getContext("webgl", {}) } return Pe } function Ee() { if (!ke) { ke = "mediump"; const t = Fe(); if (t && t.getShaderPrecisionFormat) { const s = t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT); ke = s.precision ? "highp" : "mediump" } } return ke } const Re = {}, Oe = {}, Ue = { stripVersion: function (t, s) { return s ? t.replace("#version 300 es", "") : t }, ensurePrecision: function (t, s, e) { const i = e ? s.maxSupportedFragmentPrecision : s.maxSupportedVertexPrecision; if ("precision" !== t.substring(0, 9)) { let n = e ? s.requestedFragmentPrecision : s.requestedVertexPrecision; return "highp" === n && "highp" !== i && (n = "mediump"), `precision ${n} float;\n${t}` } return "highp" !== i && "precision highp" === t.substring(0, 15) ? t.replace("precision highp", "precision mediump") : t }, addProgramDefines: function (t, s, e) { return s ? t : e ? `\n\n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in varying\n        #define finalColor gl_FragColor\n        #define texture texture2D\n        #endif\n        ${t = t.replace("out vec4 finalColor;", "")}\n        ` : `\n\n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in attribute\n        #define out varying\n        #endif\n        ${t}\n        ` }, setProgramName: function (t, { name: s = "pixi-program" }, e = !0) { s = s.replace(/\s+/g, "-"); const i = e ? Re : Oe; return i[s += e ? "-fragment" : "-vertex"] ? (i[s]++, s += `-${i[s]}`) : i[s] = 1, -1 !== t.indexOf("#define SHADER_NAME") ? t : `#define SHADER_NAME ${s}\n${t}` }, insertVersion: function (t, s) { return s ? `#version 300 es\n${t}` : t } }, Ie = Object.create(null), Be = class t { constructor(s) { const e = -1 !== (s = { ...t.defaultOptions, ...s }).fragment.indexOf("#version 300 es"), i = { stripVersion: e, ensurePrecision: { requestedFragmentPrecision: s.preferredFragmentPrecision, requestedVertexPrecision: s.preferredVertexPrecision, maxSupportedVertexPrecision: "highp", maxSupportedFragmentPrecision: Ee() }, setProgramName: { name: s.name }, addProgramDefines: e, insertVersion: e }; let n = s.fragment, r = s.vertex; Object.keys(Ue).forEach(t => { const s = i[t]; n = Ue[t](n, s, !0), r = Ue[t](r, s, !1) }), this.fragment = n, this.vertex = r, this.transformFeedbackVaryings = s.transformFeedbackVaryings, this.Mi = Se(`${this.vertex}:${this.fragment}`, "gl-program") } destroy() { this.fragment = null, this.vertex = null, this.Ti = null, this.Ai = null, this.Ci = null, this.transformFeedbackVaryings = null, Ie[this._i] = null } static from(s) { const e = `${s.vertex}:${s.fragment}`; return Ie[e] || (Ie[e] = new t(s), Ie[e]._i = e), Ie[e] } }; Be.defaultOptions = { preferredVertexPrecision: "highp", preferredFragmentPrecision: "mediump" }; let $e = Be; const Ge = { uint8x2: { size: 2, stride: 2, normalised: !1 }, uint8x4: { size: 4, stride: 4, normalised: !1 }, sint8x2: { size: 2, stride: 2, normalised: !1 }, sint8x4: { size: 4, stride: 4, normalised: !1 }, unorm8x2: { size: 2, stride: 2, normalised: !0 }, unorm8x4: { size: 4, stride: 4, normalised: !0 }, snorm8x2: { size: 2, stride: 2, normalised: !0 }, snorm8x4: { size: 4, stride: 4, normalised: !0 }, uint16x2: { size: 2, stride: 4, normalised: !1 }, uint16x4: { size: 4, stride: 8, normalised: !1 }, sint16x2: { size: 2, stride: 4, normalised: !1 }, sint16x4: { size: 4, stride: 8, normalised: !1 }, unorm16x2: { size: 2, stride: 4, normalised: !0 }, unorm16x4: { size: 4, stride: 8, normalised: !0 }, snorm16x2: { size: 2, stride: 4, normalised: !0 }, snorm16x4: { size: 4, stride: 8, normalised: !0 }, float16x2: { size: 2, stride: 4, normalised: !1 }, float16x4: { size: 4, stride: 8, normalised: !1 }, float32: { size: 1, stride: 4, normalised: !1 }, float32x2: { size: 2, stride: 8, normalised: !1 }, float32x3: { size: 3, stride: 12, normalised: !1 }, float32x4: { size: 4, stride: 16, normalised: !1 }, uint32: { size: 1, stride: 4, normalised: !1 }, uint32x2: { size: 2, stride: 8, normalised: !1 }, uint32x3: { size: 3, stride: 12, normalised: !1 }, uint32x4: { size: 4, stride: 16, normalised: !1 }, sint32: { size: 1, stride: 4, normalised: !1 }, sint32x2: { size: 2, stride: 8, normalised: !1 }, sint32x3: { size: 3, stride: 12, normalised: !1 }, sint32x4: { size: 4, stride: 16, normalised: !1 } }; function ze(t) { return Ge[t] ?? Ge.float32 } const De = { f32: "float32", "vec2<f32>": "float32x2", "vec3<f32>": "float32x3", "vec4<f32>": "float32x4", vec2f: "float32x2", vec3f: "float32x3", vec4f: "float32x4", i32: "sint32", "vec2<i32>": "sint32x2", "vec3<i32>": "sint32x3", "vec4<i32>": "sint32x4", u32: "uint32", "vec2<u32>": "uint32x2", "vec3<u32>": "uint32x3", "vec4<u32>": "uint32x4", bool: "uint32", "vec2<bool>": "uint32x2", "vec3<bool>": "uint32x3", "vec4<bool>": "uint32x4" }; function je(t) { const s = /@group\((\d+)\)/, e = /@binding\((\d+)\)/, i = /var(<[^>]+>)? (\w+)/, n = /:\s*(\w+)/, r = /(\w+)\s*:\s*([\w\<\>]+)/g, o = /struct\s+(\w+)/, h = t.match(/(^|[^/])@(group|binding)\(\d+\)[^;]+;/g)?.map(t => ({ group: parseInt(t.match(s)[1], 10), binding: parseInt(t.match(e)[1], 10), name: t.match(i)[2], isUniform: "<uniform>" === t.match(i)[1], type: t.match(n)[1] })); if (!h) return { groups: [], structs: [] }; const a = t.match(/struct\s+(\w+)\s*{([^}]+)}/g)?.map(t => { const s = t.match(o)[1], e = t.match(r).reduce((t, s) => { const [e, i] = s.split(":"); return t[e.trim()] = i.trim(), t }, {}); return e ? { name: s, members: e } : null }).filter(({ name: t }) => h.some(s => s.type === t)) ?? []; return { groups: h, structs: a } } var Le = (t => (t[t.VERTEX = 1] = "VERTEX", t[t.FRAGMENT = 2] = "FRAGMENT", t[t.COMPUTE = 4] = "COMPUTE", t))(Le || {}); const Ve = Object.create(null); class Ne { constructor(t) { this.Si = 0, this.Pi = 0; const { fragment: s, vertex: e, layout: i, gpuLayout: n, name: r } = t; if (this.name = r, this.fragment = s, this.vertex = e, s.source === e.source) { const t = je(s.source); this.structsAndGroups = t } else { const t = je(e.source), i = je(s.source); this.structsAndGroups = function (t, s) { const e = new Set, i = new Set; return { structs: [...t.structs, ...s.structs].filter(t => !e.has(t.name) && (e.add(t.name), !0)), groups: [...t.groups, ...s.groups].filter(t => { const s = `${t.name}-${t.binding}`; return !i.has(s) && (i.add(s), !0) }) } }(t, i) } this.layout = i ?? function ({ groups: t }) { const s = []; for (let e = 0; e < t.length; e++) { const i = t[e]; s[i.group] || (s[i.group] = {}), s[i.group][i.name] = i.binding } return s }(this.structsAndGroups), this.gpuLayout = n ?? function ({ groups: t }) { const s = []; for (let e = 0; e < t.length; e++) { const i = t[e]; s[i.group] || (s[i.group] = []), i.isUniform ? s[i.group].push({ binding: i.binding, visibility: Le.VERTEX | Le.FRAGMENT, buffer: { type: "uniform" } }) : "sampler" === i.type ? s[i.group].push({ binding: i.binding, visibility: Le.FRAGMENT, sampler: { type: "filtering" } }) : "texture_2d" === i.type && s[i.group].push({ binding: i.binding, visibility: Le.FRAGMENT, texture: { sampleType: "float", viewDimension: "2d", multisampled: !1 } }) } return s }(this.structsAndGroups), this.autoAssignGlobalUniforms = !(void 0 === this.layout[0]?.globalUniforms), this.autoAssignLocalUniforms = !(void 0 === this.layout[1]?.localUniforms), this.ki() } ki() { const { vertex: t, fragment: s } = this, e = t.source + s.source + t.entryPoint + s.entryPoint; this.Si = Se(e, "program") } get attributeData() { return this.Ti ?? (this.Ti = function ({ source: t, entryPoint: s }) { const e = {}, i = t.indexOf(`fn ${s}`); if (-1 !== i) { const s = t.indexOf("->", i); if (-1 !== s) { const n = t.substring(i, s), r = /@location\((\d+)\)\s+([a-zA-Z0-9_]+)\s*:\s*([a-zA-Z0-9_<>]+)(?:,|\s|$)/g; let o; for (; null !== (o = r.exec(n));) { const t = De[o[3]] ?? "float32"; e[o[2]] = { location: parseInt(o[1], 10), format: t, stride: ze(t).stride, offset: 0, instance: !1, start: 0 } } } } return e }(this.vertex)), this.Ti } destroy() { this.gpuLayout = null, this.layout = null, this.structsAndGroups = null, this.fragment = null, this.vertex = null, Ve[this._i] = null } static from(t) { const s = `${t.vertex.source}:${t.fragment.source}:${t.fragment.entryPoint}:${t.vertex.entryPoint}`; return Ve[s] || (Ve[s] = new Ne(t), Ve[s]._i = s), Ve[s] } } const We = ["f32", "i32", "vec2<f32>", "vec3<f32>", "vec4<f32>", "mat2x2<f32>", "mat3x3<f32>", "mat4x4<f32>", "mat3x2<f32>", "mat4x2<f32>", "mat2x3<f32>", "mat4x3<f32>", "mat2x4<f32>", "mat3x4<f32>", "vec2<i32>", "vec3<i32>", "vec4<i32>"], He = We.reduce((t, s) => (t[s] = !0, t), {}); function qe(t, s) { switch (t) { case "f32": return 0; case "vec2<f32>": return new Float32Array(2 * s); case "vec3<f32>": return new Float32Array(3 * s); case "vec4<f32>": return new Float32Array(4 * s); case "mat2x2<f32>": return new Float32Array([1, 0, 0, 1]); case "mat3x3<f32>": return new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]); case "mat4x4<f32>": return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]) }return null } const Xe = class t { constructor(s, e) { this.R = 0, this.uid = I("uniform"), this.F = "uniformGroup", this.U = I("resource"), this.isUniformGroup = !0, this.Fi = 0, this.destroyed = !1, e = { ...t.defaultOptions, ...e }, this.uniformStructures = s; const i = {}; for (const t in s) { const e = s[t]; if (e.name = t, e.size = e.size ?? 1, !He[e.type]) { const t = e.type.match(/^array<(\w+(?:<\w+>)?),\s*(\d+)>$/); if (t) { const [, s, i] = t; throw new Error(`Uniform type ${e.type} is not supported. Use type: '${s}', size: ${i} instead.`) } throw new Error(`Uniform type ${e.type} is not supported. Supported uniform types are: ${We.join(", ")}`) } e.value ?? (e.value = qe(e.type, e.size)), i[t] = e.value } this.uniforms = i, this.Fi = 1, this.ubo = e.ubo, this.isStatic = e.isStatic, this.Ei = Se(Object.keys(i).map(t => `${t}-${s[t].type}`).join("-"), "uniform-group") } update() { this.Fi++ } }; Xe.defaultOptions = { ubo: !1, isStatic: !1 }; let Ye = Xe; class Ke { constructor(t) { this.resources = Object.create(null), this.Ri = !0; let s = 0; for (const e in t) { const i = t[e]; this.setResource(i, s++) } this.Oi() } Oi() { if (!this.Ri) return; this.Ri = !1; const t = []; let s = 0; for (const e in this.resources) t[s++] = this.resources[e].U; this.Mi = t.join("|") } setResource(t, s) { const e = this.resources[s]; t !== e && (e && t.off?.("change", this.onResourceChange, this), t.on?.("change", this.onResourceChange, this), this.resources[s] = t, this.Ri = !0) } getResource(t) { return this.resources[t] } Ui(t) { const s = this.resources; for (const e in s) s[e].R = t } destroy() { const t = this.resources; for (const s in t) { const e = t[s]; e?.off?.("change", this.onResourceChange, this) } this.resources = null } onResourceChange(t) { if (this.Ri = !0, t.destroyed) { const s = this.resources; for (const e in s) s[e] === t && (s[e] = null) } else this.Oi() } } var Ze = (t => (t[t.WEBGL = 1] = "WEBGL", t[t.WEBGPU = 2] = "WEBGPU", t[t.BOTH = 3] = "BOTH", t))(Ze || {}); class Qe extends m { constructor(t) { super(), this.uid = I("shader"), this.Ii = Object.create(null), this.Bi = [], this.Ts = !1; let { gpuProgram: s, glProgram: e, groups: i, resources: n, compatibleRenderers: r, groupMap: o } = t; this.gpuProgram = s, this.glProgram = e, void 0 === r && (r = 0, s && (r |= Ze.WEBGPU), e && (r |= Ze.WEBGL)), this.compatibleRenderers = r; const h = {}; if (n || i || (n = {}), n && i) throw new Error("[Shader] Cannot have both resources and groups"); if (!s && i && !o) throw new Error("[Shader] No group map or WebGPU shader provided - consider using resources instead."); if (!s && i && o) for (const a in o) for (const t in o[a]) { const s = o[a][t]; h[s] = { group: a, binding: t, name: s } } else if (s && i && !o) { const t = s.structsAndGroups.groups; o = {}, t.forEach(t => { o[t.group] = o[t.group] || {}, o[t.group][t.binding] = t.name, h[t.name] = t }) } else if (n) { i = {}, o = {}, s && s.structsAndGroups.groups.forEach(t => { o[t.group] = o[t.group] || {}, o[t.group][t.binding] = t.name, h[t.name] = t }); let t = 0; for (const s in n) h[s] || (i[99] || (i[99] = new Ke, this.Bi.push(i[99])), h[s] = { group: 99, binding: t, name: s }, o[99] = o[99] || {}, o[99][t] = s, t++); for (const s in n) { const t = s; let e = n[s]; e.source || e.F || (e = new Ye(e)); const r = h[t]; r && (i[r.group] || (i[r.group] = new Ke, this.Bi.push(i[r.group])), i[r.group].setResource(e, r.binding)) } } this.groups = i, this.Ii = o, this.resources = this.$i(i, h) } addResource(t, s, e) { var i, n; (i = this.Ii)[s] || (i[s] = {}), (n = this.Ii[s])[e] || (n[e] = t), this.groups[s] || (this.groups[s] = new Ke, this.Bi.push(this.groups[s])) } $i(t, s) { const e = {}; for (const i in s) { const n = s[i]; Object.defineProperty(e, n.name, { get: () => t[n.group].getResource(n.binding), set(s) { t[n.group].setResource(s, n.binding) } }) } return e } destroy(t = !1) { this.Ts || (this.Ts = !0, this.emit("destroy", this), t && (this.gpuProgram?.destroy(), this.glProgram?.destroy()), this.gpuProgram = null, this.glProgram = null, this.removeAllListeners(), this.Ii = null, this.Bi.forEach(t => { t.destroy() }), this.Bi = null, this.resources = null, this.groups = null) } static from(t) { const { gpu: s, gl: e, ...i } = t; let n, r; return s && (n = Ne.from(s)), e && (r = $e.from(e)), new Qe({ gpuProgram: n, glProgram: r, ...i }) } } const Je = { normal: 0, add: 1, multiply: 2, screen: 3, overlay: 4, erase: 5, "normal-npm": 6, "add-npm": 7, "screen-npm": 8, min: 9, max: 10 }, ti = class t { constructor() { this.data = 0, this.blendMode = "normal", this.polygonOffset = 0, this.blend = !0, this.depthMask = !0 } get blend() { return !!(1 & this.data) } set blend(t) { !!(1 & this.data) !== t && (this.data ^= 1) } get offsets() { return !!(2 & this.data) } set offsets(t) { !!(2 & this.data) !== t && (this.data ^= 2) } set cullMode(t) { "none" !== t ? (this.culling = !0, this.clockwiseFrontFace = "front" === t) : this.culling = !1 } get cullMode() { return this.culling ? this.clockwiseFrontFace ? "front" : "back" : "none" } get culling() { return !!(4 & this.data) } set culling(t) { !!(4 & this.data) !== t && (this.data ^= 4) } get depthTest() { return !!(8 & this.data) } set depthTest(t) { !!(8 & this.data) !== t && (this.data ^= 8) } get depthMask() { return !!(32 & this.data) } set depthMask(t) { !!(32 & this.data) !== t && (this.data ^= 32) } get clockwiseFrontFace() { return !!(16 & this.data) } set clockwiseFrontFace(t) { !!(16 & this.data) !== t && (this.data ^= 16) } get blendMode() { return this.Gi } set blendMode(t) { this.blend = "none" !== t, this.Gi = t, this.zi = Je[t] || 0 } get polygonOffset() { return this.Di } set polygonOffset(t) { this.offsets = !!t, this.Di = t } toString() { return `[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]` } static for2d() { const s = new t; return s.depthTest = !1, s.blend = !0, s } }; ti.default2d = ti.for2d(); let si = ti; const ei = class t extends Qe { constructor(s) { super(s = { ...t.defaultOptions, ...s }), this.enabled = !0, this.ji = si.for2d(), this.blendMode = s.blendMode, this.padding = s.padding, "boolean" == typeof s.antialias ? this.antialias = s.antialias ? "on" : "off" : this.antialias = s.antialias, this.resolution = s.resolution, this.blendRequired = s.blendRequired, this.clipToViewport = s.clipToViewport, this.addResource("uTexture", 0, 1), s.blendRequired && this.addResource("uBackTexture", 0, 3) } apply(t, s, e, i) { t.applyFilter(this, s, e, i) } get blendMode() { return this.ji.blendMode } set blendMode(t) { this.ji.blendMode = t } static from(s) { const { gpu: e, gl: i, ...n } = s; let r, o; return e && (r = Ne.from(e)), i && (o = $e.from(i)), new t({ gpuProgram: r, glProgram: o, ...n }) } }; ei.defaultOptions = { blendMode: "normal", resolution: 1, padding: 0, antialias: "off", blendRequired: !1, clipToViewport: !0 }; let ii = ei; const ni = []; let ri; function oi() { if ("boolean" == typeof ri) return ri; try { const t = new Function("param1", "param2", "param3", "return param1[param2] === param3;"); ri = !0 === t({ a: "b" }, "a", "b") } catch (t) { ri = !1 } return ri } function hi(t, s, e = 2) { const i = s && s.length, n = i ? s[0] * e : t.length; let r = ai(t, 0, n, e, !0); const o = []; if (!r || r.next === r.prev) return o; let h, a, l; if (i && (r = function (t, s, e, i) { const n = []; for (let r = 0, o = s.length; r < o; r++) { const e = ai(t, s[r] * i, r < o - 1 ? s[r + 1] * i : t.length, i, !1); e === e.next && (e.steiner = !0), n.push(xi(e)) } n.sort(mi); for (let r = 0; r < n.length; r++)e = gi(n[r], e); return e }(t, s, r, e)), t.length > 80 * e) { h = t[0], a = t[1]; let s = h, i = a; for (let r = e; r < n; r += e) { const e = t[r], n = t[r + 1]; e < h && (h = e), n < a && (a = n), e > s && (s = e), n > i && (i = n) } l = Math.max(s - h, i - a), l = 0 !== l ? 32767 / l : 0 } return ui(r, o, e, h, a, l, 0), o } function ai(t, s, e, i, n) { let r; if (n === function (t, s, e, i) { let n = 0; for (let r = s, o = e - i; r < e; r += i)n += (t[o] - t[r]) * (t[r + 1] + t[o + 1]), o = r; return n }(t, s, e, i) > 0) for (let o = s; o < e; o += i)r = Fi(o / i | 0, t[o], t[o + 1], r); else for (let o = e - i; o >= s; o -= i)r = Fi(o / i | 0, t[o], t[o + 1], r); return r && Ai(r, r.next) && (Ei(r), r = r.next), r } function li(t, s) { if (!t) return t; s || (s = t); let e, i = t; do { if (e = !1, i.steiner || !Ai(i, i.next) && 0 !== Ti(i.prev, i, i.next)) i = i.next; else { if (Ei(i), i = s = i.prev, i === i.next) break; e = !0 } } while (e || i !== s); return s } function ui(t, s, e, i, n, r, o) { if (!t) return; !o && r && function (t, s, e, i) { let n = t; do { 0 === n.z && (n.z = bi(n.x, n.y, s, e, i)), n.prevZ = n.prev, n.nextZ = n.next, n = n.next } while (n !== t); n.prevZ.nextZ = null, n.prevZ = null, function (t) { let s, e = 1; do { let i, n = t; t = null; let r = null; for (s = 0; n;) { s++; let o = n, h = 0; for (let t = 0; t < e && (h++, o = o.nextZ, o); t++); let a = e; for (; h > 0 || a > 0 && o;)0 !== h && (0 === a || !o || n.z <= o.z) ? (i = n, n = n.nextZ, h--) : (i = o, o = o.nextZ, a--), r ? r.nextZ = i : t = i, i.prevZ = r, r = i; n = o } r.nextZ = null, e *= 2 } while (s > 1) }(n) }(t, i, n, r); let h = t; for (; t.prev !== t.next;) { const a = t.prev, l = t.next; if (r ? fi(t, i, n, r) : ci(t)) s.push(a.i, t.i, l.i), Ei(t), t = l.next, h = l.next; else if ((t = l) === h) { o ? 1 === o ? ui(t = di(li(t), s), s, e, i, n, r, 2) : 2 === o && pi(t, s, e, i, n, r) : ui(li(t), s, e, i, n, r, 1); break } } } function ci(t) { const s = t.prev, e = t, i = t.next; if (Ti(s, e, i) >= 0) return !1; const n = s.x, r = e.x, o = i.x, h = s.y, a = e.y, l = i.y, u = Math.min(n, r, o), c = Math.min(h, a, l), f = Math.max(n, r, o), d = Math.max(h, a, l); let p = i.next; for (; p !== s;) { if (p.x >= u && p.x <= f && p.y >= c && p.y <= d && wi(n, h, r, a, o, l, p.x, p.y) && Ti(p.prev, p, p.next) >= 0) return !1; p = p.next } return !0 } function fi(t, s, e, i) { const n = t.prev, r = t, o = t.next; if (Ti(n, r, o) >= 0) return !1; const h = n.x, a = r.x, l = o.x, u = n.y, c = r.y, f = o.y, d = Math.min(h, a, l), p = Math.min(u, c, f), m = Math.max(h, a, l), g = Math.max(u, c, f), v = bi(d, p, s, e, i), b = bi(m, g, s, e, i); let x = t.prevZ, y = t.nextZ; for (; x && x.z >= v && y && y.z <= b;) { if (x.x >= d && x.x <= m && x.y >= p && x.y <= g && x !== n && x !== o && wi(h, u, a, c, l, f, x.x, x.y) && Ti(x.prev, x, x.next) >= 0) return !1; if (x = x.prevZ, y.x >= d && y.x <= m && y.y >= p && y.y <= g && y !== n && y !== o && wi(h, u, a, c, l, f, y.x, y.y) && Ti(y.prev, y, y.next) >= 0) return !1; y = y.nextZ } for (; x && x.z >= v;) { if (x.x >= d && x.x <= m && x.y >= p && x.y <= g && x !== n && x !== o && wi(h, u, a, c, l, f, x.x, x.y) && Ti(x.prev, x, x.next) >= 0) return !1; x = x.prevZ } for (; y && y.z <= b;) { if (y.x >= d && y.x <= m && y.y >= p && y.y <= g && y !== n && y !== o && wi(h, u, a, c, l, f, y.x, y.y) && Ti(y.prev, y, y.next) >= 0) return !1; y = y.nextZ } return !0 } function di(t, s) { let e = t; do { const i = e.prev, n = e.next.next; !Ai(i, n) && Ci(i, e, e.next, n) && Pi(i, n) && Pi(n, i) && (s.push(i.i, e.i, n.i), Ei(e), Ei(e.next), e = t = n), e = e.next } while (e !== t); return li(e) } function pi(t, s, e, i, n, r) { let o = t; do { let t = o.next.next; for (; t !== o.prev;) { if (o.i !== t.i && Mi(o, t)) { let h = ki(o, t); return o = li(o, o.next), h = li(h, h.next), ui(o, s, e, i, n, r, 0), void ui(h, s, e, i, n, r, 0) } t = t.next } o = o.next } while (o !== t) } function mi(t, s) { let e = t.x - s.x; return 0 === e && (e = t.y - s.y, 0 === e) && (e = (t.next.y - t.y) / (t.next.x - t.x) - (s.next.y - s.y) / (s.next.x - s.x)), e } function gi(t, s) { const e = function (t, s) { let e = s; const i = t.x, n = t.y; let r, o = -1 / 0; if (Ai(t, e)) return e; do { if (Ai(t, e.next)) return e.next; if (n <= e.y && n >= e.next.y && e.next.y !== e.y) { const t = e.x + (n - e.y) * (e.next.x - e.x) / (e.next.y - e.y); if (t <= i && t > o && (o = t, r = e.x < e.next.x ? e : e.next, t === i)) return r } e = e.next } while (e !== s); if (!r) return null; const h = r, a = r.x, l = r.y; let u = 1 / 0; e = r; do { if (i >= e.x && e.x >= a && i !== e.x && yi(n < l ? i : o, n, a, l, n < l ? o : i, n, e.x, e.y)) { const s = Math.abs(n - e.y) / (i - e.x); Pi(e, t) && (s < u || s === u && (e.x > r.x || e.x === r.x && vi(r, e))) && (r = e, u = s) } e = e.next } while (e !== h); return r }(t, s); if (!e) return s; const i = ki(e, t); return li(i, i.next), li(e, e.next) } function vi(t, s) { return Ti(t.prev, t, s.prev) < 0 && Ti(s.next, t, t.next) < 0 } function bi(t, s, e, i, n) { return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = (t - e) * n | 0) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (s = 1431655765 & ((s = 858993459 & ((s = 252645135 & ((s = 16711935 & ((s = (s - i) * n | 0) | s << 8)) | s << 4)) | s << 2)) | s << 1)) << 1 } function xi(t) { let s = t, e = t; do { (s.x < e.x || s.x === e.x && s.y < e.y) && (e = s), s = s.next } while (s !== t); return e } function yi(t, s, e, i, n, r, o, h) { return (n - o) * (s - h) >= (t - o) * (r - h) && (t - o) * (i - h) >= (e - o) * (s - h) && (e - o) * (r - h) >= (n - o) * (i - h) } function wi(t, s, e, i, n, r, o, h) { return !(t === o && s === h) && yi(t, s, e, i, n, r, o, h) } function Mi(t, s) { return t.next.i !== s.i && t.prev.i !== s.i && !function (t, s) { let e = t; do { if (e.i !== t.i && e.next.i !== t.i && e.i !== s.i && e.next.i !== s.i && Ci(e, e.next, t, s)) return !0; e = e.next } while (e !== t); return !1 }(t, s) && (Pi(t, s) && Pi(s, t) && function (t, s) { let e = t, i = !1; const n = (t.x + s.x) / 2, r = (t.y + s.y) / 2; do { e.y > r != e.next.y > r && e.next.y !== e.y && n < (e.next.x - e.x) * (r - e.y) / (e.next.y - e.y) + e.x && (i = !i), e = e.next } while (e !== t); return i }(t, s) && (Ti(t.prev, t, s.prev) || Ti(t, s.prev, s)) || Ai(t, s) && Ti(t.prev, t, t.next) > 0 && Ti(s.prev, s, s.next) > 0) } function Ti(t, s, e) { return (s.y - t.y) * (e.x - s.x) - (s.x - t.x) * (e.y - s.y) } function Ai(t, s) { return t.x === s.x && t.y === s.y } function Ci(t, s, e, i) { const n = Si(Ti(t, s, e)), r = Si(Ti(t, s, i)), o = Si(Ti(e, i, t)), h = Si(Ti(e, i, s)); return n !== r && o !== h || !(0 !== n || !_i(t, e, s)) || !(0 !== r || !_i(t, i, s)) || !(0 !== o || !_i(e, t, i)) || !(0 !== h || !_i(e, s, i)) } function _i(t, s, e) { return s.x <= Math.max(t.x, e.x) && s.x >= Math.min(t.x, e.x) && s.y <= Math.max(t.y, e.y) && s.y >= Math.min(t.y, e.y) } function Si(t) { return t > 0 ? 1 : t < 0 ? -1 : 0 } function Pi(t, s) { return Ti(t.prev, t, t.next) < 0 ? Ti(t, s, t.next) >= 0 && Ti(t, t.prev, s) >= 0 : Ti(t, s, t.prev) < 0 || Ti(t, t.next, s) < 0 } function ki(t, s) { const e = Ri(t.i, t.x, t.y), i = Ri(s.i, s.x, s.y), n = t.next, r = s.prev; return t.next = s, s.prev = t, e.next = n, n.prev = e, i.next = e, e.prev = i, r.next = i, i.prev = r, i } function Fi(t, s, e, i) { const n = Ri(t, s, e); return i ? (n.next = i.next, n.prev = i, i.next.prev = n, i.next = n) : (n.prev = n, n.next = n), n } function Ei(t) { t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ) } function Ri(t, s, e) { return { i: t, x: s, y: e, prev: null, next: null, z: 0, prevZ: null, nextZ: null, steiner: !1 } } a.handleByNamedList(r.Environment, ni); const Oi = hi.default || hi; var Ui = (t => (t[t.NONE = 0] = "NONE", t[t.COLOR = 16384] = "COLOR", t[t.STENCIL = 1024] = "STENCIL", t[t.DEPTH = 256] = "DEPTH", t[t.COLOR_DEPTH = 16640] = "COLOR_DEPTH", t[t.COLOR_STENCIL = 17408] = "COLOR_STENCIL", t[t.DEPTH_STENCIL = 1280] = "DEPTH_STENCIL", t[t.ALL = 17664] = "ALL", t))(Ui || {}); class Ii { constructor(t) { this.items = [], this.Li = t } emit(t, s, e, i, n, r, o, h) { const { name: a, items: l } = this; for (let u = 0, c = l.length; u < c; u++)l[u][a](t, s, e, i, n, r, o, h); return this } add(t) { return t[this.Li] && (this.remove(t), this.items.push(t)), this } remove(t) { const s = this.items.indexOf(t); return -1 !== s && this.items.splice(s, 1), this } contains(t) { return -1 !== this.items.indexOf(t) } removeAll() { return this.items.length = 0, this } destroy() { this.removeAll(), this.items = null, this.Li = null } get empty() { return 0 === this.items.length } get name() { return this.Li } } const Bi = ["init", "destroy", "contextChange", "resolutionChange", "resetState", "renderEnd", "renderStart", "render", "update", "postrender", "prerender"], $i = class t extends m { constructor(t) { super(), this.uid = I("renderer"), this.runners = Object.create(null), this.renderPipes = Object.create(null), this.Vi = {}, this.Ni = Object.create(null), this.type = t.type, this.name = t.name, this.config = t; const s = [...Bi, ...this.config.runners ?? []]; this.Wi(...s), this.Hi() } async init(s = {}) { const e = !0 === s.skipExtensionImports || !1 === s.manageImports; await async function (t) { if (!t) for (let s = 0; s < ni.length; s++) { const t = ni[s]; if (t.value.test()) return void (await t.value.load()) } }(e), this.qi(this.config.systems), this.Xi(this.config.renderPipes, this.config.renderPipeAdaptors); for (const t in this.Ni) s = { ...this.Ni[t].constructor.defaultOptions, ...s }; s = { ...t.defaultOptions, ...s }, this.fs = s.roundPixels ? 1 : 0; for (let t = 0; t < this.runners.init.items.length; t++)await this.runners.init.items[t].init(s); this.Vi = s } render(t, s) { let e = t; if (e instanceof bs && (e = { container: e }, s && (G(0, "passing a second argument is deprecated, please use render options instead"), e.target = s.renderTexture)), e.target || (e.target = this.view.renderTarget), e.target === this.view.renderTarget && (this.Yi = e.container, e.clearColor ?? (e.clearColor = this.background.colorRgba), e.clear ?? (e.clear = this.background.clearBeforeRender)), e.clearColor) { const t = Array.isArray(e.clearColor) && 4 === e.clearColor.length; e.clearColor = t ? e.clearColor : kt.shared.setValue(e.clearColor).toArray() } e.transform || (e.container.updateLocalTransform(), e.transform = e.container.localTransform), e.container.visible && (e.container.enableRenderGroup(), this.runners.prerender.emit(e), this.runners.renderStart.emit(e), this.runners.render.emit(e), this.runners.renderEnd.emit(e), this.runners.postrender.emit(e)) } resize(t, s, e) { const i = this.view.resolution; this.view.resize(t, s, e), this.emit("resize", this.view.screen.width, this.view.screen.height, this.view.resolution), void 0 !== e && e !== i && this.runners.resolutionChange.emit(e) } clear(t = {}) { t.target || (t.target = this.renderTarget.renderTarget), t.clearColor || (t.clearColor = this.background.colorRgba), t.clear ?? (t.clear = Ui.ALL); const { clear: s, clearColor: e, target: i } = t; kt.shared.setValue(e ?? this.background.colorRgba), this.renderTarget.clear(i, s, kt.shared.toArray()) } get resolution() { return this.view.resolution } set resolution(t) { this.view.resolution = t, this.runners.resolutionChange.emit(t) } get width() { return this.view.texture.frame.width } get height() { return this.view.texture.frame.height } get canvas() { return this.view.canvas } get lastObjectRendered() { return this.Yi } get renderingToScreen() { return this.renderTarget.renderingToScreen } get screen() { return this.view.screen } Wi(...t) { t.forEach(t => { this.runners[t] = new Ii(t) }) } qi(t) { let s; for (s in t) { const e = t[s]; this.Ki(e.value, e.name) } } Ki(t, s) { const e = new t(this); if (this[s]) throw new Error(`Whoops! The name "${s}" is already in use`); this[s] = e, this.Ni[s] = e; for (const i in this.runners) this.runners[i].add(e); return this } Xi(t, s) { const e = s.reduce((t, s) => (t[s.name] = s.value, t), {}); t.forEach(t => { const s = t.value, i = t.name, n = e[i]; this.renderPipes[i] = new s(this, n ? new n : null), this.runners.destroy.add(this.renderPipes[i]) }) } destroy(t = !1) { this.runners.destroy.items.reverse(), this.runners.destroy.emit(t), (!0 === t || "object" == typeof t && t.releaseGlobalResources) && Rt.release(), Object.values(this.runners).forEach(t => { t.destroy() }), this.Ni = null, this.renderPipes = null } generateTexture(t) { return this.textureGenerator.generateTexture(t) } get roundPixels() { return !!this.fs } Hi() { if (!oi()) throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.") } resetState() { this.runners.resetState.emit() } }; $i.defaultOptions = { resolution: 1, failIfMajorPerformanceCaveat: !1, roundPixels: !1 }; let Gi, zi, Di = $i; function ji(t) { return void 0 !== Gi || (Gi = (() => { const s = { stencil: !0, failIfMajorPerformanceCaveat: t ?? Di.defaultOptions.failIfMajorPerformanceCaveat }; try { if (!ks.get().getWebGLRenderingContext()) return !1; let t = ks.get().createCanvas().getContext("webgl", s); const e = !!t?.getContextAttributes()?.stencil; if (t) { const s = t.getExtension("WEBGL_lose_context"); s && s.loseContext() } return t = null, e } catch (e) { return !1 } })()), Gi } async function Li(t = {}) { return void 0 !== zi || (zi = await (async () => { const s = ks.get().getNavigator().gpu; if (!s) return !1; try { const e = await s.requestAdapter(t); return await e.requestDevice(), !0 } catch (e) { return !1 } })()), zi } const Vi = ["webgl", "webgpu", "canvas"], Ni = "8.14.3"; class Wi { static init() { globalThis.__PIXI_APP_INIT__?.(this, Ni) } static destroy() { } } Wi.extension = r.Application; class Hi { constructor(t) { this.Be = t } init() { globalThis.__PIXI_RENDERER_INIT__?.(this.Be, Ni) } destroy() { this.Be = null } } Hi.extension = { type: [r.WebGLSystem, r.WebGPUSystem], name: "initHook", priority: -10 }; const qi = class t { constructor(...t) { this.stage = new bs, void 0 !== t[0] && G(0, "Application constructor options are deprecated, please use Application.init() instead.") } async init(s) { s = { ...s }, this.stage || (this.stage = new bs), this.renderer = await async function (t) { let s, e = []; t.preference ? (e.push(t.preference), Vi.forEach(s => { s !== t.preference && e.push(s) })) : e = Vi.slice(); let i = {}; for (let o = 0; o < e.length; o++) { const r = e[o]; if ("webgpu" === r && await Li()) { const { WebGPURenderer: e } = await n(async () => { const { WebGPURenderer: t } = await Promise.resolve().then(() => ju); return { WebGPURenderer: t } }, void 0, import.meta.url); s = e, i = { ...t, ...t.webgpu }; break } if ("webgl" === r && ji(t.failIfMajorPerformanceCaveat ?? Di.defaultOptions.failIfMajorPerformanceCaveat)) { const { WebGLRenderer: e } = await n(async () => { const { WebGLRenderer: t } = await Promise.resolve().then(() => su); return { WebGLRenderer: t } }, void 0, import.meta.url); s = e, i = { ...t, ...t.webgl }; break } if ("canvas" === r) throw i = { ...t }, new Error("CanvasRenderer is not yet implemented") } if (delete i.webgpu, delete i.webgl, !s) throw new Error("No available renderer for the current environment"); const r = new s; return await r.init(i), r }(s), t.Zi.forEach(t => { t.init.call(this, s) }) } render() { this.renderer.render({ container: this.stage }) } get canvas() { return this.renderer.canvas } get view() { return G(0, "Application.view is deprecated, please use Application.canvas instead."), this.renderer.canvas } get screen() { return this.renderer.screen } destroy(s = !1, e = !1) { const i = t.Zi.slice(0); i.reverse(), i.forEach(t => { t.destroy.call(this) }), this.stage.destroy(e), this.stage = null, this.renderer.destroy(s), this.renderer = null } }; qi.Zi = []; let Xi = qi; a.handleByList(r.Application, Xi.Zi), a.add(Wi); class Yi { static init(t) { Object.defineProperty(this, "resizeTo", { configurable: !0, set(t) { globalThis.removeEventListener("resize", this.queueResize), this.Qi = t, t && (globalThis.addEventListener("resize", this.queueResize), this.resize()) }, get() { return this.Qi } }), this.queueResize = () => { this.Qi && (this.Ji(), this.tn = requestAnimationFrame(() => this.resize())) }, this.Ji = () => { this.tn && (cancelAnimationFrame(this.tn), this.tn = null) }, this.resize = () => { if (!this.Qi) return; let t, s; if (this.Ji(), this.Qi === globalThis.window) t = globalThis.innerWidth, s = globalThis.innerHeight; else { const { clientWidth: e, clientHeight: i } = this.Qi; t = e, s = i } this.renderer.resize(t, s), this.render() }, this.tn = null, this.Qi = null, this.resizeTo = t.resizeTo || null } static destroy() { globalThis.removeEventListener("resize", this.queueResize), this.Ji(), this.Ji = null, this.queueResize = null, this.resizeTo = null, this.resize = null } } Yi.extension = r.Application; class Ki { static init(t) { t = Object.assign({ autoStart: !0, sharedTicker: !1 }, t), Object.defineProperty(this, "ticker", { configurable: !0, set(t) { this.sn && this.sn.remove(this.render, this), this.sn = t, t && t.add(this.render, this, Rs.LOW) }, get() { return this.sn } }), this.stop = () => { this.sn.stop() }, this.start = () => { this.sn.start() }, this.sn = null, this.ticker = t.sharedTicker ? Bs.shared : new Bs, t.autoStart && this.start() } static destroy() { if (this.sn) { const t = this.sn; this.ticker = null, t.destroy() } } } Ki.extension = r.Application; class Zi extends m { constructor() { super(...arguments), this.chars = Object.create(null), this.lineHeight = 0, this.fontFamily = "", this.fontMetrics = { fontSize: 0, ascent: 0, descent: 0 }, this.baseLineOffset = 0, this.distanceField = { type: "none", range: 0 }, this.pages = [], this.applyFillAsTint = !0, this.baseMeasurementFontSize = 100, this.baseRenderedFontSize = 100 } get font() { return G(0, "BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead."), this.fontFamily } get pageTextures() { return G(0, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."), this.pages } get size() { return G(0, "BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead."), this.fontMetrics.fontSize } get distanceFieldRange() { return G(0, "BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead."), this.distanceField.range } get distanceFieldType() { return G(0, "BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead."), this.distanceField.type } destroy(t = !1) { this.emit("destroy", this), this.removeAllListeners(); for (const s in this.chars) this.chars[s].texture?.destroy(); this.chars = null, t && (this.pages.forEach(t => t.texture.destroy(!0)), this.pages = null) } } class Qi { constructor(t = 0, s = 0, e = !1) { this.first = null, this.items = Object.create(null), this.last = null, this.max = t, this.resetTtl = e, this.size = 0, this.ttl = s } clear() { return this.first = null, this.items = Object.create(null), this.last = null, this.size = 0, this } delete(t) { if (this.has(t)) { const s = this.items[t]; delete this.items[t], this.size--, null !== s.prev && (s.prev.next = s.next), null !== s.next && (s.next.prev = s.prev), this.first === s && (this.first = s.next), this.last === s && (this.last = s.prev) } return this } entries(t = this.keys()) { return t.map(t => [t, this.get(t)]) } evict(t = !1) { if (t || this.size > 0) { const t = this.first; delete this.items[t.key], 0 === --this.size ? (this.first = null, this.last = null) : (this.first = t.next, this.first.prev = null) } return this } expiresAt(t) { let s; return this.has(t) && (s = this.items[t].expiry), s } get(t) { const s = this.items[t]; if (void 0 !== s) return this.ttl > 0 && s.expiry <= Date.now() ? void this.delete(t) : (this.moveToEnd(s), s.value) } has(t) { return t in this.items } moveToEnd(t) { this.last !== t && (null !== t.prev && (t.prev.next = t.next), null !== t.next && (t.next.prev = t.prev), this.first === t && (this.first = t.next), t.prev = this.last, t.next = null, null !== this.last && (this.last.next = t), this.last = t, null === this.first && (this.first = t)) } keys() { const t = []; let s = this.first; for (; null !== s;)t.push(s.key), s = s.next; return t } setWithEvicted(t, s, e = this.resetTtl) { let i = null; if (this.has(t)) this.set(t, s, !0, e); else { this.max > 0 && this.size === this.max && (i = { ...this.first }, this.evict(!0)); let e = this.items[t] = { expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl, key: t, prev: this.last, next: null, value: s }; 1 === ++this.size ? this.first = e : this.last.next = e, this.last = e } return i } set(t, s, e = !1, i = this.resetTtl) { let n = this.items[t]; return e || void 0 !== n ? (n.value = s, !1 === e && i && (n.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl), this.moveToEnd(n)) : (this.max > 0 && this.size === this.max && this.evict(!0), n = this.items[t] = { expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl, key: t, prev: this.last, next: null, value: s }, 1 === ++this.size ? this.first = n : this.last.next = n, this.last = n), this } values(t = this.keys()) { return t.map(t => this.get(t)) } } function Ji(t = 1e3, s = 0, e = !1) { if (isNaN(t) || t < 0) throw new TypeError("Invalid max value"); if (isNaN(s) || s < 0) throw new TypeError("Invalid ttl value"); if ("boolean" != typeof e) throw new TypeError("Invalid resetTtl value"); return new Qi(t, s, e) } const tn = ["serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui"]; function sn(t) { const s = "number" == typeof t.fontSize ? `${t.fontSize}px` : t.fontSize; let e = t.fontFamily; Array.isArray(t.fontFamily) || (e = t.fontFamily.split(",")); for (let i = e.length - 1; i >= 0; i--) { let t = e[i].trim(); /([\"\'])[^\'\"]+\1/.test(t) || tn.includes(t) || (t = `"${t}"`), e[i] = t } return `${t.fontStyle} ${t.fontVariant} ${t.fontWeight} ${s} ${e.join(",")}` } const en = { willReadFrequently: !0 }, nn = class t { static get experimentalLetterSpacingSupported() { let s = t.en; if (void 0 === s) { const e = ks.get().getCanvasRenderingContext2D().prototype; s = t.en = "letterSpacing" in e || "textLetterSpacing" in e } return s } constructor(t, s, e, i, n, r, o, h, a) { this.text = t, this.style = s, this.width = e, this.height = i, this.lines = n, this.lineWidths = r, this.lineHeight = o, this.maxLineWidth = h, this.fontProperties = a } static measureText(s = " ", e, i = t.Ie, n = e.wordWrap) { const r = `${s}-${e.styleKey}-wordWrap-${n}`; if (t.nn.has(r)) return t.nn.get(r); const o = sn(e), h = t.measureFont(o); 0 === h.fontSize && (h.fontSize = e.fontSize, h.ascent = e.fontSize); const a = t.rn; a.font = o; const l = (n ? t.hn(s, e, i) : s).split(/(?:\r\n|\r|\n)/), u = new Array(l.length); let c = 0; for (let v = 0; v < l.length; v++) { const s = t.an(l[v], e.letterSpacing, a); u[v] = s, c = Math.max(c, s) } const f = e.ln?.width || 0; let d = c + f; e.dropShadow && (d += e.dropShadow.distance); const p = e.lineHeight || h.fontSize; let m = Math.max(p, h.fontSize + f) + (l.length - 1) * (p + e.leading); e.dropShadow && (m += e.dropShadow.distance); const g = new t(s, e, d, m, l, u, p + e.leading, c, h); return t.nn.set(r, g), g } static an(s, e, i) { let n = !1; t.experimentalLetterSpacingSupported && (t.experimentalLetterSpacing ? (i.letterSpacing = `${e}px`, i.textLetterSpacing = `${e}px`, n = !0) : (i.letterSpacing = "0px", i.textLetterSpacing = "0px")); const r = i.measureText(s); let o = r.width; const h = -r.actualBoundingBoxLeft; let a = r.actualBoundingBoxRight - h; if (o > 0) if (n) o -= e, a -= e; else { const i = (t.graphemeSegmenter(s).length - 1) * e; o += i, a += i } return Math.max(o, a) } static hn(s, e, i = t.Ie) { const n = i.getContext("2d", en); let r = 0, o = "", h = ""; const a = Object.create(null), { letterSpacing: l, whiteSpace: u } = e, c = t.un(u), f = t.cn(u); let d = !c; const p = e.wordWrapWidth + l, m = t.dn(s); for (let g = 0; g < m.length; g++) { let s = m[g]; if (t.pn(s)) { if (!f) { h += t.mn(o), d = !c, o = "", r = 0; continue } s = " " } if (c) { const e = t.isBreakingSpace(s), i = t.isBreakingSpace(o[o.length - 1]); if (e && i) continue } const i = t.gn(s, l, a, n); if (i > p) if ("" !== o && (h += t.mn(o), o = "", r = 0), t.canBreakWords(s, e.breakWords)) { const i = t.wordWrapSplit(s); for (let u = 0; u < i.length; u++) { let c = i[u], f = c, m = 1; for (; i[u + m];) { const n = i[u + m]; if (t.canBreakChars(f, n, s, u, e.breakWords)) break; c += n, f = n, m++ } u += m - 1; const g = t.gn(c, l, a, n); g + r > p && (h += t.mn(o), d = !1, o = "", r = 0), o += c, r += g } } else { o.length > 0 && (h += t.mn(o), o = "", r = 0); const e = g === m.length - 1; h += t.mn(s, !e), d = !1, o = "", r = 0 } else i + r > p && (d = !1, h += t.mn(o), o = "", r = 0), (o.length > 0 || !t.isBreakingSpace(s) || d) && (o += s, r += i) } return h += t.mn(o, !1), h } static mn(s, e = !0) { return s = t.vn(s), e ? `${s}\n` : s } static gn(s, e, i, n) { let r = i[s]; return "number" != typeof r && (r = t.an(s, e, n) + e, i[s] = r), r } static un(t) { return "normal" === t || "pre-line" === t } static cn(t) { return "normal" === t } static vn(s) { if ("string" != typeof s) return ""; for (let e = s.length - 1; e >= 0; e--) { const i = s[e]; if (!t.isBreakingSpace(i)) break; s = s.slice(0, -1) } return s } static pn(s) { return "string" == typeof s && t.bn.includes(s.charCodeAt(0)) } static isBreakingSpace(s, e) { return "string" == typeof s && t.xn.includes(s.charCodeAt(0)) } static dn(s) { const e = []; let i = ""; if ("string" != typeof s) return e; for (let n = 0; n < s.length; n++) { const r = s[n], o = s[n + 1]; t.isBreakingSpace(r, o) || t.pn(r) ? ("" !== i && (e.push(i), i = ""), "\r" === r && "\n" === o ? (e.push("\r\n"), n++) : e.push(r)) : i += r } return "" !== i && e.push(i), e } static canBreakWords(t, s) { return s } static canBreakChars(t, s, e, i, n) { return !0 } static wordWrapSplit(s) { return t.graphemeSegmenter(s) } static measureFont(s) { if (t.yn[s]) return t.yn[s]; const e = t.Cs; e.font = s; const i = e.measureText(t.METRICS_STRING + t.BASELINE_SYMBOL), n = { ascent: i.actualBoundingBoxAscent, descent: i.actualBoundingBoxDescent, fontSize: i.actualBoundingBoxAscent + i.actualBoundingBoxDescent }; return t.yn[s] = n, n } static clearMetrics(s = "") { s ? delete t.yn[s] : t.yn = {} } static get Ie() { if (!t.wn) { let e; try { const s = new OffscreenCanvas(0, 0), i = s.getContext("2d", en); if (i?.measureText) return t.wn = s, s; e = ks.get().createCanvas() } catch (s) { e = ks.get().createCanvas() } e.width = e.height = 10, t.wn = e } return t.wn } static get Cs() { return t.rn || (t.rn = t.Ie.getContext("2d", en)), t.rn } }; nn.METRICS_STRING = "|q", nn.BASELINE_SYMBOL = "M", nn.BASELINE_MULTIPLIER = 1.4, nn.HEIGHT_MULTIPLIER = 2, nn.graphemeSegmenter = (() => { if ("function" == typeof Intl?.Segmenter) { const t = new Intl.Segmenter; return s => { const e = t.segment(s), i = []; let n = 0; for (const t of e) i[n++] = t.segment; return i } } return t => [...t] })(), nn.experimentalLetterSpacing = !1, nn.yn = {}, nn.bn = [10, 13], nn.xn = [9, 32, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8200, 8201, 8202, 8287, 12288], nn.nn = Ji(1e3); let rn = nn; const on = [{ offset: 0, color: "white" }, { offset: 1, color: "black" }], hn = class t { constructor(...s) { this.uid = I("fillGradient"), this.Os = 0, this.type = "linear", this.colorStops = []; let e = function (t) { let s = t[0] ?? {}; return ("number" == typeof s || t[1]) && (G(0, "use options object instead"), s = { type: "linear", start: { x: t[0], y: t[1] }, end: { x: t[2], y: t[3] }, textureSpace: t[4], textureSize: t[5] ?? an.defaultLinearOptions.textureSize }), s }(s); e = { ..."radial" === e.type ? t.defaultRadialOptions : t.defaultLinearOptions, ...L(e) }, this.Mn = e.textureSize, this.Tn = e.wrapMode, "radial" === e.type ? (this.center = e.center, this.outerCenter = e.outerCenter ?? this.center, this.innerRadius = e.innerRadius, this.outerRadius = e.outerRadius, this.scale = e.scale, this.rotation = e.rotation) : (this.start = e.start, this.end = e.end), this.textureSpace = e.textureSpace, this.type = e.type, e.colorStops.forEach(t => { this.addColorStop(t.offset, t.color) }) } addColorStop(t, s) { return this.colorStops.push({ offset: t, color: kt.shared.setValue(s).toHexa() }), this } buildLinearGradient() { if (this.texture) return; let { x: t, y: s } = this.start, { x: e, y: i } = this.end, n = e - t, r = i - s; const o = n < 0 || r < 0; if ("clamp-to-edge" === this.Tn) { if (n < 0) { const s = t; t = e, e = s, n *= -1 } if (r < 0) { const t = s; s = i, i = t, r *= -1 } } const h = this.colorStops.length ? this.colorStops : on, a = this.Mn, { canvas: l, context: u } = un(a, 1), c = o ? u.createLinearGradient(this.Mn, 0, 0, 0) : u.createLinearGradient(0, 0, this.Mn, 0); ln(c, h), u.fillStyle = c, u.fillRect(0, 0, a, 1), this.texture = new Z({ source: new Es({ resource: l, addressMode: this.Tn }) }); const f = Math.sqrt(n * n + r * r), d = Math.atan2(r, n), p = new w; p.scale(f / a, 1), p.rotate(d), p.translate(t, s), "local" === this.textureSpace && p.scale(a, a), this.transform = p } buildGradient() { this.texture || this.Os++, "linear" === this.type ? this.buildLinearGradient() : this.buildRadialGradient() } buildRadialGradient() { if (this.texture) return; const t = this.colorStops.length ? this.colorStops : on, s = this.Mn, { canvas: e, context: i } = un(s, s), { x: n, y: r } = this.center, { x: o, y: h } = this.outerCenter, a = this.innerRadius, l = this.outerRadius, u = o - l, c = h - l, f = s / (2 * l), d = (n - u) * f, p = (r - c) * f, m = i.createRadialGradient(d, p, a * f, (o - u) * f, (h - c) * f, l * f); ln(m, t), i.fillStyle = t[t.length - 1].color, i.fillRect(0, 0, s, s), i.fillStyle = m, i.translate(d, p), i.rotate(this.rotation), i.scale(1, this.scale), i.translate(-d, -p), i.fillRect(0, 0, s, s), this.texture = new Z({ source: new Es({ resource: e, addressMode: this.Tn }) }); const g = new w; g.scale(1 / f, 1 / f), g.translate(u, c), "local" === this.textureSpace && g.scale(s, s), this.transform = g } destroy() { this.texture?.destroy(!0), this.texture = null, this.transform = null, this.colorStops = [], this.start = null, this.end = null, this.center = null, this.outerCenter = null } get styleKey() { return `fill-gradient-${this.uid}-${this.Os}` } }; hn.defaultLinearOptions = { start: { x: 0, y: 0 }, end: { x: 0, y: 1 }, colorStops: [], textureSpace: "local", type: "linear", textureSize: 256, wrapMode: "clamp-to-edge" }, hn.defaultRadialOptions = { center: { x: .5, y: .5 }, innerRadius: 0, outerRadius: .5, colorStops: [], scale: 1, textureSpace: "local", type: "radial", textureSize: 256, wrapMode: "clamp-to-edge" }; let an = hn; function ln(t, s) { for (let e = 0; e < s.length; e++) { const i = s[e]; t.addColorStop(i.offset, i.color) } } function un(t, s) { const e = ks.get().createCanvas(t, s), i = e.getContext("2d"); return { canvas: e, context: i } } const cn = { repeat: { addressModeU: "repeat", addressModeV: "repeat" }, "repeat-x": { addressModeU: "repeat", addressModeV: "clamp-to-edge" }, "repeat-y": { addressModeU: "clamp-to-edge", addressModeV: "repeat" }, "no-repeat": { addressModeU: "clamp-to-edge", addressModeV: "clamp-to-edge" } }; class fn { constructor(t, s) { this.uid = I("fillPattern"), this.Os = 0, this.transform = new w, this.texture = t, this.transform.scale(1 / t.frame.width, 1 / t.frame.height), s && (t.source.style.addressModeU = cn[s].addressModeU, t.source.style.addressModeV = cn[s].addressModeV) } setTransform(t) { const s = this.texture; this.transform.copyFrom(t), this.transform.invert(), this.transform.scale(1 / s.frame.width, 1 / s.frame.height), this.Os++ } get texture() { return this.Y } set texture(t) { this.Y !== t && (this.Y = t, this.Os++) } get styleKey() { return `fill-pattern-${this.uid}-${this.Os}` } destroy() { this.texture.destroy(!0), this.texture = null } } var dn, pn; const mn = f(function () { if (pn) return dn; pn = 1, dn = function (i) { var n = []; return i.replace(s, function (s, i, r) { var o = i.toLowerCase(); for (r = function (t) { var s = t.match(e); return s ? s.map(Number) : [] }(r), "m" == o && r.length > 2 && (n.push([i].concat(r.splice(0, 2))), o = "l", i = "m" == i ? "l" : "L"); ;) { if (r.length == t[o]) return r.unshift(i), n.push(r); if (r.length < t[o]) throw new Error("malformed path data"); n.push([i].concat(r.splice(0, t[o]))) } }), n }; var t = { a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0 }, s = /([astvzqmhlc])([^astvzqmhlc]*)/gi, e = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/gi; return dn }()); class gn { constructor(t = 0, s = 0, e = 0) { this.type = "circle", this.x = t, this.y = s, this.radius = e } clone() { return new gn(this.x, this.y, this.radius) } contains(t, s) { if (this.radius <= 0) return !1; const e = this.radius * this.radius; let i = this.x - t, n = this.y - s; return i *= i, n *= n, i + n <= e } strokeContains(t, s, e, i = .5) { if (0 === this.radius) return !1; const n = this.x - t, r = this.y - s, o = this.radius, h = (1 - i) * e, a = Math.sqrt(n * n + r * r); return a <= o + h && a > o - (e - h) } getBounds(t) { return t || (t = new O), t.x = this.x - this.radius, t.y = this.y - this.radius, t.width = 2 * this.radius, t.height = 2 * this.radius, t } copyFrom(t) { return this.x = t.x, this.y = t.y, this.radius = t.radius, this } copyTo(t) { return t.copyFrom(this), t } toString() { return `[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]` } } class vn { constructor(t = 0, s = 0, e = 0, i = 0) { this.type = "ellipse", this.x = t, this.y = s, this.halfWidth = e, this.halfHeight = i } clone() { return new vn(this.x, this.y, this.halfWidth, this.halfHeight) } contains(t, s) { if (this.halfWidth <= 0 || this.halfHeight <= 0) return !1; let e = (t - this.x) / this.halfWidth, i = (s - this.y) / this.halfHeight; return e *= e, i *= i, e + i <= 1 } strokeContains(t, s, e, i = .5) { const { halfWidth: n, halfHeight: r } = this; if (n <= 0 || r <= 0) return !1; const o = e * (1 - i), h = e - o, a = n - h, l = r - h, u = n + o, c = r + o, f = t - this.x, d = s - this.y; return f * f / (a * a) + d * d / (l * l) > 1 && f * f / (u * u) + d * d / (c * c) <= 1 } getBounds(t) { return t || (t = new O), t.x = this.x - this.halfWidth, t.y = this.y - this.halfHeight, t.width = 2 * this.halfWidth, t.height = 2 * this.halfHeight, t } copyFrom(t) { return this.x = t.x, this.y = t.y, this.halfWidth = t.halfWidth, this.halfHeight = t.halfHeight, this } copyTo(t) { return t.copyFrom(this), t } toString() { return `[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]` } } function bn(t, s, e, i, n, r) { const o = n - e, h = r - i, a = o * o + h * h; let l, u, c = -1; 0 !== a && (c = ((t - e) * o + (s - i) * h) / a), c < 0 ? (l = e, u = i) : c > 1 ? (l = n, u = r) : (l = e + c * o, u = i + c * h); const f = t - l, d = s - u; return f * f + d * d } class xn { constructor(...t) { this.type = "polygon"; let s = Array.isArray(t[0]) ? t[0] : t; if ("number" != typeof s[0]) { const t = []; for (let e = 0, i = s.length; e < i; e++)t.push(s[e].x, s[e].y); s = t } this.points = s, this.closePath = !0 } isClockwise() { let t = 0; const s = this.points, e = s.length; for (let i = 0; i < e; i += 2) { const n = s[i], r = s[i + 1]; t += (s[(i + 2) % e] - n) * (s[(i + 3) % e] + r) } return t < 0 } containsPolygon(t) { const s = this.getBounds(void 0), e = t.getBounds(void 0); if (!s.containsRect(e)) return !1; const i = t.points; for (let n = 0; n < i.length; n += 2) { const t = i[n], s = i[n + 1]; if (!this.contains(t, s)) return !1 } return !0 } clone() { const t = this.points.slice(), s = new xn(t); return s.closePath = this.closePath, s } contains(t, s) { let e = !1; const i = this.points.length / 2; for (let n = 0, r = i - 1; n < i; r = n++) { const i = this.points[2 * n], o = this.points[2 * n + 1], h = this.points[2 * r], a = this.points[2 * r + 1]; o > s != a > s && t < (s - o) / (a - o) * (h - i) + i && (e = !e) } return e } strokeContains(t, s, e, i = .5) { const n = e * e, r = n * (1 - i), o = n - r, { points: h } = this, a = h.length - (this.closePath ? 0 : 2); for (let l = 0; l < a; l += 2) { const e = h[l], i = h[l + 1], n = h[(l + 2) % h.length], a = h[(l + 3) % h.length]; if (bn(t, s, e, i, n, a) <= (Math.sign((n - e) * (s - i) - (a - i) * (t - e)) < 0 ? o : r)) return !0 } return !1 } getBounds(t) { t || (t = new O); const s = this.points; let e = 1 / 0, i = -1 / 0, n = 1 / 0, r = -1 / 0; for (let o = 0, h = s.length; o < h; o += 2) { const t = s[o], h = s[o + 1]; e = t < e ? t : e, i = t > i ? t : i, n = h < n ? h : n, r = h > r ? h : r } return t.x = e, t.width = i - e, t.y = n, t.height = r - n, t } copyFrom(t) { return this.points = t.points.slice(), this.closePath = t.closePath, this } copyTo(t) { return t.copyFrom(this), t } toString() { return `[pixi.js/math:PolygoncloseStroke=${this.closePath}points=${this.points.reduce((t, s) => `${t}, ${s}`, "")}]` } get lastX() { return this.points[this.points.length - 2] } get lastY() { return this.points[this.points.length - 1] } get x() { return G(0, "Polygon.lastX is deprecated, please use Polygon.lastX instead."), this.points[this.points.length - 2] } get y() { return G(0, "Polygon.y is deprecated, please use Polygon.lastY instead."), this.points[this.points.length - 1] } get startX() { return this.points[0] } get startY() { return this.points[1] } } const yn = (t, s, e, i, n, r, o) => { const h = t - e, a = s - i, l = Math.sqrt(h * h + a * a); return l >= n - r && l <= n + o }; class wn { constructor(t = 0, s = 0, e = 0, i = 0, n = 20) { this.type = "roundedRectangle", this.x = t, this.y = s, this.width = e, this.height = i, this.radius = n } getBounds(t) { return t || (t = new O), t.x = this.x, t.y = this.y, t.width = this.width, t.height = this.height, t } clone() { return new wn(this.x, this.y, this.width, this.height, this.radius) } copyFrom(t) { return this.x = t.x, this.y = t.y, this.width = t.width, this.height = t.height, this } copyTo(t) { return t.copyFrom(this), t } contains(t, s) { if (this.width <= 0 || this.height <= 0) return !1; if (t >= this.x && t <= this.x + this.width && s >= this.y && s <= this.y + this.height) { const e = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2)); if (s >= this.y + e && s <= this.y + this.height - e || t >= this.x + e && t <= this.x + this.width - e) return !0; let i = t - (this.x + e), n = s - (this.y + e); const r = e * e; if (i * i + n * n <= r) return !0; if (i = t - (this.x + this.width - e), i * i + n * n <= r) return !0; if (n = s - (this.y + this.height - e), i * i + n * n <= r) return !0; if (i = t - (this.x + e), i * i + n * n <= r) return !0 } return !1 } strokeContains(t, s, e, i = .5) { const { x: n, y: r, width: o, height: h, radius: a } = this, l = e * (1 - i), u = e - l, c = n + a, f = r + a, d = n + o, p = r + h; return (t >= n - l && t <= n + u || t >= d - u && t <= d + l) && s >= f && s <= f + (h - 2 * a) || (s >= r - l && s <= r + u || s >= p - u && s <= p + l) && t >= c && t <= c + (o - 2 * a) || t < c && s < f && yn(t, s, c, f, a, u, l) || t > d - a && s < f && yn(t, s, d - a, f, a, u, l) || t > d - a && s > p - a && yn(t, s, d - a, p - a, a, u, l) || t < c && s > p - a && yn(t, s, c, p - a, a, u, l) } toString() { return `[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]` } } const Mn = {}; function Tn(t, s, e) { let i = 2166136261; for (let n = 0; n < s; n++)i ^= t[n].uid, i = Math.imul(i, 16777619), i >>>= 0; return Mn[i] || function (t, s, e, i) { const n = {}; let r = 0; for (let h = 0; h < i; h++) { const e = h < s ? t[h] : Z.EMPTY.source; n[r++] = e.source, n[r++] = e.style } const o = new Ke(n); return Mn[e] = o, o }(t, s, i, e) } class An { constructor(t) { "number" == typeof t ? this.rawBinaryData = new ArrayBuffer(t) : t instanceof Uint8Array ? this.rawBinaryData = t.buffer : this.rawBinaryData = t, this.uint32View = new Uint32Array(this.rawBinaryData), this.float32View = new Float32Array(this.rawBinaryData), this.size = this.rawBinaryData.byteLength } get int8View() { return this.An || (this.An = new Int8Array(this.rawBinaryData)), this.An } get uint8View() { return this.Cn || (this.Cn = new Uint8Array(this.rawBinaryData)), this.Cn } get int16View() { return this._n || (this._n = new Int16Array(this.rawBinaryData)), this._n } get int32View() { return this.Sn || (this.Sn = new Int32Array(this.rawBinaryData)), this.Sn } get float64View() { return this.Pn || (this.Pn = new Float64Array(this.rawBinaryData)), this.Pn } get bigUint64View() { return this.kn || (this.kn = new BigUint64Array(this.rawBinaryData)), this.kn } view(t) { return this[`${t}View`] } destroy() { this.rawBinaryData = null, this.uint32View = null, this.float32View = null, this.uint16View = null, this.An = null, this.Cn = null, this._n = null, this.Sn = null, this.Pn = null, this.kn = null } static sizeOf(t) { switch (t) { case "int8": case "uint8": return 1; case "int16": case "uint16": return 2; case "int32": case "uint32": case "float32": return 4; default: throw new Error(`${t} isn't a valid view type`) } } } function Cn(t, s) { const e = t.byteLength / 8 | 0, i = new Float64Array(t, 0, e); new Float64Array(s, 0, e).set(i); const n = t.byteLength - 8 * e; if (n > 0) { const i = new Uint8Array(t, 8 * e, n); new Uint8Array(s, 8 * e, n).set(i) } } const _n = { normal: "normal-npm", add: "add-npm", screen: "screen-npm" }; var Sn = (t => (t[t.DISABLED = 0] = "DISABLED", t[t.RENDERING_MASK_ADD = 1] = "RENDERING_MASK_ADD", t[t.MASK_ACTIVE = 2] = "MASK_ACTIVE", t[t.INVERSE_MASK_ACTIVE = 3] = "INVERSE_MASK_ACTIVE", t[t.RENDERING_MASK_REMOVE = 4] = "RENDERING_MASK_REMOVE", t[t.NONE = 5] = "NONE", t))(Sn || {}); function Pn(t, s) { return "no-premultiply-alpha" === s.alphaMode && _n[t] || t } const kn = ["precision mediump float;", "void main(void){", "float test = 0.1;", "%forloop%", "gl_FragColor = vec4(0.0);", "}"].join("\n"); function Fn(t) { let s = ""; for (let e = 0; e < t; ++e)e > 0 && (s += "\nelse "), e < t - 1 && (s += `if(test == ${e}.0){}`); return s } function En(t, s) { if (0 === t) throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`"); const e = s.createShader(s.FRAGMENT_SHADER); try { for (; ;) { const i = kn.replace(/%forloop%/gi, Fn(t)); if (s.shaderSource(e, i), s.compileShader(e), s.getShaderParameter(e, s.COMPILE_STATUS)) break; t = t / 2 | 0 } } finally { s.deleteShader(e) } return t } let Rn = null; class On { constructor() { this.ids = Object.create(null), this.textures = [], this.count = 0 } clear() { for (let t = 0; t < this.count; t++) { const s = this.textures[t]; this.textures[t] = null, this.ids[s.uid] = null } this.count = 0 } } class Un { constructor() { this.renderPipeId = "batch", this.action = "startBatch", this.start = 0, this.size = 0, this.textures = new On, this.blendMode = "normal", this.topology = "triangle-strip", this.canBundle = !0 } destroy() { this.textures = null, this.gpuBindGroup = null, this.bindGroup = null, this.batcher = null } } const In = []; let Bn = 0; function $n() { return Bn > 0 ? In[--Bn] : new Un } function Gn(t) { In[Bn++] = t } Rt.register({ clear: () => { if (In.length > 0) for (const t of In) t && t.destroy(); In.length = 0, Bn = 0 } }); let zn = 0; const Dn = class t { constructor(s) { this.uid = I("batcher"), this.dirty = !0, this.batchIndex = 0, this.batches = [], this.Fn = [], (s = { ...t.defaultOptions, ...s }).maxTextures || (G(0, "maxTextures is a required option for Batcher now, please pass it in the options"), s.maxTextures = function () { if (Rn) return Rn; const t = Fe(); return Rn = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS), Rn = En(Rn, t), t.getExtension("WEBGL_lose_context")?.loseContext(), Rn }()); const { maxTextures: e, attributesInitialSize: i, indicesInitialSize: n } = s; this.attributeBuffer = new An(4 * i), this.indexBuffer = new Uint16Array(n), this.maxTextures = e } begin() { this.elementSize = 0, this.elementStart = 0, this.indexSize = 0, this.attributeSize = 0; for (let t = 0; t < this.batchIndex; t++)Gn(this.batches[t]); this.batchIndex = 0, this.En = 0, this.Rn = 0, this.dirty = !0 } add(t) { this.Fn[this.elementSize++] = t, t.On = this.indexSize, t.Un = this.attributeSize, t.In = this, this.indexSize += t.indexSize, this.attributeSize += t.attributeSize * this.vertexSize } checkAndUpdateTexture(t, s) { const e = t.Bn.textures.ids[s.K.uid]; return !(!e && 0 !== e || (t.$n = e, t.texture = s, 0)) } updateElement(t) { this.dirty = !0; const s = this.attributeBuffer; t.packAsQuad ? this.packQuadAttributes(t, s.float32View, s.uint32View, t.Un, t.$n) : this.packAttributes(t, s.float32View, s.uint32View, t.Un, t.$n) } break(t) { const s = this.Fn; if (!s[this.elementStart]) return; let e = $n(), i = e.textures; i.clear(); const n = s[this.elementStart]; let r = Pn(n.blendMode, n.texture.K), o = n.topology; 4 * this.attributeSize > this.attributeBuffer.size && this.Gn(4 * this.attributeSize), this.indexSize > this.indexBuffer.length && this.zn(this.indexSize); const h = this.attributeBuffer.float32View, a = this.attributeBuffer.uint32View, l = this.indexBuffer; let u = this.Rn, c = this.En, f = "startBatch"; const d = this.maxTextures; for (let p = this.elementStart; p < this.elementSize; ++p) { const n = s[p]; s[p] = null; const m = n.texture.K, g = Pn(n.blendMode, m), v = r !== g || o !== n.topology; m.G !== zn || v ? (m.G = zn, (i.count >= d || v) && (this.Dn(e, c, u - c, i, r, o, t, f), f = "renderBatch", c = u, r = g, o = n.topology, e = $n(), i = e.textures, i.clear(), ++zn), n.$n = m.D = i.count, i.ids[m.uid] = i.count, i.textures[i.count++] = m, n.Bn = e, u += n.indexSize, n.packAsQuad ? (this.packQuadAttributes(n, h, a, n.Un, n.$n), this.packQuadIndex(l, n.On, n.Un / this.vertexSize)) : (this.packAttributes(n, h, a, n.Un, n.$n), this.packIndex(n, l, n.On, n.Un / this.vertexSize))) : (n.$n = m.D, u += n.indexSize, n.packAsQuad ? (this.packQuadAttributes(n, h, a, n.Un, n.$n), this.packQuadIndex(l, n.On, n.Un / this.vertexSize)) : (this.packAttributes(n, h, a, n.Un, n.$n), this.packIndex(n, l, n.On, n.Un / this.vertexSize)), n.Bn = e) } i.count > 0 && (this.Dn(e, c, u - c, i, r, o, t, f), c = u, ++zn), this.elementStart = this.elementSize, this.En = c, this.Rn = u } Dn(t, s, e, i, n, r, o, h) { t.gpuBindGroup = null, t.bindGroup = null, t.action = h, t.batcher = this, t.textures = i, t.blendMode = n, t.topology = r, t.start = s, t.size = e, ++zn, this.batches[this.batchIndex++] = t, o.add(t) } finish(t) { this.break(t) } ensureAttributeBuffer(t) { 4 * t <= this.attributeBuffer.size || this.Gn(4 * t) } ensureIndexBuffer(t) { t <= this.indexBuffer.length || this.zn(t) } Gn(t) { const s = Math.max(t, 2 * this.attributeBuffer.size), e = new An(s); Cn(this.attributeBuffer.rawBinaryData, e.rawBinaryData), this.attributeBuffer = e } zn(t) { const s = this.indexBuffer; let e = Math.max(t, 1.5 * s.length); e += e % 2; const i = e > 65535 ? new Uint32Array(e) : new Uint16Array(e); if (i.BYTES_PER_ELEMENT !== s.BYTES_PER_ELEMENT) for (let n = 0; n < s.length; n++)i[n] = s[n]; else Cn(s.buffer, i.buffer); this.indexBuffer = i } packQuadIndex(t, s, e) { t[s] = e + 0, t[s + 1] = e + 1, t[s + 2] = e + 2, t[s + 3] = e + 0, t[s + 4] = e + 2, t[s + 5] = e + 3 } packIndex(t, s, e, i) { const n = t.indices, r = t.indexSize, o = t.indexOffset, h = t.attributeOffset; for (let a = 0; a < r; a++)s[e++] = i + n[a + o] - h } destroy(t = {}) { if (null !== this.batches) { for (let t = 0; t < this.batches.length; t++)Gn(this.batches[t]); this.batches = null, this.geometry.destroy(!0), this.geometry = null, t.shader && (this.shader?.destroy(), this.shader = null); for (let t = 0; t < this.Fn.length; t++)this.Fn[t] && (this.Fn[t].Bn = null); this.Fn = null, this.indexBuffer = null, this.attributeBuffer.destroy(), this.attributeBuffer = null } } }; Dn.defaultOptions = { maxTextures: null, attributesInitialSize: 4, indicesInitialSize: 6 }; let jn = Dn; var Ln = (t => (t[t.MAP_READ = 1] = "MAP_READ", t[t.MAP_WRITE = 2] = "MAP_WRITE", t[t.COPY_SRC = 4] = "COPY_SRC", t[t.COPY_DST = 8] = "COPY_DST", t[t.INDEX = 16] = "INDEX", t[t.VERTEX = 32] = "VERTEX", t[t.UNIFORM = 64] = "UNIFORM", t[t.STORAGE = 128] = "STORAGE", t[t.INDIRECT = 256] = "INDIRECT", t[t.QUERY_RESOLVE = 512] = "QUERY_RESOLVE", t[t.STATIC = 1024] = "STATIC", t))(Ln || {}); class Vn extends m { constructor(t) { let { data: s, size: e } = t; const { usage: i, label: n, shrinkToFit: r } = t; super(), this.uid = I("buffer"), this.F = "buffer", this.U = I("resource"), this.R = 0, this.X = 1, this.jn = null, this.shrinkToFit = !0, this.destroyed = !1, s instanceof Array && (s = new Float32Array(s)), this.Ln = s, e ?? (e = s?.byteLength); const o = !!s; this.descriptor = { size: e, usage: i, mappedAtCreation: o, label: n }, this.shrinkToFit = r ?? !0 } get data() { return this.Ln } set data(t) { this.setDataWithSize(t, t.length, !0) } get dataInt32() { return this.jn || (this.jn = new Int32Array(this.data.buffer)), this.jn } get static() { return !!(this.descriptor.usage & Ln.STATIC) } set static(t) { t ? this.descriptor.usage |= Ln.STATIC : this.descriptor.usage &= ~Ln.STATIC } setDataWithSize(t, s, e) { if (this.X++, this.Vn = s * t.BYTES_PER_ELEMENT, this.Ln === t) return void (e && this.emit("update", this)); const i = this.Ln; this.Ln = t, this.jn = null, i && i.length === t.length || !this.shrinkToFit && i && t.byteLength < i.byteLength ? e && this.emit("update", this) : (this.descriptor.size = t.byteLength, this.U = I("resource"), this.emit("change", this)) } update(t) { this.Vn = t ?? this.Vn, this.X++, this.emit("update", this) } destroy() { this.destroyed = !0, this.emit("destroy", this), this.emit("change", this), this.Ln = null, this.descriptor = null, this.removeAllListeners() } } function Nn(t, s) { if (!(t instanceof Vn)) { let e = s ? Ln.INDEX : Ln.VERTEX; t instanceof Array && (s ? (t = new Uint32Array(t), e = Ln.INDEX | Ln.COPY_DST) : (t = new Float32Array(t), e = Ln.VERTEX | Ln.COPY_DST)), t = new Vn({ data: t, label: s ? "index-mesh-buffer" : "vertex-mesh-buffer", usage: e }) } return t } class Wn extends m { constructor(t = {}) { super(), this.uid = I("geometry"), this.Si = 0, this.instanceCount = 1, this.gs = new tt, this.vs = !0; const { attributes: s, indexBuffer: e, topology: i } = t; if (this.buffers = [], this.attributes = {}, s) for (const n in s) this.addAttribute(n, s[n]); this.instanceCount = t.instanceCount ?? 1, e && this.addIndex(e), this.topology = i || "triangle-list" } onBufferUpdate() { this.vs = !0, this.emit("update", this) } getAttribute(t) { return this.attributes[t] } getIndex() { return this.indexBuffer } getBuffer(t) { return this.getAttribute(t).buffer } getSize() { for (const t in this.attributes) { const s = this.attributes[t]; return s.buffer.data.length / (s.stride / 4 || s.size) } return 0 } addAttribute(t, s) { const e = function (t) { return (t instanceof Vn || Array.isArray(t) || t.BYTES_PER_ELEMENT) && (t = { buffer: t }), t.buffer = Nn(t.buffer, !1), t }(s); -1 === this.buffers.indexOf(e.buffer) && (this.buffers.push(e.buffer), e.buffer.on("update", this.onBufferUpdate, this), e.buffer.on("change", this.onBufferUpdate, this)), this.attributes[t] = e } addIndex(t) { this.indexBuffer = Nn(t, !0), this.buffers.push(this.indexBuffer) } get bounds() { return this.vs ? (this.vs = !1, function (t, s, e) { const i = t.getAttribute("aPosition"); if (!i) return e.minX = 0, e.minY = 0, e.maxX = 0, e.maxY = 0, e; const n = i.buffer.data; let r = 1 / 0, o = 1 / 0, h = -1 / 0, a = -1 / 0; const l = n.BYTES_PER_ELEMENT, u = (i.offset || 0) / l, c = (i.stride || 8) / l; for (let f = u; f < n.length; f += c) { const t = n[f], s = n[f + 1]; t > h && (h = t), s > a && (a = s), t < r && (r = t), s < o && (o = s) } return e.minX = r, e.minY = o, e.maxX = h, e.maxY = a, e }(this, 0, this.gs)) : this.gs } destroy(t = !1) { this.emit("destroy", this), this.removeAllListeners(), t && this.buffers.forEach(t => t.destroy()), this.indexBuffer?.destroy(), this.attributes = null, this.buffers = null, this.indexBuffer = null, this.gs = null } } const Hn = new Float32Array(1), qn = new Uint32Array(1); class Xn extends Wn { constructor() { const t = new Vn({ data: Hn, label: "attribute-batch-buffer", usage: Ln.VERTEX | Ln.COPY_DST, shrinkToFit: !1 }); super({ attributes: { aPosition: { buffer: t, format: "float32x2", stride: 24, offset: 0 }, aUV: { buffer: t, format: "float32x2", stride: 24, offset: 8 }, aColor: { buffer: t, format: "unorm8x4", stride: 24, offset: 16 }, aTextureIdAndRound: { buffer: t, format: "uint16x2", stride: 24, offset: 20 } }, indexBuffer: new Vn({ data: qn, label: "index-batch-buffer", usage: Ln.INDEX | Ln.COPY_DST, shrinkToFit: !1 }) }) } } function Yn(t, s, e) { if (t) for (const i in t) { const n = s[i.toLocaleLowerCase()]; if (n) { let s = t[i]; "header" === i && (s = s.replace(/@in\s+[^;]+;\s*/g, "").replace(/@out\s+[^;]+;\s*/g, "")), e && n.push(`//----${e}----//`), n.push(s) } else Et() } } const Kn = /\{\{(.*?)\}\}/g; function Zn(t) { const s = {}; return (t.match(Kn)?.map(t => t.replace(/[{()}]/g, "")) ?? []).forEach(t => { s[t] = [] }), s } function Qn(t, s) { let e; const i = /@in\s+([^;]+);/g; for (; null !== (e = i.exec(t));)s.push(e[1]) } function Jn(t, s, e = !1) { const i = []; Qn(s, i), t.forEach(t => { t.header && Qn(t.header, i) }); const n = i; e && n.sort(); const r = n.map((t, s) => `       @location(${s}) ${t},`).join("\n"); let o = s.replace(/@in\s+[^;]+;\s*/g, ""); return o = o.replace("{{in}}", `\n${r}\n`), o } function tr(t, s) { let e; const i = /@out\s+([^;]+);/g; for (; null !== (e = i.exec(t));)s.push(e[1]) } function sr(t, s) { let e = t; for (const i in s) { const t = s[i]; e = t.join("\n").length ? e.replace(`{{${i}}}`, `//-----${i} START-----//\n${t.join("\n")}\n//----${i} FINISH----//`) : e.replace(`{{${i}}}`, "") } return e } const er = Object.create(null), ir = new Map; let nr = 0; function rr({ template: t, bits: s }) { const e = or(t, s); return er[e] || (er[e] = hr(t.vertex, t.fragment, s)), er[e] } function or(t, s) { return s.map(t => (ir.has(t) || ir.set(t, nr++), ir.get(t))).sort((t, s) => t - s).join("-") + t.vertex + t.fragment } function hr(t, s, e) { const i = Zn(t), n = Zn(s); return e.forEach(t => { Yn(t.vertex, i, t.name), Yn(t.fragment, n, t.name) }), { vertex: sr(t, i), fragment: sr(s, n) } } const ar = { name: "global-uniforms-bit", vertex: { header: "\n        struct GlobalUniforms {\n            uProjectionMatrix:mat3x3<f32>,\n            uWorldTransformMatrix:mat3x3<f32>,\n            uWorldColorAlpha: vec4<f32>,\n            uResolution: vec2<f32>,\n        }\n\n        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;\n        " } }, lr = { name: "global-uniforms-bit", vertex: { header: "\n          uniform mat3 uProjectionMatrix;\n          uniform mat3 uWorldTransformMatrix;\n          uniform vec4 uWorldColorAlpha;\n          uniform vec2 uResolution;\n        " } }; function ur({ bits: t, name: s }) { const e = function ({ template: t, bits: s }) { const e = or(t, s); if (er[e]) return er[e]; const { vertex: i, fragment: n } = function (t, s) { const e = s.map(t => t.vertex).filter(t => !!t), i = s.map(t => t.fragment).filter(t => !!t); let n = Jn(e, t.vertex, !0); return n = function (t, s) { const e = []; tr(s, e), t.forEach(t => { t.header && tr(t.header, e) }); let i = 0; const n = e.sort().map(t => t.indexOf("builtin") > -1 ? t : `@location(${i++}) ${t}`).join(",\n"), r = e.sort().map(t => { return `       var ${s = t, s.replace(/@.*?\s+/g, "")};`; var s }).join("\n"), o = `return VSOutput(\n            ${e.sort().map(t => ` ${function (t) { const s = /\b(\w+)\s*:/g.exec(t); return s ? s[1] : "" }(t)}`).join(",\n")});`; let h = s.replace(/@out\s+[^;]+;\s*/g, ""); return h = h.replace("{{struct}}", `\n${n}\n`), h = h.replace("{{start}}", `\n${r}\n`), h = h.replace("{{return}}", `\n${o}\n`), h }(e, n), { vertex: n, fragment: Jn(i, t.fragment, !0) } }(t, s); return er[e] = hr(i, n, s), er[e] }({ template: { fragment: "\n    @in vUV : vec2<f32>;\n    @in vColor : vec4<f32>;\n\n    {{header}}\n\n    @fragment\n    fn main(\n        {{in}}\n      ) -> @location(0) vec4<f32> {\n\n        {{start}}\n\n        var outColor:vec4<f32>;\n\n        {{main}}\n\n        var finalColor:vec4<f32> = outColor * vColor;\n\n        {{end}}\n\n        return finalColor;\n      };\n", vertex: "\n    @in aPosition: vec2<f32>;\n    @in aUV: vec2<f32>;\n\n    @out @builtin(position) vPosition: vec4<f32>;\n    @out vUV : vec2<f32>;\n    @out vColor : vec4<f32>;\n\n    {{header}}\n\n    struct VSOutput {\n        {{struct}}\n    };\n\n    @vertex\n    fn main( {{in}} ) -> VSOutput {\n\n        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;\n        var modelMatrix = mat3x3<f32>(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        var position = aPosition;\n        var uv = aUV;\n\n        {{start}}\n\n        vColor = vec4<f32>(1., 1., 1., 1.);\n\n        {{main}}\n\n        vUV = uv;\n\n        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);\n\n        vColor *= globalUniforms.uWorldColorAlpha;\n\n        {{end}}\n\n        {{return}}\n    };\n" }, bits: [ar, ...t] }); return Ne.from({ name: s, vertex: { source: e.vertex, entryPoint: "main" }, fragment: { source: e.fragment, entryPoint: "main" } }) } function cr({ bits: t, name: s }) { return new $e({ name: s, ...rr({ template: { vertex: "\n    in vec2 aPosition;\n    in vec2 aUV;\n\n    out vec4 vColor;\n    out vec2 vUV;\n\n    {{header}}\n\n    void main(void){\n\n        mat3 worldTransformMatrix = uWorldTransformMatrix;\n        mat3 modelMatrix = mat3(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        vec2 position = aPosition;\n        vec2 uv = aUV;\n\n        {{start}}\n\n        vColor = vec4(1.);\n\n        {{main}}\n\n        vUV = uv;\n\n        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n\n        vColor *= uWorldColorAlpha;\n\n        {{end}}\n    }\n", fragment: "\n\n    in vec4 vColor;\n    in vec2 vUV;\n\n    out vec4 finalColor;\n\n    {{header}}\n\n    void main(void) {\n\n        {{start}}\n\n        vec4 outColor;\n\n        {{main}}\n\n        finalColor = outColor * vColor;\n\n        {{end}}\n    }\n" }, bits: [lr, ...t] }) }) } const fr = { name: "color-bit", vertex: { header: "\n            @in aColor: vec4<f32>;\n        ", main: "\n            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);\n        " } }, dr = { name: "color-bit", vertex: { header: "\n            in vec4 aColor;\n        ", main: "\n            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);\n        " } }, pr = {}; function mr(t) { const s = []; if (1 === t) s.push("@group(1) @binding(0) var textureSource1: texture_2d<f32>;"), s.push("@group(1) @binding(1) var textureSampler1: sampler;"); else { let e = 0; for (let i = 0; i < t; i++)s.push(`@group(1) @binding(${e++}) var textureSource${i + 1}: texture_2d<f32>;`), s.push(`@group(1) @binding(${e++}) var textureSampler${i + 1}: sampler;`) } return s.join("\n") } function gr(t) { const s = []; if (1 === t) s.push("outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);"); else { s.push("switch vTextureId {"); for (let e = 0; e < t; e++)e === t - 1 ? s.push("  default:{") : s.push(`  case ${e}:{`), s.push(`      outColor = textureSampleGrad(textureSource${e + 1}, textureSampler${e + 1}, vUV, uvDx, uvDy);`), s.push("      break;}"); s.push("}") } return s.join("\n") } function vr(t) { return pr[t] || (pr[t] = { name: "texture-batch-bit", vertex: { header: "\n                @in aTextureIdAndRound: vec2<u32>;\n                @out @interpolate(flat) vTextureId : u32;\n            ", main: "\n                vTextureId = aTextureIdAndRound.y;\n            ", end: "\n                if(aTextureIdAndRound.x == 1)\n                {\n                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n                }\n            " }, fragment: { header: `\n                @in @interpolate(flat) vTextureId: u32;\n\n                ${mr(t)}\n            `, main: `\n                var uvDx = dpdx(vUV);\n                var uvDy = dpdy(vUV);\n\n                ${gr(t)}\n            ` } }), pr[t] } const br = {}; function xr(t) { const s = []; for (let e = 0; e < t; e++)e > 0 && s.push("else"), e < t - 1 && s.push(`if(vTextureId < ${e}.5)`), s.push("{"), s.push(`\toutColor = texture(uTextures[${e}], vUV);`), s.push("}"); return s.join("\n") } function yr(t) { return br[t] || (br[t] = { name: "texture-batch-bit", vertex: { header: "\n                in vec2 aTextureIdAndRound;\n                out float vTextureId;\n\n            ", main: "\n                vTextureId = aTextureIdAndRound.y;\n            ", end: "\n                if(aTextureIdAndRound.x == 1.)\n                {\n                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n                }\n            " }, fragment: { header: `\n                in float vTextureId;\n\n                uniform sampler2D uTextures[${t}];\n\n            `, main: `\n\n                ${xr(t)}\n            ` } }), br[t] } const wr = { name: "round-pixels-bit", vertex: { header: "\n            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32>\n            {\n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        " } }, Mr = { name: "round-pixels-bit", vertex: { header: "\n            vec2 roundPixels(vec2 position, vec2 targetSize)\n            {\n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        " } }, Tr = {}; function Ar(t) { let s = Tr[t]; if (s) return s; const e = new Int32Array(t); for (let i = 0; i < t; i++)e[i] = i; return s = Tr[t] = new Ye({ uTextures: { value: e, type: "i32", size: t } }, { isStatic: !0 }), s } class Cr extends Qe { constructor(t) { super({ glProgram: cr({ name: "batch", bits: [dr, yr(t), Mr] }), gpuProgram: ur({ name: "batch", bits: [fr, vr(t), wr] }), resources: { batchSamplers: Ar(t) } }), this.maxTextures = t } } let _r = null; const Sr = class t extends jn { constructor(s) { super(s), this.geometry = new Xn, this.name = t.extension.name, this.vertexSize = 6, _r ?? (_r = new Cr(s.maxTextures)), this.shader = _r } packAttributes(t, s, e, i, n) { const r = n << 16 | 65535 & t.roundPixels, o = t.transform, h = o.a, a = o.b, l = o.c, u = o.d, c = o.tx, f = o.ty, { positions: d, uvs: p } = t, m = t.color, g = t.attributeOffset, v = g + t.attributeSize; for (let b = g; b < v; b++) { const t = 2 * b, n = d[t], o = d[t + 1]; s[i++] = h * n + l * o + c, s[i++] = u * o + a * n + f, s[i++] = p[t], s[i++] = p[t + 1], e[i++] = m, e[i++] = r } } packQuadAttributes(t, s, e, i, n) { const r = t.texture, o = t.transform, h = o.a, a = o.b, l = o.c, u = o.d, c = o.tx, f = o.ty, d = t.bounds, p = d.maxX, m = d.minX, g = d.maxY, v = d.minY, b = r.uvs, x = t.color, y = n << 16 | 65535 & t.roundPixels; s[i + 0] = h * m + l * v + c, s[i + 1] = u * v + a * m + f, s[i + 2] = b.x0, s[i + 3] = b.y0, e[i + 4] = x, e[i + 5] = y, s[i + 6] = h * p + l * v + c, s[i + 7] = u * v + a * p + f, s[i + 8] = b.x1, s[i + 9] = b.y1, e[i + 10] = x, e[i + 11] = y, s[i + 12] = h * p + l * g + c, s[i + 13] = u * g + a * p + f, s[i + 14] = b.x2, s[i + 15] = b.y2, e[i + 16] = x, e[i + 17] = y, s[i + 18] = h * m + l * g + c, s[i + 19] = u * g + a * m + f, s[i + 20] = b.x3, s[i + 21] = b.y3, e[i + 22] = x, e[i + 23] = y } Nn(t) { this.shader.maxTextures !== t && (_r = new Cr(t), this.shader = _r) } destroy() { this.shader = null, super.destroy() } }; Sr.extension = { type: [r.Batcher], name: "default" }; let Pr = Sr; function kr(t, s, e, i, n) { const r = s.a, o = s.b, h = s.c, a = s.d, l = s.tx, u = s.ty; e || (e = 0), i || (i = 2), n || (n = t.length / i - e); let c = e * i; for (let f = 0; f < n; f++) { const s = t[c], e = t[c + 1]; t[c] = r * s + h * e + l, t[c + 1] = o * s + a * e + u, c += i } } const Fr = new w; class Er { constructor() { this.packAsQuad = !1, this.batcherName = "default", this.topology = "triangle-list", this.applyTransform = !0, this.roundPixels = 0, this.In = null, this.Bn = null } get uvs() { return this.geometryData.uvs } get positions() { return this.geometryData.vertices } get indices() { return this.geometryData.indices } get blendMode() { return this.renderable && this.applyTransform ? this.renderable.groupBlendMode : "normal" } get color() { const t = this.baseColor, s = t >> 16 | 65280 & t | (255 & t) << 16, e = this.renderable; return e ? Kt(s, e.groupColor) + (this.alpha * e.groupAlpha * 255 << 24) : s + (255 * this.alpha << 24) } get transform() { return this.renderable?.groupTransform || Fr } copyTo(t) { t.indexOffset = this.indexOffset, t.indexSize = this.indexSize, t.attributeOffset = this.attributeOffset, t.attributeSize = this.attributeSize, t.baseColor = this.baseColor, t.alpha = this.alpha, t.texture = this.texture, t.geometryData = this.geometryData, t.topology = this.topology } reset() { this.applyTransform = !0, this.renderable = null, this.topology = "triangle-list" } destroy() { this.renderable = null, this.texture = null, this.geometryData = null, this.In = null, this.Bn = null } } const Rr = { extension: { type: r.ShapeBuilder, name: "circle" }, build(t, s) { let e, i, n, r, o, h; if ("circle" === t.type) { const s = t; if (o = h = s.radius, o <= 0) return !1; e = s.x, i = s.y, n = r = 0 } else if ("ellipse" === t.type) { const s = t; if (o = s.halfWidth, h = s.halfHeight, o <= 0 || h <= 0) return !1; e = s.x, i = s.y, n = r = 0 } else { const s = t, a = s.width / 2, l = s.height / 2; e = s.x + a, i = s.y + l, o = h = Math.max(0, Math.min(s.radius, Math.min(a, l))), n = a - o, r = l - h } if (n < 0 || r < 0) return !1; const a = Math.ceil(2.3 * Math.sqrt(o + h)), l = 8 * a + (n ? 4 : 0) + (r ? 4 : 0); if (0 === l) return !1; if (0 === a) return s[0] = s[6] = e + n, s[1] = s[3] = i + r, s[2] = s[4] = e - n, s[5] = s[7] = i - r, !0; let u = 0, c = 4 * a + (n ? 2 : 0) + 2, f = c, d = l, p = n + o, m = r, g = e + p, v = e - p, b = i + m; if (s[u++] = g, s[u++] = b, s[--c] = b, s[--c] = v, r) { const t = i - m; s[f++] = v, s[f++] = t, s[--d] = t, s[--d] = g } for (let y = 1; y < a; y++) { const t = Math.PI / 2 * (y / a), l = n + Math.cos(t) * o, p = r + Math.sin(t) * h, m = e + l, g = e - l, v = i + p, b = i - p; s[u++] = m, s[u++] = v, s[--c] = v, s[--c] = g, s[f++] = g, s[f++] = b, s[--d] = b, s[--d] = m } p = n, m = r + h, g = e + p, v = e - p, b = i + m; const x = i - m; return s[u++] = g, s[u++] = b, s[--d] = x, s[--d] = g, n && (s[u++] = v, s[u++] = b, s[--d] = x, s[--d] = v), !0 }, triangulate(t, s, e, i, n, r) { if (0 === t.length) return; let o = 0, h = 0; for (let u = 0; u < t.length; u += 2)o += t[u], h += t[u + 1]; o /= t.length / 2, h /= t.length / 2; let a = i; s[a * e] = o, s[a * e + 1] = h; const l = a++; for (let u = 0; u < t.length; u += 2)s[a * e] = t[u], s[a * e + 1] = t[u + 1], u > 0 && (n[r++] = a, n[r++] = l, n[r++] = a - 1), a++; n[r++] = l + 1, n[r++] = l, n[r++] = a - 1 } }, Or = { ...Rr, extension: { ...Rr.extension, name: "ellipse" } }, Ur = { ...Rr, extension: { ...Rr.extension, name: "roundedRectangle" } }, Ir = 1e-4; function Br(t, s, e, i, n, r, o, h) { let a, l; o ? (a = i, l = -e) : (a = -i, l = e); const u = t - e * n + a, c = s - i * n + l, f = t + e * r + a, d = s + i * r + l; return h.push(u, c), h.push(f, d), 2 } function $r(t, s, e, i, n, r, o, h) { const a = e - t, l = i - s; let u = Math.atan2(a, l), c = Math.atan2(n - t, r - s); h && u < c ? u += 2 * Math.PI : !h && u > c && (c += 2 * Math.PI); let f = u; const d = c - u, p = Math.abs(d), m = Math.sqrt(a * a + l * l), g = 1 + (15 * p * Math.sqrt(m) / Math.PI | 0), v = d / g; if (f += v, h) { o.push(t, s), o.push(e, i); for (let e = 1, i = f; e < g; e++, i += v)o.push(t, s), o.push(t + Math.sin(i) * m, s + Math.cos(i) * m); o.push(t, s), o.push(n, r) } else { o.push(e, i), o.push(t, s); for (let e = 1, i = f; e < g; e++, i += v)o.push(t + Math.sin(i) * m, s + Math.cos(i) * m), o.push(t, s); o.push(n, r), o.push(t, s) } return 2 * g } function Gr(t, s, e, i, n, r, o) { const h = Oi(t, s, 2); if (!h) return; for (let l = 0; l < h.length; l += 3)r[o++] = h[l] + n, r[o++] = h[l + 1] + n, r[o++] = h[l + 2] + n; let a = n * i; for (let l = 0; l < t.length; l += 2)e[a] = t[l], e[a + 1] = t[l + 1], a += i } const zr = [], Dr = { extension: { type: r.ShapeBuilder, name: "polygon" }, build(t, s) { for (let e = 0; e < t.points.length; e++)s[e] = t.points[e]; return !0 }, triangulate(t, s, e, i, n, r) { Gr(t, zr, s, e, i, n, r) } }, jr = { extension: { type: r.ShapeBuilder, name: "rectangle" }, build(t, s) { const e = t, i = e.x, n = e.y, r = e.width, o = e.height; return r > 0 && o > 0 && (s[0] = i, s[1] = n, s[2] = i + r, s[3] = n, s[4] = i + r, s[5] = n + o, s[6] = i, s[7] = n + o, !0) }, triangulate(t, s, e, i, n, r) { let o = 0; s[(i *= e) + o] = t[0], s[i + o + 1] = t[1], o += e, s[i + o] = t[2], s[i + o + 1] = t[3], o += e, s[i + o] = t[6], s[i + o + 1] = t[7], o += e, s[i + o] = t[4], s[i + o + 1] = t[5], o += e; const h = i / e; n[r++] = h, n[r++] = h + 1, n[r++] = h + 2, n[r++] = h + 1, n[r++] = h + 3, n[r++] = h + 2 } }, Lr = { extension: { type: r.ShapeBuilder, name: "triangle" }, build: (t, s) => (s[0] = t.x, s[1] = t.y, s[2] = t.x2, s[3] = t.y2, s[4] = t.x3, s[5] = t.y3, !0), triangulate(t, s, e, i, n, r) { let o = 0; s[(i *= e) + o] = t[0], s[i + o + 1] = t[1], o += e, s[i + o] = t[2], s[i + o + 1] = t[3], o += e, s[i + o] = t[4], s[i + o + 1] = t[5]; const h = i / e; n[r++] = h, n[r++] = h + 1, n[r++] = h + 2 } }, Vr = new w, Nr = new O, Wr = {}; a.handleByMap(r.ShapeBuilder, Wr), a.add(jr, Dr, Lr, Rr, Or, Ur); const Hr = new O, qr = new w; function Xr(t, s, e) { const i = [], n = Wr.rectangle, r = Hr; r.x = t.dx, r.y = t.dy, r.width = t.dw, r.height = t.dh; const o = t.transform; if (!n.build(r, i)) return; const { vertices: h, uvs: a, indices: l } = e, u = l.length, c = h.length / 2; o && kr(i, o), n.triangulate(i, h, 2, c, l, u); const f = t.image, d = f.uvs; a.push(d.x0, d.y0, d.x1, d.y1, d.x3, d.y3, d.x2, d.y2); const p = Ut.get(Er); p.indexOffset = u, p.indexSize = l.length - u, p.attributeOffset = c, p.attributeSize = h.length / 2 - c, p.baseColor = t.style, p.alpha = t.alpha, p.texture = f, p.geometryData = e, s.push(p) } function Yr(t, s, e, i, n) { const { vertices: r, uvs: o, indices: h } = n; t.shapePrimitives.forEach(({ shape: t, transform: a, holes: l }) => { const u = [], c = Wr[t.type]; if (!c.build(t, u)) return; const f = h.length, d = r.length / 2; let p = "triangle-list"; if (a && kr(u, a), e) { const e = t.closePath ?? !0, i = s; i.pixelLine ? (function (t, s, e, i) { const n = Ir; if (0 === t.length) return; const r = t[0], o = t[1], h = t[t.length - 2], a = t[t.length - 1], l = s || Math.abs(r - h) < n && Math.abs(o - a) < n, u = e, c = t.length / 2, f = u.length / 2; for (let d = 0; d < c; d++)u.push(t[2 * d]), u.push(t[2 * d + 1]); for (let d = 0; d < c - 1; d++)i.push(f + d, f + d + 1); l && i.push(f + c - 1, f) }(u, e, r, h), p = "line-list") : function (t, s, e, i, n, r) { const o = Ir; if (0 === t.length) return; const h = s; let a = h.alignment; if (.5 !== s.alignment) { let s = function (t) { const s = t.length; if (s < 6) return 1; let e = 0; for (let i = 0, n = t[s - 2], r = t[s - 1]; i < s; i += 2) { const s = t[i], o = t[i + 1]; e += (s - n) * (o + r), n = s, r = o } return e < 0 ? -1 : 1 }(t); a = (a - .5) * s + .5 } const l = new x(t[0], t[1]), u = new x(t[t.length - 2], t[t.length - 1]), c = i, f = Math.abs(l.x - u.x) < o && Math.abs(l.y - u.y) < o; if (c) { t = t.slice(), f && (t.pop(), t.pop(), u.set(t[t.length - 2], t[t.length - 1])); const s = .5 * (l.x + u.x), e = .5 * (u.y + l.y); t.unshift(s, e), t.push(s, e) } const d = n, p = t.length / 2; let m = t.length; const g = d.length / 2, v = h.width / 2, b = v * v, y = h.miterLimit * h.miterLimit; let w = t[0], M = t[1], T = t[2], A = t[3], C = 0, _ = 0, S = -(M - A), P = w - T, k = 0, F = 0, E = Math.sqrt(S * S + P * P); S /= E, P /= E, S *= v, P *= v; const R = 2 * (1 - a), O = 2 * a; c || ("round" === h.cap ? m += $r(w - S * (R - O) * .5, M - P * (R - O) * .5, w - S * R, M - P * R, w + S * O, M + P * O, d, !0) + 2 : "square" === h.cap && (m += Br(w, M, S, P, R, O, !0, d))), d.push(w - S * R, M - P * R), d.push(w + S * O, M + P * O); for (let x = 1; x < p - 1; ++x) { w = t[2 * (x - 1)], M = t[2 * (x - 1) + 1], T = t[2 * x], A = t[2 * x + 1], C = t[2 * (x + 1)], _ = t[2 * (x + 1) + 1], S = -(M - A), P = w - T, E = Math.sqrt(S * S + P * P), S /= E, P /= E, S *= v, P *= v, k = -(A - _), F = T - C, E = Math.sqrt(k * k + F * F), k /= E, F /= E, k *= v, F *= v; const s = T - w, e = M - A, i = T - C, n = _ - A, r = s * i + e * n, o = e * i - n * s, a = o < 0; if (Math.abs(o) < .001 * Math.abs(r)) { d.push(T - S * R, A - P * R), d.push(T + S * O, A + P * O), r >= 0 && ("round" === h.join ? m += $r(T, A, T - S * R, A - P * R, T - k * R, A - F * R, d, !1) + 4 : m += 2, d.push(T - k * O, A - F * O), d.push(T + k * R, A + F * R)); continue } const l = (-S + w) * (-P + A) - (-S + T) * (-P + M), u = (-k + C) * (-F + A) - (-k + T) * (-F + _), c = (s * u - i * l) / o, f = (n * l - e * u) / o, p = (c - T) * (c - T) + (f - A) * (f - A), g = T + (c - T) * R, U = A + (f - A) * R, I = T - (c - T) * O, B = A - (f - A) * O, $ = a ? R : O; p <= Math.min(s * s + e * e, i * i + n * n) + $ * $ * b ? "bevel" === h.join || p / b > y ? (a ? (d.push(g, U), d.push(T + S * O, A + P * O), d.push(g, U), d.push(T + k * O, A + F * O)) : (d.push(T - S * R, A - P * R), d.push(I, B), d.push(T - k * R, A - F * R), d.push(I, B)), m += 2) : "round" === h.join ? a ? (d.push(g, U), d.push(T + S * O, A + P * O), m += $r(T, A, T + S * O, A + P * O, T + k * O, A + F * O, d, !0) + 4, d.push(g, U), d.push(T + k * O, A + F * O)) : (d.push(T - S * R, A - P * R), d.push(I, B), m += $r(T, A, T - S * R, A - P * R, T - k * R, A - F * R, d, !1) + 4, d.push(T - k * R, A - F * R), d.push(I, B)) : (d.push(g, U), d.push(I, B)) : (d.push(T - S * R, A - P * R), d.push(T + S * O, A + P * O), "round" === h.join ? m += a ? $r(T, A, T + S * O, A + P * O, T + k * O, A + F * O, d, !0) + 2 : $r(T, A, T - S * R, A - P * R, T - k * R, A - F * R, d, !1) + 2 : "miter" === h.join && p / b <= y && (a ? (d.push(I, B), d.push(I, B)) : (d.push(g, U), d.push(g, U)), m += 2), d.push(T - k * R, A - F * R), d.push(T + k * O, A + F * O), m += 2) } w = t[2 * (p - 2)], M = t[2 * (p - 2) + 1], T = t[2 * (p - 1)], A = t[2 * (p - 1) + 1], S = -(M - A), P = w - T, E = Math.sqrt(S * S + P * P), S /= E, P /= E, S *= v, P *= v, d.push(T - S * R, A - P * R), d.push(T + S * O, A + P * O), c || ("round" === h.cap ? m += $r(T - S * (R - O) * .5, A - P * (R - O) * .5, T - S * R, A - P * R, T + S * O, A + P * O, d, !1) + 2 : "square" === h.cap && (m += Br(T, A, S, P, R, O, !1, d))); for (let x = g; x < m + g - 2; ++x)w = d[2 * x], M = d[2 * x + 1], T = d[2 * (x + 1)], A = d[2 * (x + 1) + 1], C = d[2 * (x + 2)], _ = d[2 * (x + 2) + 1], Math.abs(w * (A - _) + T * (_ - M) + C * (M - A)) < 1e-8 || r.push(x, x + 1, x + 2) }(u, i, 0, e, r, h) } else if (l) { const t = [], s = u.slice(); (function (t) { const s = []; for (let e = 0; e < t.length; e++) { const i = t[e].shape, n = []; Wr[i.type].build(i, n) && s.push(n) } return s })(l).forEach(e => { t.push(s.length / 2), s.push(...e) }), Gr(s, t, r, 2, d, h, f) } else c.triangulate(u, r, 2, d, h, f); const m = o.length / 2, g = s.texture; if (g !== Z.WHITE) { const e = function (t, s, e, i) { const n = s.matrix ? t.copyFrom(s.matrix).invert() : t.identity(); if ("local" === s.textureSpace) { const t = e.getBounds(Nr); s.width && t.pad(s.width); const { x: i, y: r } = t, o = 1 / t.width, h = 1 / t.height, a = -i * o, l = -r * h, u = n.a, c = n.b, f = n.c, d = n.d; n.a *= o, n.b *= o, n.c *= h, n.d *= h, n.tx = a * u + l * f + n.tx, n.ty = a * c + l * d + n.ty } else n.translate(s.texture.frame.x, s.texture.frame.y), n.scale(1 / s.texture.source.width, 1 / s.texture.source.height); const r = s.texture.source.style; return s.fill instanceof an || "clamp-to-edge" !== r.addressMode || (r.addressMode = "repeat", r.update()), i && n.append(Vr.copyFrom(i).invert()), n }(qr, s, t, a); !function (t, s, e, i, n, r, o, h = null) { let a = 0; e *= s, n *= r; const l = h.a, u = h.b, c = h.c, f = h.d, d = h.tx, p = h.ty; for (; a < o;) { const o = t[e], h = t[e + 1]; i[n] = l * o + c * h + d, i[n + 1] = u * o + f * h + p, n += r, e += s, a++ } }(r, 2, d, o, m, 2, r.length / 2 - d, e) } else !function (t, s, e, i) { let n = 0; for (s *= 2; n < i;)t[s] = 0, t[s + 1] = 0, s += 2, n++ }(o, m, 0, r.length / 2 - d); const v = Ut.get(Er); v.indexOffset = f, v.indexSize = h.length - f, v.attributeOffset = d, v.attributeSize = r.length / 2 - d, v.baseColor = s.color, v.alpha = s.alpha, v.texture = g, v.geometryData = n, v.topology = p, i.push(v) }) } class Kr { constructor() { this.batches = [], this.geometryData = { vertices: [], uvs: [], indices: [] } } } class Zr { constructor() { this.instructions = new us } init(t) { const s = t.maxTextures; this.batcher ? this.batcher.Nn(s) : this.batcher = new Pr({ maxTextures: s }), this.instructions.reset() } get geometry() { return G(0, "GraphicsContextRenderData#geometry is deprecated, please use batcher.geometry instead."), this.batcher.geometry } destroy() { this.batcher.destroy(), this.instructions.destroy(), this.batcher = null, this.instructions = null } } const Qr = class t { constructor(t) { this.Wn = {}, this.Hn = Object.create(null), this.Be = t, t.renderableGC.addManagedHash(this, "_gpuContextHash"), t.renderableGC.addManagedHash(this, "_graphicsDataContextHash") } init(s) { t.defaultOptions.bezierSmoothness = s?.bezierSmoothness ?? t.defaultOptions.bezierSmoothness } getContextRenderData(t) { return this.Hn[t.uid] || this.qn(t) } updateGpuContext(t) { let s = this.Wn[t.uid] || this.Xn(t); if (t.dirty) { s ? this.Yn(t) : s = this.Xn(t), function (t, s) { const { geometryData: e, batches: i } = s; i.length = 0, e.indices.length = 0, e.vertices.length = 0, e.uvs.length = 0; for (let n = 0; n < t.instructions.length; n++) { const s = t.instructions[n]; if ("texture" === s.action) Xr(s.data, i, e); else if ("fill" === s.action || "stroke" === s.action) { const t = "stroke" === s.action, n = s.data.path.shapePath, r = s.data.style, o = s.data.hole; t && o && Yr(o.shapePath, r, !0, i, e), o && (n.shapePrimitives[n.shapePrimitives.length - 1].holes = o.shapePath.shapePrimitives), Yr(n, r, t, i, e) } } }(t, s); const e = t.batchMode; t.customShader || "no-batch" === e ? s.isBatchable = !1 : s.isBatchable = "auto" !== e || s.geometryData.vertices.length < 400, t.dirty = !1 } return s } getGpuContext(t) { return this.Wn[t.uid] || this.Xn(t) } qn(t) { const s = Ut.get(Zr, { maxTextures: this.Be.limits.maxBatchableTextures }), { batches: e, geometryData: i } = this.Wn[t.uid], n = i.vertices.length, r = i.indices.length; for (let l = 0; l < e.length; l++)e[l].applyTransform = !1; const o = s.batcher; o.ensureAttributeBuffer(n), o.ensureIndexBuffer(r), o.begin(); for (let l = 0; l < e.length; l++) { const t = e[l]; o.add(t) } o.finish(s.instructions); const h = o.geometry; h.indexBuffer.setDataWithSize(o.indexBuffer, o.indexSize, !0), h.buffers[0].setDataWithSize(o.attributeBuffer.float32View, o.attributeSize, !0); const a = o.batches; for (let l = 0; l < a.length; l++) { const t = a[l]; t.bindGroup = Tn(t.textures.textures, t.textures.count, this.Be.limits.maxBatchableTextures) } return this.Hn[t.uid] = s, s } Xn(t) { const s = new Kr; return s.context = t, this.Wn[t.uid] = s, t.on("destroy", this.onGraphicsContextDestroy, this), this.Wn[t.uid] } onGraphicsContextDestroy(t) { this.Yn(t), t.off("destroy", this.onGraphicsContextDestroy, this), this.Wn[t.uid] = null } Yn(t) { const s = this.Wn[t.uid]; s.isBatchable || this.Hn[t.uid] && (Ut.return(this.getContextRenderData(t)), this.Hn[t.uid] = null), s.batches && s.batches.forEach(t => { Ut.return(t) }) } destroy() { for (const t in this.Wn) this.Wn[t] && this.onGraphicsContextDestroy(this.Wn[t].context); this.Wn = {}, this.Hn = {}, this.Be = null } }; Qr.extension = { type: [r.WebGLSystem, r.WebGPUSystem, r.CanvasSystem], name: "graphicsContext" }, Qr.defaultOptions = { bezierSmoothness: .5 }; let Jr = Qr; const to = 1.1920929e-7; function so(t, s, e, i, n, r, o, h, a, l) { let u = (1 - Math.min(.99, Math.max(0, l ?? Jr.defaultOptions.bezierSmoothness))) / 1; return u *= u, function (t, s, e, i, n, r, o, h, a, l) { eo(t, s, e, i, n, r, o, h, a, l, 0), a.push(o, h) }(s, e, i, n, r, o, h, a, t, u), t } function eo(t, s, e, i, n, r, o, h, a, l, u) { if (u > 8) return; const c = (t + e) / 2, f = (s + i) / 2, d = (e + n) / 2, p = (i + r) / 2, m = (n + o) / 2, g = (r + h) / 2, v = (c + d) / 2, b = (f + p) / 2, x = (d + m) / 2, y = (p + g) / 2, w = (v + x) / 2, M = (b + y) / 2; if (u > 0) { let u = o - t, c = h - s; const f = Math.abs((e - o) * c - (i - h) * u), d = Math.abs((n - o) * c - (r - h) * u); if (f > to && d > to) { if ((f + d) * (f + d) <= l * (u * u + c * c)) return void a.push(w, M) } else if (f > to) { if (f * f <= l * (u * u + c * c)) return void a.push(w, M) } else if (d > to) { if (d * d <= l * (u * u + c * c)) return void a.push(w, M) } else if (u = w - (t + o) / 2, c = M - (s + h) / 2, u * u + c * c <= l) return void a.push(w, M) } eo(t, s, c, f, v, b, w, M, a, l, u + 1), eo(w, M, x, y, m, g, o, h, a, l, u + 1) } function io(t, s, e, i, n, r, o, h) { let a = (1 - Math.min(.99, Math.max(0, h ?? Jr.defaultOptions.bezierSmoothness))) / 1; return a *= a, function (t, s, e, i, n, r, o, h) { no(o, t, s, e, i, n, r, h, 0), o.push(n, r) }(s, e, i, n, r, o, t, a), t } function no(t, s, e, i, n, r, o, h, a) { if (a > 8) return; const l = (s + i) / 2, u = (e + n) / 2, c = (i + r) / 2, f = (n + o) / 2, d = (l + c) / 2, p = (u + f) / 2; let m = r - s, g = o - e; const v = Math.abs((i - r) * g - (n - o) * m); if (v > 1.1920929e-7) { if (v * v <= h * (m * m + g * g)) return void t.push(d, p) } else if (m = d - (s + r) / 2, g = p - (e + o) / 2, m * m + g * g <= h) return void t.push(d, p); no(t, s, e, l, u, d, p, h, a + 1), no(t, d, p, c, f, r, o, h, a + 1) } function ro(t, s, e, i, n, r, o, h) { let a = Math.abs(n - r); (!o && n > r || o && r > n) && (a = 2 * Math.PI - a), h || (h = Math.max(6, Math.floor(6 * Math.pow(i, 1 / 3) * (a / Math.PI)))); let l = a / (h = Math.max(h, 3)), u = n; l *= o ? -1 : 1; for (let c = 0; c < h + 1; c++) { const n = s + Math.cos(u) * i, r = e + Math.sin(u) * i; t.push(n, r), u += l } } const oo = 2 * Math.PI, ho = { centerX: 0, centerY: 0, ang1: 0, ang2: 0 }, ao = ({ x: t, y: s }, e, i, n, r, o, h, a) => { const l = n * (t *= e) - r * (s *= i), u = r * t + n * s; return a.x = l + o, a.y = u + h, a }; function lo(t, s) { const e = -1.5707963267948966 === s ? -.551915024494 : 4 / 3 * Math.tan(s / 4), i = 1.5707963267948966 === s ? .551915024494 : e, n = Math.cos(t), r = Math.sin(t), o = Math.cos(t + s), h = Math.sin(t + s); return [{ x: n - r * i, y: r + n * i }, { x: o + h * i, y: h - o * i }, { x: o, y: h }] } const uo = (t, s, e, i) => { let n = t * e + s * i; return n > 1 && (n = 1), n < -1 && (n = -1), (t * i - s * e < 0 ? -1 : 1) * Math.acos(n) }, co = new O; class fo { constructor(t) { this.shapePrimitives = [], this.Kn = null, this.gs = new tt, this.Zn = t, this.signed = t.checkForHoles } moveTo(t, s) { return this.startPoly(t, s), this } lineTo(t, s) { this.Qn(); const e = this.Kn.points, i = e[e.length - 2], n = e[e.length - 1]; return i === t && n === s || e.push(t, s), this } arc(t, s, e, i, n, r) { return this.Qn(!1), ro(this.Kn.points, t, s, e, i, n, r), this } arcTo(t, s, e, i, n) { return this.Qn(), function (t, s, e, i, n, r) { const o = t[t.length - 2], h = t[t.length - 1] - e, a = o - s, l = n - e, u = i - s, c = Math.abs(h * u - a * l); if (c < 1e-8 || 0 === r) return void (t[t.length - 2] === s && t[t.length - 1] === e || t.push(s, e)); const f = h * h + a * a, d = l * l + u * u, p = h * l + a * u, m = r * Math.sqrt(f) / c, g = r * Math.sqrt(d) / c, v = m * p / f, b = g * p / d, x = m * u + g * a, y = m * l + g * h, w = a * (g + v), M = h * (g + v), T = u * (m + b), A = l * (m + b); ro(t, x + s, y + e, r, Math.atan2(M - y, w - x), Math.atan2(A - y, T - x), a * l > u * h) }(this.Kn.points, t, s, e, i, n), this } arcToSvg(t, s, e, i, n, r, o) { return function (t, s, e, i, n, r, o, h = 0, a = 0, l = 0) { if (0 === r || 0 === o) return; const u = Math.sin(h * oo / 360), c = Math.cos(h * oo / 360), f = c * (s - i) / 2 + u * (e - n) / 2, d = -u * (s - i) / 2 + c * (e - n) / 2; if (0 === f && 0 === d) return; r = Math.abs(r), o = Math.abs(o); const p = Math.pow(f, 2) / Math.pow(r, 2) + Math.pow(d, 2) / Math.pow(o, 2); p > 1 && (r *= Math.sqrt(p), o *= Math.sqrt(p)), ((t, s, e, i, n, r, o, h, a, l, u, c, f) => { const d = Math.pow(n, 2), p = Math.pow(r, 2), m = Math.pow(u, 2), g = Math.pow(c, 2); let v = d * p - d * g - p * m; v < 0 && (v = 0), v /= d * g + p * m, v = Math.sqrt(v) * (o === h ? -1 : 1); const b = v * n / r * c, x = v * -r / n * u, y = l * b - a * x + (t + e) / 2, w = a * b + l * x + (s + i) / 2, M = (u - b) / n, T = (c - x) / r, A = (-u - b) / n, C = (-c - x) / r, _ = uo(1, 0, M, T); let S = uo(M, T, A, C); 0 === h && S > 0 && (S -= oo), 1 === h && S < 0 && (S += oo), f.centerX = y, f.centerY = w, f.ang1 = _, f.ang2 = S })(s, e, i, n, r, o, a, l, u, c, f, d, ho); let { ang1: m, ang2: g } = ho; const { centerX: v, centerY: b } = ho; let x = Math.abs(g) / (oo / 4); Math.abs(1 - x) < 1e-7 && (x = 1); const y = Math.max(Math.ceil(x), 1); g /= y; let w = t[t.length - 2], M = t[t.length - 1]; const T = { x: 0, y: 0 }; for (let A = 0; A < y; A++) { const s = lo(m, g), { x: e, y: i } = ao(s[0], r, o, c, u, v, b, T), { x: n, y: h } = ao(s[1], r, o, c, u, v, b, T), { x: a, y: l } = ao(s[2], r, o, c, u, v, b, T); so(t, w, M, e, i, n, h, a, l), w = a, M = l, m += g } }(this.Kn.points, this.Kn.lastX, this.Kn.lastY, r, o, t, s, e, i, n), this } bezierCurveTo(t, s, e, i, n, r, o) { this.Qn(); const h = this.Kn; return so(this.Kn.points, h.lastX, h.lastY, t, s, e, i, n, r, o), this } quadraticCurveTo(t, s, e, i, n) { this.Qn(); const r = this.Kn; return io(this.Kn.points, r.lastX, r.lastY, t, s, e, i, n), this } closePath() { return this.endPoly(!0), this } addPath(t, s) { this.endPoly(), s && !s.isIdentity() && (t = t.clone(!0)).transform(s); const e = this.shapePrimitives, i = e.length; for (let n = 0; n < t.instructions.length; n++) { const s = t.instructions[n]; this[s.action](...s.data) } if (t.checkForHoles && e.length - i > 1) { let t = null; for (let s = i; s < e.length; s++) { const i = e[s]; if ("polygon" === i.shape.type) { const n = i.shape, r = t?.shape; r && r.containsPolygon(n) ? (t.holes || (t.holes = []), t.holes.push(i), e.copyWithin(s, s + 1), e.length--, s--) : t = i } } } return this } finish(t = !1) { this.endPoly(t) } rect(t, s, e, i, n) { return this.drawShape(new O(t, s, e, i), n), this } circle(t, s, e, i) { return this.drawShape(new gn(t, s, e), i), this } poly(t, s, e) { const i = new xn(t); return i.closePath = s, this.drawShape(i, e), this } regularPoly(t, s, e, i, n = 0, r) { i = Math.max(0 | i, 3); const o = -1 * Math.PI / 2 + n, h = 2 * Math.PI / i, a = []; for (let l = 0; l < i; l++) { const i = o - l * h; a.push(t + e * Math.cos(i), s + e * Math.sin(i)) } return this.poly(a, !0, r), this } roundPoly(t, s, e, i, n, r = 0, o) { if (i = Math.max(0 | i, 3), n <= 0) return this.regularPoly(t, s, e, i, r); const h = e * Math.sin(Math.PI / i) - .001; n = Math.min(n, h); const a = -1 * Math.PI / 2 + r, l = 2 * Math.PI / i, u = (i - 2) * Math.PI / i / 2; for (let c = 0; c < i; c++) { const i = c * l + a, r = t + e * Math.cos(i), h = s + e * Math.sin(i), f = i + Math.PI + u, d = i - Math.PI - u, p = r + n * Math.cos(f), m = h + n * Math.sin(f), g = r + n * Math.cos(d), v = h + n * Math.sin(d); 0 === c ? this.moveTo(p, m) : this.lineTo(p, m), this.quadraticCurveTo(r, h, g, v, o) } return this.closePath() } roundShape(t, s, e = !1, i) { return t.length < 3 ? this : (e ? function (t, s, e, i) { const n = (t, s) => Math.sqrt((t.x - s.x) ** 2 + (t.y - s.y) ** 2), r = (t, s, e) => ({ x: t.x + (s.x - t.x) * e, y: t.y + (s.y - t.y) * e }), o = s.length; for (let h = 0; h < o; h++) { const a = s[(h + 1) % o], l = a.radius ?? e; if (l <= 0) { 0 === h ? t.moveTo(a.x, a.y) : t.lineTo(a.x, a.y); continue } const u = s[h], c = s[(h + 2) % o], f = n(u, a); let d; d = f < 1e-4 ? a : r(a, u, Math.min(f / 2, l) / f); const p = n(c, a); let m; m = p < 1e-4 ? a : r(a, c, Math.min(p / 2, l) / p), 0 === h ? t.moveTo(d.x, d.y) : t.lineTo(d.x, d.y), t.quadraticCurveTo(a.x, a.y, m.x, m.y, i) } }(this, t, s, i) : function (t, s, e) { const i = (t, s) => { const e = s.x - t.x, i = s.y - t.y, n = Math.sqrt(e * e + i * i); return { len: n, nx: e / n, ny: i / n } }, n = (s, e) => { 0 === s ? t.moveTo(e.x, e.y) : t.lineTo(e.x, e.y) }; let r = s[s.length - 1]; for (let o = 0; o < s.length; o++) { const h = s[o % s.length], a = h.radius ?? e; if (a <= 0) { n(o, h), r = h; continue } const l = s[(o + 1) % s.length], u = i(h, r), c = i(h, l); if (u.len < 1e-4 || c.len < 1e-4) { n(o, h), r = h; continue } let f = Math.asin(u.nx * c.ny - u.ny * c.nx), d = 1, p = !1; u.nx * c.nx - u.ny * -c.ny < 0 ? f < 0 ? f = Math.PI + f : (f = Math.PI - f, d = -1, p = !0) : f > 0 && (d = -1, p = !0); const m = f / 2; let g, v = Math.abs(Math.cos(m) * a / Math.sin(m)); v > Math.min(u.len / 2, c.len / 2) ? (v = Math.min(u.len / 2, c.len / 2), g = Math.abs(v * Math.sin(m) / Math.cos(m))) : g = a; const b = h.x + c.nx * v + -c.ny * g * d, x = h.y + c.ny * v + c.nx * g * d, y = Math.atan2(u.ny, u.nx) + Math.PI / 2 * d, w = Math.atan2(c.ny, c.nx) - Math.PI / 2 * d; 0 === o && t.moveTo(b + Math.cos(y) * g, x + Math.sin(y) * g), t.arc(b, x, g, y, w, p), r = h } }(this, t, s), this.closePath()) } filletRect(t, s, e, i, n) { if (0 === n) return this.rect(t, s, e, i); const r = Math.min(e, i) / 2, o = Math.min(r, Math.max(-r, n)), h = t + e, a = s + i, l = o < 0 ? -o : 0, u = Math.abs(o); return this.moveTo(t, s + u).arcTo(t + l, s + l, t + u, s, u).lineTo(h - u, s).arcTo(h - l, s + l, h, s + u, u).lineTo(h, a - u).arcTo(h - l, a - l, t + e - u, a, u).lineTo(t + u, a).arcTo(t + l, a - l, t, a - u, u).closePath() } chamferRect(t, s, e, i, n, r) { if (n <= 0) return this.rect(t, s, e, i); const o = Math.min(n, Math.min(e, i) / 2), h = t + e, a = s + i, l = [t + o, s, h - o, s, h, s + o, h, a - o, h - o, a, t + o, a, t, a - o, t, s + o]; for (let u = l.length - 1; u >= 2; u -= 2)l[u] === l[u - 2] && l[u - 1] === l[u - 3] && l.splice(u - 1, 2); return this.poly(l, !0, r) } ellipse(t, s, e, i, n) { return this.drawShape(new vn(t, s, e, i), n), this } roundRect(t, s, e, i, n, r) { return this.drawShape(new wn(t, s, e, i, n), r), this } drawShape(t, s) { return this.endPoly(), this.shapePrimitives.push({ shape: t, transform: s }), this } startPoly(t, s) { let e = this.Kn; return e && this.endPoly(), e = new xn, e.points.push(t, s), this.Kn = e, this } endPoly(t = !1) { const s = this.Kn; return s && s.points.length > 2 && (s.closePath = t, this.shapePrimitives.push({ shape: s })), this.Kn = null, this } Qn(t = !0) { if (!this.Kn && (this.Kn = new xn, t)) { const t = this.shapePrimitives[this.shapePrimitives.length - 1]; if (t) { let s = t.shape.x, e = t.shape.y; if (t.transform && !t.transform.isIdentity()) { const i = t.transform, n = s; s = i.a * s + i.c * e + i.tx, e = i.b * n + i.d * e + i.ty } this.Kn.points.push(s, e) } else this.Kn.points.push(0, 0) } } buildPath() { const t = this.Zn; this.shapePrimitives.length = 0, this.Kn = null; for (let s = 0; s < t.instructions.length; s++) { const e = t.instructions[s]; this[e.action](...e.data) } this.finish() } get bounds() { const t = this.gs; t.clear(); const s = this.shapePrimitives; for (let e = 0; e < s.length; e++) { const i = s[e], n = i.shape.getBounds(co); i.transform ? t.addRect(n, i.transform) : t.addRect(n) } return t } } class po { constructor(t, s = !1) { this.instructions = [], this.uid = I("graphicsPath"), this.Ri = !0, this.checkForHoles = s, "string" == typeof t ? function (t, s) { const e = mn(t), i = []; let n = null, r = 0, o = 0; for (let h = 0; h < e.length; h++) { const t = e[h], a = t[0], l = t; switch (a) { case "M": r = l[1], o = l[2], s.moveTo(r, o); break; case "m": r += l[1], o += l[2], s.moveTo(r, o); break; case "H": r = l[1], s.lineTo(r, o); break; case "h": r += l[1], s.lineTo(r, o); break; case "V": o = l[1], s.lineTo(r, o); break; case "v": o += l[1], s.lineTo(r, o); break; case "L": r = l[1], o = l[2], s.lineTo(r, o); break; case "l": r += l[1], o += l[2], s.lineTo(r, o); break; case "C": r = l[5], o = l[6], s.bezierCurveTo(l[1], l[2], l[3], l[4], r, o); break; case "c": s.bezierCurveTo(r + l[1], o + l[2], r + l[3], o + l[4], r + l[5], o + l[6]), r += l[5], o += l[6]; break; case "S": r = l[3], o = l[4], s.bezierCurveToShort(l[1], l[2], r, o); break; case "s": s.bezierCurveToShort(r + l[1], o + l[2], r + l[3], o + l[4]), r += l[3], o += l[4]; break; case "Q": r = l[3], o = l[4], s.quadraticCurveTo(l[1], l[2], r, o); break; case "q": s.quadraticCurveTo(r + l[1], o + l[2], r + l[3], o + l[4]), r += l[3], o += l[4]; break; case "T": r = l[1], o = l[2], s.quadraticCurveToShort(r, o); break; case "t": r += l[1], o += l[2], s.quadraticCurveToShort(r, o); break; case "A": r = l[6], o = l[7], s.arcToSvg(l[1], l[2], l[3], l[4], l[5], r, o); break; case "a": r += l[6], o += l[7], s.arcToSvg(l[1], l[2], l[3], l[4], l[5], r, o); break; case "Z": case "z": s.closePath(), i.length > 0 && (n = i.pop(), n ? (r = n.startX, o = n.startY) : (r = 0, o = 0)), n = null; break; default: Et() }"Z" !== a && "z" !== a && null === n && (n = { startX: r, startY: o }, i.push(n)) } }(t, this) : this.instructions = t?.slice() ?? [] } get shapePath() { return this.Jn || (this.Jn = new fo(this)), this.Ri && (this.Ri = !1, this.Jn.buildPath()), this.Jn } addPath(t, s) { return t = t.clone(), this.instructions.push({ action: "addPath", data: [t, s] }), this.Ri = !0, this } arc(...t) { return this.instructions.push({ action: "arc", data: t }), this.Ri = !0, this } arcTo(...t) { return this.instructions.push({ action: "arcTo", data: t }), this.Ri = !0, this } arcToSvg(...t) { return this.instructions.push({ action: "arcToSvg", data: t }), this.Ri = !0, this } bezierCurveTo(...t) { return this.instructions.push({ action: "bezierCurveTo", data: t }), this.Ri = !0, this } bezierCurveToShort(t, s, e, i, n) { const r = this.instructions[this.instructions.length - 1], o = this.getLastPoint(x.shared); let h = 0, a = 0; if (r && "bezierCurveTo" === r.action) { h = r.data[2], a = r.data[3]; const t = o.x, s = o.y; h = t + (t - h), a = s + (s - a) } else h = o.x, a = o.y; return this.instructions.push({ action: "bezierCurveTo", data: [h, a, t, s, e, i, n] }), this.Ri = !0, this } closePath() { return this.instructions.push({ action: "closePath", data: [] }), this.Ri = !0, this } ellipse(...t) { return this.instructions.push({ action: "ellipse", data: t }), this.Ri = !0, this } lineTo(...t) { return this.instructions.push({ action: "lineTo", data: t }), this.Ri = !0, this } moveTo(...t) { return this.instructions.push({ action: "moveTo", data: t }), this } quadraticCurveTo(...t) { return this.instructions.push({ action: "quadraticCurveTo", data: t }), this.Ri = !0, this } quadraticCurveToShort(t, s, e) { const i = this.instructions[this.instructions.length - 1], n = this.getLastPoint(x.shared); let r = 0, o = 0; if (i && "quadraticCurveTo" === i.action) { r = i.data[0], o = i.data[1]; const t = n.x, s = n.y; r = t + (t - r), o = s + (s - o) } else r = n.x, o = n.y; return this.instructions.push({ action: "quadraticCurveTo", data: [r, o, t, s, e] }), this.Ri = !0, this } rect(t, s, e, i, n) { return this.instructions.push({ action: "rect", data: [t, s, e, i, n] }), this.Ri = !0, this } circle(t, s, e, i) { return this.instructions.push({ action: "circle", data: [t, s, e, i] }), this.Ri = !0, this } roundRect(...t) { return this.instructions.push({ action: "roundRect", data: t }), this.Ri = !0, this } poly(...t) { return this.instructions.push({ action: "poly", data: t }), this.Ri = !0, this } regularPoly(...t) { return this.instructions.push({ action: "regularPoly", data: t }), this.Ri = !0, this } roundPoly(...t) { return this.instructions.push({ action: "roundPoly", data: t }), this.Ri = !0, this } roundShape(...t) { return this.instructions.push({ action: "roundShape", data: t }), this.Ri = !0, this } filletRect(...t) { return this.instructions.push({ action: "filletRect", data: t }), this.Ri = !0, this } chamferRect(...t) { return this.instructions.push({ action: "chamferRect", data: t }), this.Ri = !0, this } star(t, s, e, i, n, r, o) { n || (n = i / 2); const h = -1 * Math.PI / 2 + r, a = 2 * e, l = 2 * Math.PI / a, u = []; for (let c = 0; c < a; c++) { const e = c % 2 ? n : i, r = c * l + h; u.push(t + e * Math.cos(r), s + e * Math.sin(r)) } return this.poly(u, !0, o), this } clone(t = !1) { const s = new po; if (s.checkForHoles = this.checkForHoles, t) for (let e = 0; e < this.instructions.length; e++) { const t = this.instructions[e]; s.instructions.push({ action: t.action, data: t.data.slice() }) } else s.instructions = this.instructions.slice(); return s } clear() { return this.instructions.length = 0, this.Ri = !0, this } transform(t) { if (t.isIdentity()) return this; const s = t.a, e = t.b, i = t.c, n = t.d, r = t.tx, o = t.ty; let h = 0, a = 0, l = 0, u = 0, c = 0, f = 0, d = 0, p = 0; for (let m = 0; m < this.instructions.length; m++) { const g = this.instructions[m], v = g.data; switch (g.action) { case "moveTo": case "lineTo": h = v[0], a = v[1], v[0] = s * h + i * a + r, v[1] = e * h + n * a + o; break; case "bezierCurveTo": l = v[0], u = v[1], c = v[2], f = v[3], h = v[4], a = v[5], v[0] = s * l + i * u + r, v[1] = e * l + n * u + o, v[2] = s * c + i * f + r, v[3] = e * c + n * f + o, v[4] = s * h + i * a + r, v[5] = e * h + n * a + o; break; case "quadraticCurveTo": l = v[0], u = v[1], h = v[2], a = v[3], v[0] = s * l + i * u + r, v[1] = e * l + n * u + o, v[2] = s * h + i * a + r, v[3] = e * h + n * a + o; break; case "arcToSvg": h = v[5], a = v[6], d = v[0], p = v[1], v[0] = s * d + i * p, v[1] = e * d + n * p, v[5] = s * h + i * a + r, v[6] = e * h + n * a + o; break; case "circle": v[4] = mo(v[3], t); break; case "rect": v[4] = mo(v[4], t); break; case "ellipse": v[8] = mo(v[8], t); break; case "roundRect": v[5] = mo(v[5], t); break; case "addPath": v[0].transform(t); break; case "poly": v[2] = mo(v[2], t); break; default: Et(g.action) } } return this.Ri = !0, this } get bounds() { return this.shapePath.bounds } getLastPoint(t) { let s = this.instructions.length - 1, e = this.instructions[s]; if (!e) return t.x = 0, t.y = 0, t; for (; "closePath" === e.action;) { if (s--, s < 0) return t.x = 0, t.y = 0, t; e = this.instructions[s] } switch (e.action) { case "moveTo": case "lineTo": t.x = e.data[0], t.y = e.data[1]; break; case "quadraticCurveTo": t.x = e.data[2], t.y = e.data[3]; break; case "bezierCurveTo": t.x = e.data[4], t.y = e.data[5]; break; case "arc": case "arcToSvg": t.x = e.data[5], t.y = e.data[6]; break; case "addPath": e.data[0].getLastPoint(t) }return t } } function mo(t, s) { return t ? t.prepend(s) : s.clone() } function go(t, s, e) { const i = t.getAttribute(s); return i ? Number(i) : e } function vo(t) { const s = go(t, "x1", 0), e = go(t, "y1", 0), i = go(t, "x2", 1), n = go(t, "y2", 0), r = t.getAttribute("gradientUnits") || "objectBoundingBox", o = new an(s, e, i, n, "objectBoundingBox" === r ? "local" : "global"); for (let h = 0; h < t.children.length; h++) { const s = t.children[h], e = go(s, "offset", 0), i = kt.shared.setValue(s.getAttribute("stop-color")).toNumber(); o.addColorStop(e, i) } return o } function bo(t) { return Et(), new an(0, 0, 1, 0) } function xo(t) { const s = t.match(/url\s*\(\s*['"]?\s*#([^'"\s)]+)\s*['"]?\s*\)/i); return s ? s[1] : "" } const yo = { fill: { type: "paint", default: 0 }, "fill-opacity": { type: "number", default: 1 }, stroke: { type: "paint", default: 0 }, "stroke-width": { type: "number", default: 1 }, "stroke-opacity": { type: "number", default: 1 }, "stroke-linecap": { type: "string", default: "butt" }, "stroke-linejoin": { type: "string", default: "miter" }, "stroke-miterlimit": { type: "number", default: 10 }, "stroke-dasharray": { type: "string", default: "none" }, "stroke-dashoffset": { type: "number", default: 0 }, opacity: { type: "number", default: 1 } }; function wo(t, s) { const e = t.getAttribute("style"), i = {}, n = {}, r = { strokeStyle: i, fillStyle: n, useFill: !1, useStroke: !1 }; for (const o in yo) { const e = t.getAttribute(o); e && Mo(s, r, o, e.trim()) } if (e) { const t = e.split(";"); for (let e = 0; e < t.length; e++) { const i = t[e].trim(), [n, o] = i.split(":"); yo[n] && Mo(s, r, n, o.trim()) } } return { strokeStyle: r.useStroke ? i : null, fillStyle: r.useFill ? n : null, useFill: r.useFill, useStroke: r.useStroke } } function Mo(t, s, e, i) { switch (e) { case "stroke": if ("none" !== i) { if (i.startsWith("url(")) { const e = xo(i); s.strokeStyle.fill = t.defs[e] } else s.strokeStyle.color = kt.shared.setValue(i).toNumber(); s.useStroke = !0 } break; case "stroke-width": s.strokeStyle.width = Number(i); break; case "fill": if ("none" !== i) { if (i.startsWith("url(")) { const e = xo(i); s.fillStyle.fill = t.defs[e] } else s.fillStyle.color = kt.shared.setValue(i).toNumber(); s.useFill = !0 } break; case "fill-opacity": s.fillStyle.alpha = Number(i); break; case "stroke-opacity": s.strokeStyle.alpha = Number(i); break; case "opacity": s.fillStyle.alpha = Number(i), s.strokeStyle.alpha = Number(i) } } function To(t) { const s = t.match(/[-+]?[0-9]*\.?[0-9]+/g); if (!s || s.length < 4) return 0; const e = s.map(Number), i = [], n = []; for (let a = 0; a < e.length; a += 2)a + 1 < e.length && (i.push(e[a]), n.push(e[a + 1])); if (0 === i.length || 0 === n.length) return 0; const r = Math.min(...i), o = Math.max(...i), h = Math.min(...n); return (o - r) * (Math.max(...n) - h) } function Ao(t, s) { const e = new po(t, !1); for (const i of e.instructions) s.instructions.push(i) } function Co(t, s, e, i) { const n = t.children, { fillStyle: r, strokeStyle: o } = wo(t, s); r && e ? e = { ...e, ...r } : r && (e = r), o && i ? i = { ...i, ...o } : o && (i = o); const h = !e && !i; let a, l, u, c, f, d, p, m, g, v, b, x, y, w, M, T, A; switch (h && (e = { color: 0 }), t.nodeName.toLowerCase()) { case "path": { w = t.getAttribute("d"); const n = t.getAttribute("fill-rule"), r = w.split(/(?=[Mm])/).filter(t => t.trim().length > 0), o = "evenodd" === n, h = r.length > 1; if (o && h) { const t = r.map(t => ({ path: t, area: To(t) })); t.sort((t, s) => s.area - t.area); const n = r.length > 3 || !function (t) { if (t.length <= 2) return !0; const s = t.map(t => t.area).sort((t, s) => s - t), [e, i] = s, n = s[s.length - 1]; return !(e / i > 3 && i / n < 2) }(t); if (n) for (let r = 0; r < t.length; r++) { const n = t[r], o = 0 === r; s.context.beginPath(); const h = new po(void 0, !0); Ao(n.path, h), s.context.path(h), o ? (e && s.context.fill(e), i && s.context.stroke(i)) : s.context.cut() } else for (let r = 0; r < t.length; r++) { const n = t[r], o = r % 2 == 1; s.context.beginPath(); const h = new po(void 0, !0); Ao(n.path, h), s.context.path(h), o ? s.context.cut() : (e && s.context.fill(e), i && s.context.stroke(i)) } } else M = new po(w, !n || "evenodd" === n), s.context.path(M), e && s.context.fill(e), i && s.context.stroke(i); break } case "circle": p = go(t, "cx", 0), m = go(t, "cy", 0), g = go(t, "r", 0), s.context.ellipse(p, m, g, g), e && s.context.fill(e), i && s.context.stroke(i); break; case "rect": a = go(t, "x", 0), l = go(t, "y", 0), T = go(t, "width", 0), A = go(t, "height", 0), v = go(t, "rx", 0), b = go(t, "ry", 0), v || b ? s.context.roundRect(a, l, T, A, v || b) : s.context.rect(a, l, T, A), e && s.context.fill(e), i && s.context.stroke(i); break; case "ellipse": p = go(t, "cx", 0), m = go(t, "cy", 0), v = go(t, "rx", 0), b = go(t, "ry", 0), s.context.beginPath(), s.context.ellipse(p, m, v, b), e && s.context.fill(e), i && s.context.stroke(i); break; case "line": u = go(t, "x1", 0), c = go(t, "y1", 0), f = go(t, "x2", 0), d = go(t, "y2", 0), s.context.beginPath(), s.context.moveTo(u, c), s.context.lineTo(f, d), i && s.context.stroke(i); break; case "polygon": y = t.getAttribute("points"), x = y.match(/\d+/g).map(t => parseInt(t, 10)), s.context.poly(x, !0), e && s.context.fill(e), i && s.context.stroke(i); break; case "polyline": y = t.getAttribute("points"), x = y.match(/\d+/g).map(t => parseInt(t, 10)), s.context.poly(x, !1), i && s.context.stroke(i); break; case "g": case "svg": break; default: Et(t.nodeName) }h && (e = null); for (let C = 0; C < n.length; C++)Co(n[C], s, e, i) } function _o(t) { return t instanceof fn } function So(t) { return t instanceof an } function Po(t, s, e) { return t.fill = s, t.color = 16777215, t.texture = s.texture, t.matrix = s.transform, { ...e, ...t } } function ko(t, s, e) { return s.buildGradient(), t.fill = s, t.color = 16777215, t.texture = s.texture, t.matrix = s.transform, t.textureSpace = s.textureSpace, { ...e, ...t } } function Fo(t, s) { if (null == t) return null; const e = {}, i = t; return function (t) { return kt.isColorLike(t) }(t) ? function (t, s, e) { const i = kt.shared.setValue(s ?? 0); return t.color = i.toNumber(), t.alpha = 1 === i.alpha ? e.alpha : i.alpha, t.texture = Z.WHITE, { ...e, ...t } }(e, t, s) : function (t) { return t instanceof Z }(t) ? function (t, s, e) { return t.texture = s, { ...e, ...t } }(e, t, s) : _o(t) ? Po(e, t, s) : So(t) ? ko(e, t, s) : i.fill && _o(i.fill) ? Po(i, i.fill, s) : i.fill && So(i.fill) ? ko(i, i.fill, s) : function (t, s) { const e = { ...s, ...t }, i = kt.shared.setValue(e.color); return e.alpha *= i.alpha, e.color = i.toNumber(), e }(i, s) } function Eo(t, s) { const { width: e, alignment: i, miterLimit: n, cap: r, join: o, pixelLine: h, ...a } = s, l = Fo(t, a); return l ? { width: e, alignment: i, miterLimit: n, cap: r, join: o, pixelLine: h, ...l } : null } const Ro = new x, Oo = new w, Uo = class t extends m { constructor() { super(...arguments), this.uid = I("graphicsContext"), this.dirty = !0, this.batchMode = "auto", this.instructions = [], this.tr = new po, this.sr = new w, this.er = { ...t.defaultFillStyle }, this.ir = { ...t.defaultStrokeStyle }, this.nr = [], this.Os = 0, this.gs = new tt, this.vs = !0 } clone() { const s = new t; return s.batchMode = this.batchMode, s.instructions = this.instructions.slice(), s.tr = this.tr.clone(), s.sr = this.sr.clone(), s.er = { ...this.er }, s.ir = { ...this.ir }, s.nr = this.nr.slice(), s.gs = this.gs.clone(), s.vs = !0, s } get fillStyle() { return this.er } set fillStyle(s) { this.er = Fo(s, t.defaultFillStyle) } get strokeStyle() { return this.ir } set strokeStyle(s) { this.ir = Eo(s, t.defaultStrokeStyle) } setFillStyle(s) { return this.er = Fo(s, t.defaultFillStyle), this } setStrokeStyle(s) { return this.ir = Fo(s, t.defaultStrokeStyle), this } texture(t, s, e, i, n, r) { return this.instructions.push({ action: "texture", data: { image: t, dx: e || 0, dy: i || 0, dw: n || t.frame.width, dh: r || t.frame.height, transform: this.sr.clone(), alpha: this.er.alpha, style: s ? kt.shared.setValue(s).toNumber() : 16777215 } }), this.onUpdate(), this } beginPath() { return this.tr = new po, this } fill(s, e) { let i; const n = this.instructions[this.instructions.length - 1]; return i = 0 === this.Os && "stroke" === n?.action ? n.data.path : this.tr.clone(), i ? (null != s && (void 0 !== e && "number" == typeof s && (G(0, "GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead"), s = { color: s, alpha: e }), this.er = Fo(s, t.defaultFillStyle)), this.instructions.push({ action: "fill", data: { style: this.fillStyle, path: i } }), this.onUpdate(), this.rr(), this.Os = 0, this) : this } rr() { const { x: t, y: s } = this.tr.getLastPoint(x.shared); this.tr.clear(), this.tr.moveTo(t, s) } stroke(s) { let e; const i = this.instructions[this.instructions.length - 1]; return e = 0 === this.Os && "fill" === i?.action ? i.data.path : this.tr.clone(), e ? (null != s && (this.ir = Eo(s, t.defaultStrokeStyle)), this.instructions.push({ action: "stroke", data: { style: this.strokeStyle, path: e } }), this.onUpdate(), this.rr(), this.Os = 0, this) : this } cut() { for (let t = 0; t < 2; t++) { const s = this.instructions[this.instructions.length - 1 - t], e = this.tr.clone(); if (s && ("stroke" === s.action || "fill" === s.action)) { if (!s.data.hole) { s.data.hole = e; break } s.data.hole.addPath(e) } } return this.rr(), this } arc(t, s, e, i, n, r) { this.Os++; const o = this.sr; return this.tr.arc(o.a * t + o.c * s + o.tx, o.b * t + o.d * s + o.ty, e, i, n, r), this } arcTo(t, s, e, i, n) { this.Os++; const r = this.sr; return this.tr.arcTo(r.a * t + r.c * s + r.tx, r.b * t + r.d * s + r.ty, r.a * e + r.c * i + r.tx, r.b * e + r.d * i + r.ty, n), this } arcToSvg(t, s, e, i, n, r, o) { this.Os++; const h = this.sr; return this.tr.arcToSvg(t, s, e, i, n, h.a * r + h.c * o + h.tx, h.b * r + h.d * o + h.ty), this } bezierCurveTo(t, s, e, i, n, r, o) { this.Os++; const h = this.sr; return this.tr.bezierCurveTo(h.a * t + h.c * s + h.tx, h.b * t + h.d * s + h.ty, h.a * e + h.c * i + h.tx, h.b * e + h.d * i + h.ty, h.a * n + h.c * r + h.tx, h.b * n + h.d * r + h.ty, o), this } closePath() { return this.Os++, this.tr?.closePath(), this } ellipse(t, s, e, i) { return this.Os++, this.tr.ellipse(t, s, e, i, this.sr.clone()), this } circle(t, s, e) { return this.Os++, this.tr.circle(t, s, e, this.sr.clone()), this } path(t) { return this.Os++, this.tr.addPath(t, this.sr.clone()), this } lineTo(t, s) { this.Os++; const e = this.sr; return this.tr.lineTo(e.a * t + e.c * s + e.tx, e.b * t + e.d * s + e.ty), this } moveTo(t, s) { this.Os++; const e = this.sr, i = this.tr.instructions, n = e.a * t + e.c * s + e.tx, r = e.b * t + e.d * s + e.ty; return 1 === i.length && "moveTo" === i[0].action ? (i[0].data[0] = n, i[0].data[1] = r, this) : (this.tr.moveTo(n, r), this) } quadraticCurveTo(t, s, e, i, n) { this.Os++; const r = this.sr; return this.tr.quadraticCurveTo(r.a * t + r.c * s + r.tx, r.b * t + r.d * s + r.ty, r.a * e + r.c * i + r.tx, r.b * e + r.d * i + r.ty, n), this } rect(t, s, e, i) { return this.Os++, this.tr.rect(t, s, e, i, this.sr.clone()), this } roundRect(t, s, e, i, n) { return this.Os++, this.tr.roundRect(t, s, e, i, n, this.sr.clone()), this } poly(t, s) { return this.Os++, this.tr.poly(t, s, this.sr.clone()), this } regularPoly(t, s, e, i, n = 0, r) { return this.Os++, this.tr.regularPoly(t, s, e, i, n, r), this } roundPoly(t, s, e, i, n, r) { return this.Os++, this.tr.roundPoly(t, s, e, i, n, r), this } roundShape(t, s, e, i) { return this.Os++, this.tr.roundShape(t, s, e, i), this } filletRect(t, s, e, i, n) { return this.Os++, this.tr.filletRect(t, s, e, i, n), this } chamferRect(t, s, e, i, n, r) { return this.Os++, this.tr.chamferRect(t, s, e, i, n, r), this } star(t, s, e, i, n = 0, r = 0) { return this.Os++, this.tr.star(t, s, e, i, n, r, this.sr.clone()), this } svg(t) { return this.Os++, function (t, s) { if ("string" == typeof t) { const s = document.createElement("div"); s.innerHTML = t.trim(), t = s.querySelector("svg") } const e = { context: s, defs: {}, path: new po }; !function (t, s) { const e = t.querySelectorAll("defs"); for (let i = 0; i < e.length; i++) { const t = e[i]; for (let e = 0; e < t.children.length; e++) { const i = t.children[e]; switch (i.nodeName.toLowerCase()) { case "lineargradient": s.defs[i.id] = vo(i); break; case "radialgradient": s.defs[i.id] = bo() } } } }(t, e); const i = t.children, { fillStyle: n, strokeStyle: r } = wo(t, e); for (let o = 0; o < i.length; o++) { const t = i[o]; "defs" !== t.nodeName.toLowerCase() && Co(t, e, n, r) } }(t, this), this } restore() { const t = this.nr.pop(); return t && (this.sr = t.transform, this.er = t.fillStyle, this.ir = t.strokeStyle), this } save() { return this.nr.push({ transform: this.sr.clone(), fillStyle: { ...this.er }, strokeStyle: { ...this.ir } }), this } getTransform() { return this.sr } resetTransform() { return this.sr.identity(), this } rotate(t) { return this.sr.rotate(t), this } scale(t, s = t) { return this.sr.scale(t, s), this } setTransform(t, s, e, i, n, r) { return t instanceof w ? (this.sr.set(t.a, t.b, t.c, t.d, t.tx, t.ty), this) : (this.sr.set(t, s, e, i, n, r), this) } transform(t, s, e, i, n, r) { return t instanceof w ? (this.sr.append(t), this) : (Oo.set(t, s, e, i, n, r), this.sr.append(Oo), this) } translate(t, s = t) { return this.sr.translate(t, s), this } clear() { return this.tr.clear(), this.instructions.length = 0, this.resetTransform(), this.onUpdate(), this } onUpdate() { this.vs = !0, this.dirty || (this.emit("update", this, 16), this.dirty = !0) } get bounds() { if (!this.vs) return this.gs; this.vs = !1; const t = this.gs; t.clear(); for (let s = 0; s < this.instructions.length; s++) { const e = this.instructions[s], i = e.action; if ("fill" === i) { const s = e.data; t.addBounds(s.path.bounds) } else if ("texture" === i) { const s = e.data; t.addFrame(s.dx, s.dy, s.dx + s.dw, s.dy + s.dh, s.transform) } if ("stroke" === i) { const s = e.data, i = s.style.alignment, n = s.style.width * (1 - i), r = s.path.bounds; t.addFrame(r.minX - n, r.minY - n, r.maxX + n, r.maxY + n) } } return t } containsPoint(t) { if (!this.bounds.containsPoint(t.x, t.y)) return !1; const s = this.instructions; let e = !1; for (let i = 0; i < s.length; i++) { const n = s[i], r = n.data, o = r.path; if (!n.action || !o) continue; const h = r.style, a = o.shapePath.shapePrimitives; for (let s = 0; s < a.length; s++) { const i = a[s].shape; if (!h || !i) continue; const o = a[s].transform, l = o ? o.applyInverse(t, Ro) : t; if ("fill" === n.action) e = i.contains(l.x, l.y); else { const t = h; e = i.strokeContains(l.x, l.y, t.width, t.alignment) } const u = r.hole; if (u) { const t = u.shapePath?.shapePrimitives; if (t) for (let s = 0; s < t.length; s++)t[s].shape.contains(l.x, l.y) && (e = !1) } if (e) return !0 } } return e } destroy(t = !1) { if (this.nr.length = 0, this.sr = null, this.emit("destroy", this), this.removeAllListeners(), "boolean" == typeof t ? t : t?.texture) { const s = "boolean" == typeof t ? t : t?.textureSource; this.er.texture && (this.er.fill && "uid" in this.er.fill ? this.er.fill.destroy() : this.er.texture.destroy(s)), this.ir.texture && (this.ir.fill && "uid" in this.ir.fill ? this.ir.fill.destroy() : this.ir.texture.destroy(s)) } this.er = null, this.ir = null, this.instructions = null, this.tr = null, this.gs = null, this.nr = null, this.customShader = null, this.sr = null } }; Uo.defaultFillStyle = { color: 16777215, alpha: 1, texture: Z.WHITE, matrix: null, fill: null, textureSpace: "local" }, Uo.defaultStrokeStyle = { width: 1, color: 16777215, alpha: 1, alignment: .5, miterLimit: 10, cap: "butt", join: "miter", texture: Z.WHITE, matrix: null, fill: null, textureSpace: "local", pixelLine: !1 }; let Io = Uo; const Bo = class t extends m { constructor(s = {}) { super(), this.uid = I("textStyle"), this.Os = 0, function (t) { const s = t; if ("boolean" == typeof s.dropShadow && s.dropShadow) { const e = $o.defaultDropShadow; t.dropShadow = { alpha: s.dropShadowAlpha ?? e.alpha, angle: s.dropShadowAngle ?? e.angle, blur: s.dropShadowBlur ?? e.blur, color: s.dropShadowColor ?? e.color, distance: s.dropShadowDistance ?? e.distance } } if (void 0 !== s.strokeThickness) { G(0, "strokeThickness is now a part of stroke"); const e = s.stroke; let i = {}; if (kt.isColorLike(e)) i.color = e; else if (e instanceof an || e instanceof fn) i.fill = e; else { if (!Object.hasOwnProperty.call(e, "color") && !Object.hasOwnProperty.call(e, "fill")) throw new Error("Invalid stroke value."); i = e } t.stroke = { ...i, width: s.strokeThickness } } if (Array.isArray(s.fillGradientStops)) { if (G(0, "gradient fill is now a fill pattern: `new FillGradient(...)`"), !Array.isArray(s.fill) || 0 === s.fill.length) throw new Error("Invalid fill value. Expected an array of colors for gradient fill."); s.fill.length !== s.fillGradientStops.length && Et(); const e = new an({ start: { x: 0, y: 0 }, end: { x: 0, y: 1 }, textureSpace: "local" }), i = s.fillGradientStops.slice(), n = s.fill.map(t => kt.shared.setValue(t).toNumber()); i.forEach((t, s) => { e.addColorStop(t, n[s]) }), t.fill = { fill: e } } }(s); const e = { ...t.defaultTextStyle, ...s }; for (const t in e) this[t] = e[t]; this.update(), this.Os = 0 } get align() { return this.hr } set align(t) { this.hr !== t && (this.hr = t, this.update()) } get breakWords() { return this.ar } set breakWords(t) { this.ar !== t && (this.ar = t, this.update()) } get dropShadow() { return this.lr } set dropShadow(s) { this.lr !== s && (this.lr = null !== s && "object" == typeof s ? this.ur({ ...t.defaultDropShadow, ...s }) : s ? this.ur({ ...t.defaultDropShadow }) : null, this.update()) } get fontFamily() { return this.cr } set fontFamily(t) { this.cr !== t && (this.cr = t, this.update()) } get fontSize() { return this.dr } set fontSize(t) { this.dr !== t && (this.dr = "string" == typeof t ? parseInt(t, 10) : t, this.update()) } get fontStyle() { return this.pr } set fontStyle(t) { this.pr !== t && (this.pr = t.toLowerCase(), this.update()) } get fontVariant() { return this.mr } set fontVariant(t) { this.mr !== t && (this.mr = t, this.update()) } get fontWeight() { return this.gr } set fontWeight(t) { this.gr !== t && (this.gr = t, this.update()) } get leading() { return this.vr } set leading(t) { this.vr !== t && (this.vr = t, this.update()) } get letterSpacing() { return this.br } set letterSpacing(t) { this.br !== t && (this.br = t, this.update()) } get lineHeight() { return this.yr } set lineHeight(t) { this.yr !== t && (this.yr = t, this.update()) } get padding() { return this.wr } set padding(t) { this.wr !== t && (this.wr = t, this.update()) } get filters() { return this.Mr } set filters(t) { this.Mr !== t && (this.Mr = Object.freeze(t), this.update()) } get trim() { return this.Tr } set trim(t) { this.Tr !== t && (this.Tr = t, this.update()) } get textBaseline() { return this.Ar } set textBaseline(t) { this.Ar !== t && (this.Ar = t, this.update()) } get whiteSpace() { return this.Cr } set whiteSpace(t) { this.Cr !== t && (this.Cr = t, this.update()) } get wordWrap() { return this.hn } set wordWrap(t) { this.hn !== t && (this.hn = t, this.update()) } get wordWrapWidth() { return this._r } set wordWrapWidth(t) { this._r !== t && (this._r = t, this.update()) } get fill() { return this.Sr } set fill(t) { t !== this.Sr && (this.Sr = t, this.Pr(t) && (this.Sr = this.ur({ ...Io.defaultFillStyle, ...t }, () => { this.kr = Fo({ ...this.Sr }, Io.defaultFillStyle) })), this.kr = Fo(0 === t ? "black" : t, Io.defaultFillStyle), this.update()) } get stroke() { return this.Fr } set stroke(t) { t !== this.Fr && (this.Fr = t, this.Pr(t) && (this.Fr = this.ur({ ...Io.defaultStrokeStyle, ...t }, () => { this.ln = Eo({ ...this.Fr }, Io.defaultStrokeStyle) })), this.ln = Eo(t, Io.defaultStrokeStyle), this.update()) } update() { this.Os++, this.emit("update", this) } reset() { const s = t.defaultTextStyle; for (const t in s) this[t] = s[t] } get styleKey() { return `${this.uid}-${this.Os}` } clone() { return new t({ align: this.align, breakWords: this.breakWords, dropShadow: this.lr ? { ...this.lr } : null, fill: this.kr, fontFamily: this.fontFamily, fontSize: this.fontSize, fontStyle: this.fontStyle, fontVariant: this.fontVariant, fontWeight: this.fontWeight, leading: this.leading, letterSpacing: this.letterSpacing, lineHeight: this.lineHeight, padding: this.padding, stroke: this.ln, textBaseline: this.textBaseline, whiteSpace: this.whiteSpace, wordWrap: this.wordWrap, wordWrapWidth: this.wordWrapWidth, filters: this.Mr ? [...this.Mr] : void 0 }) } Er() { let t = 0; if (this.Mr) for (let s = 0; s < this.Mr.length; s++)t += this.Mr[s].padding; return Math.max(this.wr, t) } destroy(t = !1) { if (this.removeAllListeners(), "boolean" == typeof t ? t : t?.texture) { const s = "boolean" == typeof t ? t : t?.textureSource; this.kr?.texture && this.kr.texture.destroy(s), this.Sr?.texture && this.Sr.texture.destroy(s), this.ln?.texture && this.ln.texture.destroy(s), this.Fr?.texture && this.Fr.texture.destroy(s) } this.kr = null, this.ln = null, this.dropShadow = null, this.Fr = null, this.Sr = null } ur(t, s) { return new Proxy(t, { set: (t, e, i) => (t[e] === i || (t[e] = i, s?.(e, i), this.update()), !0) }) } Pr(t) { return null !== (t ?? null) && !(kt.isColorLike(t) || t instanceof an || t instanceof fn) } }; Bo.defaultDropShadow = { alpha: 1, angle: Math.PI / 6, blur: 0, color: "black", distance: 5 }, Bo.defaultTextStyle = { align: "left", breakWords: !1, dropShadow: null, fill: "black", fontFamily: "Arial", fontSize: 26, fontStyle: "normal", fontVariant: "normal", fontWeight: "normal", leading: 0, letterSpacing: 0, lineHeight: 0, padding: 0, stroke: null, textBaseline: "alphabetic", trim: !1, whiteSpace: "pre", wordWrap: !1, wordWrapWidth: 100 }; let $o = Bo; const Go = new class { constructor(t) { this.Rr = Object.create(null), this.canvasOptions = t || {}, this.enableFullScreen = !1 } Or(t, s) { const e = ks.get().createCanvas(); e.width = t, e.height = s; const i = e.getContext("2d"); return { canvas: e, context: i } } getOptimalCanvasAndContext(t, s, e = 1) { t = Math.ceil(t * e - 1e-6), s = Math.ceil(s * e - 1e-6); const i = ((t = D(t)) << 17) + ((s = D(s)) << 1); this.Rr[i] || (this.Rr[i] = []); let n = this.Rr[i].pop(); return n || (n = this.Or(t, s)), n } returnCanvasAndContext(t) { const s = t.canvas, { width: e, height: i } = s, n = (e << 17) + (i << 1); t.context.resetTransform(), t.context.clearRect(0, 0, e, i), this.Rr[n].push(t) } clear() { this.Rr = {} } }; Rt.register(Go); const zo = 1e5; function Do(t, s, e, i = 0) { if (t.texture === Z.WHITE && !t.fill) return kt.shared.setValue(t.color).setAlpha(t.alpha ?? 1).toHexa(); if (!t.fill) { const e = s.createPattern(t.texture.source.resource, "repeat"), i = t.matrix.copyTo(w.shared); return i.scale(t.texture.frame.width, t.texture.frame.height), e.setTransform(i), e } if (t.fill instanceof fn) { const e = t.fill, i = s.createPattern(e.texture.source.resource, "repeat"), n = e.transform.copyTo(w.shared); return n.scale(e.texture.frame.width, e.texture.frame.height), i.setTransform(n), i } if (t.fill instanceof an) { const n = t.fill, r = "linear" === n.type, o = "local" === n.textureSpace; let h, a = 1, l = 1; o && e && (a = e.width + i, l = e.height + i); let u = !1; if (r) { const { start: t, end: e } = n; h = s.createLinearGradient(t.x * a, t.y * l, e.x * a, e.y * l), u = Math.abs(e.x - t.x) < Math.abs(.1 * (e.y - t.y)) } else { const { center: t, innerRadius: e, outerCenter: i, outerRadius: r } = n; h = s.createRadialGradient(t.x * a, t.y * l, e * a, i.x * a, i.y * l, r * a) } if (u && o && e) { const t = e.lineHeight / l; for (let s = 0; s < e.lines.length; s++) { const r = (s * e.lineHeight + i / 2) / l; n.colorStops.forEach(s => { const e = r + s.offset * t; h.addColorStop(Math.floor(e * zo) / zo, kt.shared.setValue(s.color).toHex()) }) } } else n.colorStops.forEach(t => { h.addColorStop(t.offset, kt.shared.setValue(t.color).toHex()) }); return h } return Et(), "red" } const jo = class t extends Zi { constructor(s) { super(), this.resolution = 1, this.pages = [], this.wr = 0, this.Ur = Object.create(null), this.Ir = [], this.Br = 0, this.$r = 0, this.Gr = 0, this.zr = -1, this.Dr = !1; const e = { ...t.defaultOptions, ...s }; this.Mn = e.textureSize, this.jr = e.mipmap; const i = e.style.clone(); e.overrideFill && (i.kr.color = 16777215, i.kr.alpha = 1, i.kr.texture = Z.WHITE, i.kr.fill = null), this.applyFillAsTint = e.overrideFill; const n = i.fontSize; i.fontSize = this.baseMeasurementFontSize; const r = sn(i); e.overrideSize ? i.ln && (i.ln.width *= this.baseRenderedFontSize / n) : i.fontSize = this.baseRenderedFontSize = n, this.L = i, this.Dr = e.skipKerning ?? !1, this.resolution = e.resolution ?? 1, this.wr = e.padding ?? 4, e.textureStyle && (this.Lr = e.textureStyle instanceof W ? e.textureStyle : new W(e.textureStyle)), this.fontMetrics = rn.measureFont(r), this.lineHeight = i.lineHeight || this.fontMetrics.fontSize || i.fontSize } ensureCharacters(t) { const s = rn.graphemeSegmenter(t).filter(t => !this.Ir.includes(t)).filter((t, s, e) => e.indexOf(t) === s); if (!s.length) return; let e; this.Ir = [...this.Ir, ...s], e = -1 === this.zr ? this.Vr() : this.pages[this.zr]; let { canvas: i, context: n } = e.canvasAndContext, r = e.texture.source; const o = this.L; let h = this.Br, a = this.$r, l = this.Gr; const u = this.baseRenderedFontSize / this.baseMeasurementFontSize, c = this.wr * u; let f = !1; const d = i.width / this.resolution, p = i.height / this.resolution; for (let m = 0; m < s.length; m++) { const t = s[m], e = rn.measureText(t, o, i, !1); e.lineHeight = e.height; const g = e.width * u, v = Math.ceil(("italic" === o.fontStyle ? 2 : 1) * g) + 2 * c, b = e.height * u + 2 * c; if (f = !1, "\n" !== t && "\r" !== t && "\t" !== t && " " !== t && (f = !0, l = Math.ceil(Math.max(b, l))), h + v > d && (a += l, l = b, h = 0, a + l > p)) { r.update(); const t = this.Vr(); i = t.canvasAndContext.canvas, n = t.canvasAndContext.context, r = t.texture.source, h = 0, a = 0, l = 0 } const x = g / u - (o.dropShadow?.distance ?? 0) - (o.ln?.width ?? 0); if (this.chars[t] = { id: t.codePointAt(0), xOffset: -this.wr, yOffset: -this.wr, xAdvance: x, kerning: {} }, f) { this.Nr(n, e, h + c, a + c, u, o); const s = r.width * u, i = r.height * u, l = new O(h / s * r.width, a / i * r.height, v / s * r.width, b / i * r.height); this.chars[t].texture = new Z({ source: r, frame: l }), h += Math.ceil(v) } } r.update(), this.Br = h, this.$r = a, this.Gr = l, this.Dr && this.Wr(s, n) } get pageTextures() { return G(0, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."), this.pages } Wr(t, s) { const e = this.Ur; for (let i = 0; i < t.length; i++) { const n = t[i]; for (let t = 0; t < this.Ir.length; t++) { const i = this.Ir[t]; let r = e[n]; r || (r = e[n] = s.measureText(n).width); let o = e[i]; o || (o = e[i] = s.measureText(i).width); let h = s.measureText(n + i).width, a = h - (r + o); a && (this.chars[n].kerning[i] = a), h = s.measureText(n + i).width, a = h - (r + o), a && (this.chars[i].kerning[n] = a) } } } Vr() { this.zr++; const t = this.resolution, s = Go.getOptimalCanvasAndContext(this.Mn, this.Mn, t); this.Hr(s.context, this.L, t); const e = t * (this.baseRenderedFontSize / this.baseMeasurementFontSize), i = new Z({ source: new Es({ resource: s.canvas, resolution: e, alphaMode: "premultiply-alpha-on-upload", autoGenerateMipmaps: this.jr }) }); this.Lr && (i.source.style = this.Lr); const n = { canvasAndContext: s, texture: i }; return this.pages[this.zr] = n, n } Hr(t, s, e) { s.fontSize = this.baseRenderedFontSize, t.scale(e, e), t.font = sn(s), s.fontSize = this.baseMeasurementFontSize, t.textBaseline = s.textBaseline; const i = s.ln, n = i?.width ?? 0; if (i && (t.lineWidth = n, t.lineJoin = i.join, t.miterLimit = i.miterLimit, t.strokeStyle = Do(i, t)), s.kr && (t.fillStyle = Do(s.kr, t)), s.dropShadow) { const i = s.dropShadow, n = kt.shared.setValue(i.color).toArray(), r = i.blur * e, o = i.distance * e; t.shadowColor = `rgba(${255 * n[0]},${255 * n[1]},${255 * n[2]},${i.alpha})`, t.shadowBlur = r, t.shadowOffsetX = Math.cos(i.angle) * o, t.shadowOffsetY = Math.sin(i.angle) * o } else t.shadowColor = "black", t.shadowBlur = 0, t.shadowOffsetX = 0, t.shadowOffsetY = 0 } Nr(t, s, e, i, n, r) { const o = s.text, h = s.fontProperties, a = r.ln, l = (a?.width ?? 0) * n, u = e + l / 2, c = i - l / 2, f = h.descent * n, d = s.lineHeight * n; let p = !1; r.stroke && l && (p = !0, t.strokeText(o, u, c + d - f)); const { shadowBlur: m, shadowOffsetX: g, shadowOffsetY: v } = t; r.kr && (p && (t.shadowBlur = 0, t.shadowOffsetX = 0, t.shadowOffsetY = 0), t.fillText(o, u, c + d - f)), p && (t.shadowBlur = m, t.shadowOffsetX = g, t.shadowOffsetY = v) } destroy() { super.destroy(); for (let t = 0; t < this.pages.length; t++) { const { canvasAndContext: s, texture: e } = this.pages[t]; Go.returnCanvasAndContext(s), e.destroy(!0) } this.pages = null } }; jo.defaultOptions = { textureSize: 512, style: new $o, mipmap: !0 }; let Lo = jo; function Vo(t, s, e, i) { const n = { width: 0, height: 0, offsetY: 0, scale: s.fontSize / e.baseMeasurementFontSize, lines: [{ width: 0, charPositions: [], spaceWidth: 0, spacesIndex: [], chars: [] }] }; n.offsetY = e.baseLineOffset; let r = n.lines[0], o = null, h = !0; const a = { width: 0, start: 0, index: 0, positions: [], chars: [] }, l = e.baseMeasurementFontSize / s.fontSize, u = s.letterSpacing * l, c = s.wordWrapWidth * l, f = s.lineHeight ? s.lineHeight * l : e.lineHeight, d = s.wordWrap && s.breakWords, p = t => { const s = r.width; for (let e = 0; e < a.index; e++) { const i = t.positions[e]; r.chars.push(t.chars[e]), r.charPositions.push(i + s) } r.width += t.width, h = !1, a.width = 0, a.index = 0, a.chars.length = 0 }, m = () => { let t = r.chars.length - 1; if (i) { let s = r.chars[t]; for (; " " === s;)r.width -= e.chars[s].xAdvance, s = r.chars[--t] } n.width = Math.max(n.width, r.width), r = { width: 0, charPositions: [], chars: [], spaceWidth: 0, spacesIndex: [] }, h = !0, n.lines.push(r), n.height += f }, g = t => t - u > c; for (let v = 0; v < t.length + 1; v++) { let i; const n = v === t.length; n || (i = t[v]); const l = e.chars[i] || e.chars[" "]; if (/(?:\s)/.test(i) || "\r" === i || "\n" === i || n) { if (!h && s.wordWrap && g(r.width + a.width) ? (m(), p(a), n || r.charPositions.push(0)) : (a.start = r.width, p(a), n || r.charPositions.push(0)), "\r" === i || "\n" === i) m(); else if (!n) { const t = l.xAdvance + (l.kerning[o] || 0) + u; r.width += t, r.spaceWidth = t, r.spacesIndex.push(r.charPositions.length), r.chars.push(i) } } else { const t = l.kerning[o] || 0, s = l.xAdvance + t + u; d && g(r.width + a.width + s) && (p(a), m()), a.positions[a.index++] = a.width + t, a.chars.push(i), a.width += s } o = i } return m(), "center" === s.align ? function (t) { for (let s = 0; s < t.lines.length; s++) { const e = t.lines[s], i = t.width / 2 - e.width / 2; for (let t = 0; t < e.charPositions.length; t++)e.charPositions[t] += i } }(n) : "right" === s.align ? function (t) { for (let s = 0; s < t.lines.length; s++) { const e = t.lines[s], i = t.width - e.width; for (let t = 0; t < e.charPositions.length; t++)e.charPositions[t] += i } }(n) : "justify" === s.align && function (t) { const s = t.width; for (let e = 0; e < t.lines.length; e++) { const i = t.lines[e]; let n = 0, r = i.spacesIndex[n++], o = 0; const h = i.spacesIndex.length, a = (s - i.width) / h; for (let t = 0; t < i.charPositions.length; t++)t === r && (r = i.spacesIndex[n++], o += a), i.charPositions[t] += o } }(n), n } let No = 0; const Wo = new class { constructor() { this.ALPHA = [["a", "z"], ["A", "Z"], " "], this.NUMERIC = [["0", "9"]], this.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "], this.ASCII = [[" ", "~"]], this.defaultOptions = { chars: this.ALPHANUMERIC, resolution: 1, padding: 4, skipKerning: !1, textureStyle: null }, this.measureCache = Ji(1e3) } getFont(t, s) { let e = `${s.fontFamily}-bitmap`, i = !0; if (s.kr.fill && !s.ln ? (e += s.kr.fill.styleKey, i = !1) : (s.ln || s.dropShadow) && (e = `${s.styleKey}-bitmap`, i = !1), !Ds.has(e)) { const t = Object.create(s); t.lineHeight = 0; const n = new Lo({ style: t, overrideFill: i, overrideSize: !0, ...this.defaultOptions }); No++, No > 50 && Et(), n.once("destroy", () => { No--, Ds.remove(e) }), Ds.set(e, n) } const n = Ds.get(e); return n.ensureCharacters?.(t), n } getLayout(t, s, e = !0) { const i = this.getFont(t, s), n = `${t}-${s.styleKey}-${e}`; if (this.measureCache.has(n)) return this.measureCache.get(n); const r = Vo(rn.graphemeSegmenter(t), s, i, e); return this.measureCache.set(n, r), r } measureText(t, s, e = !0) { return this.getLayout(t, s, e) } install(...t) { let s = t[0]; "string" == typeof s && (s = { name: s, style: t[1], chars: t[2]?.chars, resolution: t[2]?.resolution, padding: t[2]?.padding, skipKerning: t[2]?.skipKerning }, G(0, "BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})")); const e = s?.name; if (!e) throw new Error("[BitmapFontManager] Property `name` is required."); s = { ...this.defaultOptions, ...s }; const i = s.style, n = i instanceof $o ? i : new $o(i), r = s.dynamicFill ?? this.qr(n), o = new Lo({ style: n, overrideFill: r, skipKerning: s.skipKerning, padding: s.padding, resolution: s.resolution, overrideSize: !1, textureStyle: s.textureStyle }), h = function (t) { if ("" === t) return []; "string" == typeof t && (t = [t]); const s = []; for (let e = 0, i = t.length; e < i; e++) { const i = t[e]; if (Array.isArray(i)) { if (2 !== i.length) throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${i.length}.`); if (0 === i[0].length || 0 === i[1].length) throw new Error("[BitmapFont]: Invalid character delimiter."); const t = i[0].charCodeAt(0), e = i[1].charCodeAt(0); if (e < t) throw new Error("[BitmapFont]: Invalid character range."); for (let i = t, n = e; i <= n; i++)s.push(String.fromCharCode(i)) } else s.push(...Array.from(i)) } if (0 === s.length) throw new Error("[BitmapFont]: Empty set when resolving characters."); return s }(s.chars); return o.ensureCharacters(h.join("")), Ds.set(`${e}-bitmap`, o), o.once("destroy", () => Ds.remove(`${e}-bitmap`)), o } uninstall(t) { const s = `${t}-bitmap`, e = Ds.get(s); e && e.destroy() } qr(t) { return !(t.ln || t.dropShadow && 0 !== t.dropShadow.color || t.kr.fill || 16777215 !== t.kr.color) } }; class Ho { constructor(t) { this.Xr = [], this.Be = t, this.Be.runners.postrender.add(this), this.Be.runners.init.add(this), this.$e = document.createElement("div"), this.$e.style.position = "absolute", this.$e.style.top = "0", this.$e.style.left = "0", this.$e.style.pointerEvents = "none", this.$e.style.zIndex = "1000" } init() { this.hi = new ie({ domElement: this.$e, renderer: this.Be }) } addRenderable(t, s) { this.Xr.includes(t) || this.Xr.push(t) } updateRenderable(t) { } validateRenderable(t) { return !0 } postrender() { const t = this.Xr; if (0 !== t.length) { this.hi.ensureAttached(); for (let s = 0; s < t.length; s++) { const e = t[s], i = e.element; if (!e.parent || e.globalDisplayStatus < 7) i?.remove(), t.splice(s, 1), s--; else { this.$e.contains(i) || (i.style.position = "absolute", i.style.pointerEvents = "auto", this.$e.appendChild(i)); const t = e.worldTransform, s = e.xs, n = e.width * s.x, r = e.height * s.y; i.style.transformOrigin = `${n}px ${r}px`, i.style.transform = `matrix(${t.a}, ${t.b}, ${t.c}, ${t.d}, ${t.tx - n}, ${t.ty - r})`, i.style.opacity = e.groupAlpha.toString() } } } else this.$e.remove() } destroy() { this.Be.runners.postrender.remove(this); for (let t = 0; t < this.Xr.length; t++) { const s = this.Xr[t]; s.element?.remove() } this.Xr.length = 0, this.$e.remove(), this.hi.destroy(), this.Be = null } } Ho.extension = { type: [r.WebGLPipes, r.WebGPUPipes, r.CanvasPipes], name: "dom" }; const qo = new class { constructor() { this.interactionFrequency = 10, this.Yr = 0, this.Kr = !1, this.Zr = !1, this.Qr = !0 } init(t) { this.removeTickerListener(), this.events = t, this.interactionFrequency = 10, this.Yr = 0, this.Kr = !1, this.Zr = !1, this.Qr = !0 } get pauseUpdate() { return this.Qr } set pauseUpdate(t) { this.Qr = t } addTickerListener() { !this.Zr && this.domElement && (Bs.system.add(this.Jr, this, Rs.INTERACTION), this.Zr = !0) } removeTickerListener() { this.Zr && (Bs.system.remove(this.Jr, this), this.Zr = !1) } pointerMoved() { this.Kr = !0 } so() { if (!this.domElement || this.Qr) return; if (this.Kr) return void (this.Kr = !1); const t = this.events.eo; this.events.supportsTouchEvents && "touch" === t.pointerType || globalThis.document.dispatchEvent(this.events.supportsPointerEvents ? new PointerEvent("pointermove", { clientX: t.clientX, clientY: t.clientY, pointerType: t.pointerType, pointerId: t.pointerId }) : new MouseEvent("mousemove", { clientX: t.clientX, clientY: t.clientY })) } Jr(t) { this.Yr += t.deltaTime, this.Yr < this.interactionFrequency || (this.Yr = 0, this.so()) } destroy() { this.removeTickerListener(), this.events = null, this.domElement = null, this.Yr = 0, this.Kr = !1, this.Zr = !1, this.Qr = !0 } }; class Xo extends ne { constructor() { super(...arguments), this.client = new x, this.movement = new x, this.offset = new x, this.global = new x, this.screen = new x } get clientX() { return this.client.x } get clientY() { return this.client.y } get x() { return this.clientX } get y() { return this.clientY } get movementX() { return this.movement.x } get movementY() { return this.movement.y } get offsetX() { return this.offset.x } get offsetY() { return this.offset.y } get globalX() { return this.global.x } get globalY() { return this.global.y } get screenX() { return this.screen.x } get screenY() { return this.screen.y } getLocalPosition(t, s, e) { return t.worldTransform.applyInverse(e || this.global, s) } getModifierState(t) { return "getModifierState" in this.nativeEvent && this.nativeEvent.getModifierState(t) } initMouseEvent(t, s, e, i, n, r, o, h, a, l, u, c, f, d, p) { throw new Error("Method not implemented.") } } class Yo extends Xo { constructor() { super(...arguments), this.width = 0, this.height = 0, this.isPrimary = !1 } getCoalescedEvents() { return "pointermove" === this.type || "mousemove" === this.type || "touchmove" === this.type ? [this] : [] } getPredictedEvents() { throw new Error("getPredictedEvents is not supported!") } } class Ko extends Xo { constructor() { super(...arguments), this.DOM_DELTA_PIXEL = 0, this.DOM_DELTA_LINE = 1, this.DOM_DELTA_PAGE = 2 } } Ko.DOM_DELTA_PIXEL = 0, Ko.DOM_DELTA_LINE = 1, Ko.DOM_DELTA_PAGE = 2; const Zo = new x, Qo = new x; class Jo { constructor(t) { this.dispatch = new m, this.moveOnAll = !1, this.enableGlobalMoveEvents = !0, this.mappingState = { trackingData: {} }, this.eventPool = new Map, this.io = [], this.no = [], this.ro = !1, this.rootTarget = t, this.hitPruneFn = this.hitPruneFn.bind(this), this.hitTestFn = this.hitTestFn.bind(this), this.mapPointerDown = this.mapPointerDown.bind(this), this.mapPointerMove = this.mapPointerMove.bind(this), this.mapPointerOut = this.mapPointerOut.bind(this), this.mapPointerOver = this.mapPointerOver.bind(this), this.mapPointerUp = this.mapPointerUp.bind(this), this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this), this.mapWheel = this.mapWheel.bind(this), this.mappingTable = {}, this.addEventMapping("pointerdown", this.mapPointerDown), this.addEventMapping("pointermove", this.mapPointerMove), this.addEventMapping("pointerout", this.mapPointerOut), this.addEventMapping("pointerleave", this.mapPointerOut), this.addEventMapping("pointerover", this.mapPointerOver), this.addEventMapping("pointerup", this.mapPointerUp), this.addEventMapping("pointerupoutside", this.mapPointerUpOutside), this.addEventMapping("wheel", this.mapWheel) } addEventMapping(t, s) { this.mappingTable[t] || (this.mappingTable[t] = []), this.mappingTable[t].push({ fn: s, priority: 0 }), this.mappingTable[t].sort((t, s) => t.priority - s.priority) } dispatchEvent(t, s) { t.propagationStopped = !1, t.propagationImmediatelyStopped = !1, this.propagate(t, s), this.dispatch.emit(s || t.type, t) } mapEvent(t) { if (!this.rootTarget) return; const s = this.mappingTable[t.type]; if (s) for (let e = 0, i = s.length; e < i; e++)s[e].fn(t); else Et(t.type) } hitTest(t, s) { qo.pauseUpdate = !0; const e = this[this.ro && this.enableGlobalMoveEvents ? "hitTestMoveRecursive" : "hitTestRecursive"](this.rootTarget, this.rootTarget.eventMode, Zo.set(t, s), this.hitTestFn, this.hitPruneFn); return e && e[0] } propagate(t, s) { if (!t.target) return; const e = t.composedPath(); t.eventPhase = t.CAPTURING_PHASE; for (let i = 0, n = e.length - 1; i < n; i++)if (t.currentTarget = e[i], this.notifyTarget(t, s), t.propagationStopped || t.propagationImmediatelyStopped) return; if (t.eventPhase = t.AT_TARGET, t.currentTarget = t.target, this.notifyTarget(t, s), !t.propagationStopped && !t.propagationImmediatelyStopped) { t.eventPhase = t.BUBBLING_PHASE; for (let i = e.length - 2; i >= 0; i--)if (t.currentTarget = e[i], this.notifyTarget(t, s), t.propagationStopped || t.propagationImmediatelyStopped) return } } all(t, s, e = this.io) { if (0 === e.length) return; t.eventPhase = t.BUBBLING_PHASE; const i = Array.isArray(s) ? s : [s]; for (let n = e.length - 1; n >= 0; n--)i.forEach(s => { t.currentTarget = e[n], this.notifyTarget(t, s) }) } propagationPath(t) { const s = [t]; for (let e = 0; e < 2048 && t !== this.rootTarget && t.parent; e++) { if (!t.parent) throw new Error("Cannot find propagation path to disconnected target"); s.push(t.parent), t = t.parent } return s.reverse(), s } hitTestMoveRecursive(t, s, e, i, n, r = !1) { let o = !1; if (this.oo(t)) return null; if ("dynamic" !== t.eventMode && "dynamic" !== s || (qo.pauseUpdate = !1), t.interactiveChildren && t.children) { const h = t.children; for (let a = h.length - 1; a >= 0; a--) { const l = h[a], u = this.hitTestMoveRecursive(l, this.ho(s) ? s : l.eventMode, e, i, n, r || n(t, e)); if (u) { if (u.length > 0 && !u[u.length - 1].parent) continue; const s = t.isInteractive(); (u.length > 0 || s) && (s && this.io.push(t), u.push(t)), 0 === this.no.length && (this.no = u), o = !0 } } } const h = this.ho(s), a = t.isInteractive(); return a && a && this.io.push(t), r || this.no.length > 0 ? null : o ? this.no : h && !n(t, e) && i(t, e) ? a ? [t] : [] : null } hitTestRecursive(t, s, e, i, n) { if (this.oo(t) || n(t, e)) return null; if ("dynamic" !== t.eventMode && "dynamic" !== s || (qo.pauseUpdate = !1), t.interactiveChildren && t.children) { const r = t.children, o = e; for (let e = r.length - 1; e >= 0; e--) { const h = r[e], a = this.hitTestRecursive(h, this.ho(s) ? s : h.eventMode, o, i, n); if (a) { if (a.length > 0 && !a[a.length - 1].parent) continue; const s = t.isInteractive(); return (a.length > 0 || s) && a.push(t), a } } } const r = this.ho(s), o = t.isInteractive(); return r && i(t, e) ? o ? [t] : [] : null } ho(t) { return "static" === t || "dynamic" === t } oo(t) { return !(t && t.visible && t.renderable && t.measurable) || "none" === t.eventMode || "passive" === t.eventMode && !t.interactiveChildren } hitPruneFn(t, s) { if (t.hitArea && (t.worldTransform.applyInverse(s, Qo), !t.hitArea.contains(Qo.x, Qo.y))) return !0; if (t.effects && t.effects.length) for (let e = 0; e < t.effects.length; e++) { const i = t.effects[e]; if (i.containsPoint && !i.containsPoint(s, this.hitTestFn)) return !0 } return !1 } hitTestFn(t, s) { return !!t.hitArea || !!t?.containsPoint && (t.worldTransform.applyInverse(s, Qo), t.containsPoint(Qo)) } notifyTarget(t, s) { if (!t.currentTarget.isInteractive()) return; s ?? (s = t.type); const e = `on${s}`; t.currentTarget[e]?.(t); const i = t.eventPhase === t.CAPTURING_PHASE || t.eventPhase === t.AT_TARGET ? `${s}capture` : s; this.ao(t, i), t.eventPhase === t.AT_TARGET && this.ao(t, s) } mapPointerDown(t) { if (!(t instanceof Yo)) return void Et(); const s = this.createPointerEvent(t); if (this.dispatchEvent(s, "pointerdown"), "touch" === s.pointerType) this.dispatchEvent(s, "touchstart"); else if ("mouse" === s.pointerType || "pen" === s.pointerType) { const t = 2 === s.button; this.dispatchEvent(s, t ? "rightdown" : "mousedown") } this.trackingData(t.pointerId).pressTargetsByButton[t.button] = s.composedPath(), this.freeEvent(s) } mapPointerMove(t) { if (!(t instanceof Yo)) return void Et(); this.io.length = 0, this.no.length = 0, this.ro = !0; const s = this.createPointerEvent(t); this.ro = !1; const e = "mouse" === s.pointerType || "pen" === s.pointerType, i = this.trackingData(t.pointerId), n = this.findMountedTarget(i.overTargets); if (i.overTargets?.length > 0 && n !== s.target) { const i = "mousemove" === t.type ? "mouseout" : "pointerout", r = this.createPointerEvent(t, i, n); if (this.dispatchEvent(r, "pointerout"), e && this.dispatchEvent(r, "mouseout"), !s.composedPath().includes(n)) { const i = this.createPointerEvent(t, "pointerleave", n); for (i.eventPhase = i.AT_TARGET; i.target && !s.composedPath().includes(i.target);)i.currentTarget = i.target, this.notifyTarget(i), e && this.notifyTarget(i, "mouseleave"), i.target = i.target.parent; this.freeEvent(i) } this.freeEvent(r) } if (n !== s.target) { const i = "mousemove" === t.type ? "mouseover" : "pointerover", r = this.clonePointerEvent(s, i); this.dispatchEvent(r, "pointerover"), e && this.dispatchEvent(r, "mouseover"); let o = n?.parent; for (; o && o !== this.rootTarget.parent && o !== s.target;)o = o.parent; if (!o || o === this.rootTarget.parent) { const t = this.clonePointerEvent(s, "pointerenter"); for (t.eventPhase = t.AT_TARGET; t.target && t.target !== n && t.target !== this.rootTarget.parent;)t.currentTarget = t.target, this.notifyTarget(t), e && this.notifyTarget(t, "mouseenter"), t.target = t.target.parent; this.freeEvent(t) } this.freeEvent(r) } const r = [], o = this.enableGlobalMoveEvents ?? !0; this.moveOnAll ? r.push("pointermove") : this.dispatchEvent(s, "pointermove"), o && r.push("globalpointermove"), "touch" === s.pointerType && (this.moveOnAll ? r.splice(1, 0, "touchmove") : this.dispatchEvent(s, "touchmove"), o && r.push("globaltouchmove")), e && (this.moveOnAll ? r.splice(1, 0, "mousemove") : this.dispatchEvent(s, "mousemove"), o && r.push("globalmousemove"), this.cursor = s.target?.cursor), r.length > 0 && this.all(s, r), this.io.length = 0, this.no.length = 0, i.overTargets = s.composedPath(), this.freeEvent(s) } mapPointerOver(t) { if (!(t instanceof Yo)) return void Et(); const s = this.trackingData(t.pointerId), e = this.createPointerEvent(t), i = "mouse" === e.pointerType || "pen" === e.pointerType; this.dispatchEvent(e, "pointerover"), i && this.dispatchEvent(e, "mouseover"), "mouse" === e.pointerType && (this.cursor = e.target?.cursor); const n = this.clonePointerEvent(e, "pointerenter"); for (n.eventPhase = n.AT_TARGET; n.target && n.target !== this.rootTarget.parent;)n.currentTarget = n.target, this.notifyTarget(n), i && this.notifyTarget(n, "mouseenter"), n.target = n.target.parent; s.overTargets = e.composedPath(), this.freeEvent(e), this.freeEvent(n) } mapPointerOut(t) { if (!(t instanceof Yo)) return void Et(); const s = this.trackingData(t.pointerId); if (s.overTargets) { const e = "mouse" === t.pointerType || "pen" === t.pointerType, i = this.findMountedTarget(s.overTargets), n = this.createPointerEvent(t, "pointerout", i); this.dispatchEvent(n), e && this.dispatchEvent(n, "mouseout"); const r = this.createPointerEvent(t, "pointerleave", i); for (r.eventPhase = r.AT_TARGET; r.target && r.target !== this.rootTarget.parent;)r.currentTarget = r.target, this.notifyTarget(r), e && this.notifyTarget(r, "mouseleave"), r.target = r.target.parent; s.overTargets = null, this.freeEvent(n), this.freeEvent(r) } this.cursor = null } mapPointerUp(t) { if (!(t instanceof Yo)) return void Et(); const s = performance.now(), e = this.createPointerEvent(t); if (this.dispatchEvent(e, "pointerup"), "touch" === e.pointerType) this.dispatchEvent(e, "touchend"); else if ("mouse" === e.pointerType || "pen" === e.pointerType) { const t = 2 === e.button; this.dispatchEvent(e, t ? "rightup" : "mouseup") } const i = this.trackingData(t.pointerId), n = this.findMountedTarget(i.pressTargetsByButton[t.button]); let r = n; if (n && !e.composedPath().includes(n)) { let s = n; for (; s && !e.composedPath().includes(s);) { if (e.currentTarget = s, this.notifyTarget(e, "pointerupoutside"), "touch" === e.pointerType) this.notifyTarget(e, "touchendoutside"); else if ("mouse" === e.pointerType || "pen" === e.pointerType) { const t = 2 === e.button; this.notifyTarget(e, t ? "rightupoutside" : "mouseupoutside") } s = s.parent } delete i.pressTargetsByButton[t.button], r = s } if (r) { const n = this.clonePointerEvent(e, "click"); n.target = r, n.path = null, i.clicksByButton[t.button] || (i.clicksByButton[t.button] = { clickCount: 0, target: n.target, timeStamp: s }); const o = i.clicksByButton[t.button]; if (o.target === n.target && s - o.timeStamp < 200 ? ++o.clickCount : o.clickCount = 1, o.target = n.target, o.timeStamp = s, n.detail = o.clickCount, "mouse" === n.pointerType) { const t = 2 === n.button; this.dispatchEvent(n, t ? "rightclick" : "click") } else "touch" === n.pointerType && this.dispatchEvent(n, "tap"); this.dispatchEvent(n, "pointertap"), this.freeEvent(n) } this.freeEvent(e) } mapPointerUpOutside(t) { if (!(t instanceof Yo)) return void Et(); const s = this.trackingData(t.pointerId), e = this.findMountedTarget(s.pressTargetsByButton[t.button]), i = this.createPointerEvent(t); if (e) { let n = e; for (; n;)i.currentTarget = n, this.notifyTarget(i, "pointerupoutside"), "touch" === i.pointerType ? this.notifyTarget(i, "touchendoutside") : "mouse" !== i.pointerType && "pen" !== i.pointerType || this.notifyTarget(i, 2 === i.button ? "rightupoutside" : "mouseupoutside"), n = n.parent; delete s.pressTargetsByButton[t.button] } this.freeEvent(i) } mapWheel(t) { if (!(t instanceof Ko)) return void Et(); const s = this.createWheelEvent(t); this.dispatchEvent(s), this.freeEvent(s) } findMountedTarget(t) { if (!t) return null; let s = t[0]; for (let e = 1; e < t.length && t[e].parent === s; e++)s = t[e]; return s } createPointerEvent(t, s, e) { const i = this.allocateEvent(Yo); return this.copyPointerData(t, i), this.copyMouseData(t, i), this.copyData(t, i), i.nativeEvent = t.nativeEvent, i.originalEvent = t, i.target = e ?? this.hitTest(i.global.x, i.global.y) ?? this.no[0], "string" == typeof s && (i.type = s), i } createWheelEvent(t) { const s = this.allocateEvent(Ko); return this.copyWheelData(t, s), this.copyMouseData(t, s), this.copyData(t, s), s.nativeEvent = t.nativeEvent, s.originalEvent = t, s.target = this.hitTest(s.global.x, s.global.y), s } clonePointerEvent(t, s) { const e = this.allocateEvent(Yo); return e.nativeEvent = t.nativeEvent, e.originalEvent = t.originalEvent, this.copyPointerData(t, e), this.copyMouseData(t, e), this.copyData(t, e), e.target = t.target, e.path = t.composedPath().slice(), e.type = s ?? e.type, e } copyWheelData(t, s) { s.deltaMode = t.deltaMode, s.deltaX = t.deltaX, s.deltaY = t.deltaY, s.deltaZ = t.deltaZ } copyPointerData(t, s) { t instanceof Yo && s instanceof Yo && (s.pointerId = t.pointerId, s.width = t.width, s.height = t.height, s.isPrimary = t.isPrimary, s.pointerType = t.pointerType, s.pressure = t.pressure, s.tangentialPressure = t.tangentialPressure, s.tiltX = t.tiltX, s.tiltY = t.tiltY, s.twist = t.twist) } copyMouseData(t, s) { t instanceof Xo && s instanceof Xo && (s.altKey = t.altKey, s.button = t.button, s.buttons = t.buttons, s.client.copyFrom(t.client), s.ctrlKey = t.ctrlKey, s.metaKey = t.metaKey, s.movement.copyFrom(t.movement), s.screen.copyFrom(t.screen), s.shiftKey = t.shiftKey, s.global.copyFrom(t.global)) } copyData(t, s) { s.isTrusted = t.isTrusted, s.srcElement = t.srcElement, s.timeStamp = performance.now(), s.type = t.type, s.detail = t.detail, s.view = t.view, s.which = t.which, s.layer.copyFrom(t.layer), s.page.copyFrom(t.page) } trackingData(t) { return this.mappingState.trackingData[t] || (this.mappingState.trackingData[t] = { pressTargetsByButton: {}, clicksByButton: {}, overTarget: null }), this.mappingState.trackingData[t] } allocateEvent(t) { this.eventPool.has(t) || this.eventPool.set(t, []); const s = this.eventPool.get(t).pop() || new t(this); return s.eventPhase = s.NONE, s.currentTarget = null, s.defaultPrevented = !1, s.path = null, s.target = null, s } freeEvent(t) { if (t.manager !== this) throw new Error("It is illegal to free an event not managed by this EventBoundary!"); const s = t.constructor; this.eventPool.has(s) || this.eventPool.set(s, []), this.eventPool.get(s).push(t) } ao(t, s) { const e = t.currentTarget.P[s]; if (e) if ("fn" in e) e.once && t.currentTarget.removeListener(s, e.fn, void 0, !0), e.fn.call(e.context, t); else for (let i = 0, n = e.length; i < n && !t.propagationImmediatelyStopped; i++)e[i].once && t.currentTarget.removeListener(s, e[i].fn, void 0, !0), e[i].fn.call(e[i].context, t) } } const th = { touchstart: "pointerdown", touchend: "pointerup", touchendoutside: "pointerupoutside", touchmove: "pointermove", touchcancel: "pointercancel" }, sh = class t { constructor(s) { this.supportsTouchEvents = "ontouchstart" in globalThis, this.supportsPointerEvents = !!globalThis.PointerEvent, this.domElement = null, this.resolution = 1, this.renderer = s, this.rootBoundary = new Jo(null), qo.init(this), this.autoPreventDefault = !0, this.lo = !1, this.eo = new Yo(null), this.uo = new Ko(null), this.cursorStyles = { default: "inherit", pointer: "pointer" }, this.features = new Proxy({ ...t.defaultEventFeatures }, { set: (t, s, e) => ("globalMove" === s && (this.rootBoundary.enableGlobalMoveEvents = e), t[s] = e, !0) }), this.co = this.co.bind(this), this.fo = this.fo.bind(this), this.do = this.do.bind(this), this.po = this.po.bind(this), this.onWheel = this.onWheel.bind(this) } static get defaultEventMode() { return this.mo } init(s) { const { canvas: e, resolution: i } = this.renderer; this.setTargetElement(e), this.resolution = i, t.mo = s.eventMode ?? "passive", Object.assign(this.features, s.eventFeatures ?? {}), this.rootBoundary.enableGlobalMoveEvents = this.features.globalMove } resolutionChange(t) { this.resolution = t } destroy() { qo.destroy(), this.setTargetElement(null), this.renderer = null, this.vo = null } setCursor(t) { t || (t = "default"); let s = !0; if (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas && (s = !1), this.vo === t) return; this.vo = t; const e = this.cursorStyles[t]; if (e) switch (typeof e) { case "string": s && (this.domElement.style.cursor = e); break; case "function": e(t); break; case "object": s && Object.assign(this.domElement.style, e) } else s && "string" == typeof t && !Object.prototype.hasOwnProperty.call(this.cursorStyles, t) && (this.domElement.style.cursor = t) } get pointer() { return this.eo } co(t) { if (!this.features.click) return; this.rootBoundary.rootTarget = this.renderer.lastObjectRendered; const s = this.bo(t); this.autoPreventDefault && s[0].isNormalized && (t.cancelable || !("cancelable" in t)) && t.preventDefault(); for (let e = 0, i = s.length; e < i; e++) { const t = s[e], i = this.xo(this.eo, t); this.rootBoundary.mapEvent(i) } this.setCursor(this.rootBoundary.cursor) } fo(t) { if (!this.features.move) return; this.rootBoundary.rootTarget = this.renderer.lastObjectRendered, qo.pointerMoved(); const s = this.bo(t); for (let e = 0, i = s.length; e < i; e++) { const t = this.xo(this.eo, s[e]); this.rootBoundary.mapEvent(t) } this.setCursor(this.rootBoundary.cursor) } do(t) { if (!this.features.click) return; this.rootBoundary.rootTarget = this.renderer.lastObjectRendered; let s = t.target; t.composedPath && t.composedPath().length > 0 && (s = t.composedPath()[0]); const e = s !== this.domElement ? "outside" : "", i = this.bo(t); for (let n = 0, r = i.length; n < r; n++) { const t = this.xo(this.eo, i[n]); t.type += e, this.rootBoundary.mapEvent(t) } this.setCursor(this.rootBoundary.cursor) } po(t) { if (!this.features.click) return; this.rootBoundary.rootTarget = this.renderer.lastObjectRendered; const s = this.bo(t); for (let e = 0, i = s.length; e < i; e++) { const t = this.xo(this.eo, s[e]); this.rootBoundary.mapEvent(t) } this.setCursor(this.rootBoundary.cursor) } onWheel(t) { if (!this.features.wheel) return; const s = this.normalizeWheelEvent(t); this.rootBoundary.rootTarget = this.renderer.lastObjectRendered, this.rootBoundary.mapEvent(s) } setTargetElement(t) { this.yo(), this.domElement = t, qo.domElement = t, this.wo() } wo() { if (this.lo || !this.domElement) return; qo.addTickerListener(); const t = this.domElement.style; t && (globalThis.navigator.msPointerEnabled ? (t.msContentZooming = "none", t.msTouchAction = "none") : this.supportsPointerEvents && (t.touchAction = "none")), this.supportsPointerEvents ? (globalThis.document.addEventListener("pointermove", this.fo, !0), this.domElement.addEventListener("pointerdown", this.co, !0), this.domElement.addEventListener("pointerleave", this.po, !0), this.domElement.addEventListener("pointerover", this.po, !0), globalThis.addEventListener("pointerup", this.do, !0)) : (globalThis.document.addEventListener("mousemove", this.fo, !0), this.domElement.addEventListener("mousedown", this.co, !0), this.domElement.addEventListener("mouseout", this.po, !0), this.domElement.addEventListener("mouseover", this.po, !0), globalThis.addEventListener("mouseup", this.do, !0), this.supportsTouchEvents && (this.domElement.addEventListener("touchstart", this.co, !0), this.domElement.addEventListener("touchend", this.do, !0), this.domElement.addEventListener("touchmove", this.fo, !0))), this.domElement.addEventListener("wheel", this.onWheel, { passive: !0, capture: !0 }), this.lo = !0 } yo() { if (!this.lo || !this.domElement) return; qo.removeTickerListener(); const t = this.domElement.style; t && (globalThis.navigator.msPointerEnabled ? (t.msContentZooming = "", t.msTouchAction = "") : this.supportsPointerEvents && (t.touchAction = "")), this.supportsPointerEvents ? (globalThis.document.removeEventListener("pointermove", this.fo, !0), this.domElement.removeEventListener("pointerdown", this.co, !0), this.domElement.removeEventListener("pointerleave", this.po, !0), this.domElement.removeEventListener("pointerover", this.po, !0), globalThis.removeEventListener("pointerup", this.do, !0)) : (globalThis.document.removeEventListener("mousemove", this.fo, !0), this.domElement.removeEventListener("mousedown", this.co, !0), this.domElement.removeEventListener("mouseout", this.po, !0), this.domElement.removeEventListener("mouseover", this.po, !0), globalThis.removeEventListener("mouseup", this.do, !0), this.supportsTouchEvents && (this.domElement.removeEventListener("touchstart", this.co, !0), this.domElement.removeEventListener("touchend", this.do, !0), this.domElement.removeEventListener("touchmove", this.fo, !0))), this.domElement.removeEventListener("wheel", this.onWheel, !0), this.domElement = null, this.lo = !1 } mapPositionToPoint(t, s, e) { const i = this.domElement.isConnected ? this.domElement.getBoundingClientRect() : { width: this.domElement.width, height: this.domElement.height, left: 0, top: 0 }, n = 1 / this.resolution; t.x = (s - i.left) * (this.domElement.width / i.width) * n, t.y = (e - i.top) * (this.domElement.height / i.height) * n } bo(t) { const s = []; if (this.supportsTouchEvents && t instanceof TouchEvent) for (let e = 0, i = t.changedTouches.length; e < i; e++) { const i = t.changedTouches[e]; void 0 === i.button && (i.button = 0), void 0 === i.buttons && (i.buttons = 1), void 0 === i.isPrimary && (i.isPrimary = 1 === t.touches.length && "touchstart" === t.type), void 0 === i.width && (i.width = i.radiusX || 1), void 0 === i.height && (i.height = i.radiusY || 1), void 0 === i.tiltX && (i.tiltX = 0), void 0 === i.tiltY && (i.tiltY = 0), void 0 === i.pointerType && (i.pointerType = "touch"), void 0 === i.pointerId && (i.pointerId = i.identifier || 0), void 0 === i.pressure && (i.pressure = i.force || .5), void 0 === i.twist && (i.twist = 0), void 0 === i.tangentialPressure && (i.tangentialPressure = 0), void 0 === i.layerX && (i.layerX = i.offsetX = i.clientX), void 0 === i.layerY && (i.layerY = i.offsetY = i.clientY), i.isNormalized = !0, i.type = t.type, s.push(i) } else if (!globalThis.MouseEvent || t instanceof MouseEvent && !(this.supportsPointerEvents && t instanceof globalThis.PointerEvent)) { const e = t; void 0 === e.isPrimary && (e.isPrimary = !0), void 0 === e.width && (e.width = 1), void 0 === e.height && (e.height = 1), void 0 === e.tiltX && (e.tiltX = 0), void 0 === e.tiltY && (e.tiltY = 0), void 0 === e.pointerType && (e.pointerType = "mouse"), void 0 === e.pointerId && (e.pointerId = 1), void 0 === e.pressure && (e.pressure = .5), void 0 === e.twist && (e.twist = 0), void 0 === e.tangentialPressure && (e.tangentialPressure = 0), e.isNormalized = !0, s.push(e) } else s.push(t); return s } normalizeWheelEvent(t) { const s = this.uo; return this.Mo(s, t), s.deltaX = t.deltaX, s.deltaY = t.deltaY, s.deltaZ = t.deltaZ, s.deltaMode = t.deltaMode, this.mapPositionToPoint(s.screen, t.clientX, t.clientY), s.global.copyFrom(s.screen), s.offset.copyFrom(s.screen), s.nativeEvent = t, s.type = t.type, s } xo(t, s) { return t.originalEvent = null, t.nativeEvent = s, t.pointerId = s.pointerId, t.width = s.width, t.height = s.height, t.isPrimary = s.isPrimary, t.pointerType = s.pointerType, t.pressure = s.pressure, t.tangentialPressure = s.tangentialPressure, t.tiltX = s.tiltX, t.tiltY = s.tiltY, t.twist = s.twist, this.Mo(t, s), this.mapPositionToPoint(t.screen, s.clientX, s.clientY), t.global.copyFrom(t.screen), t.offset.copyFrom(t.screen), t.isTrusted = s.isTrusted, "pointerleave" === t.type && (t.type = "pointerout"), t.type.startsWith("mouse") && (t.type = t.type.replace("mouse", "pointer")), t.type.startsWith("touch") && (t.type = th[t.type] || t.type), t } Mo(t, s) { t.isTrusted = s.isTrusted, t.srcElement = s.srcElement, t.timeStamp = performance.now(), t.type = s.type, t.altKey = s.altKey, t.button = s.button, t.buttons = s.buttons, t.client.x = s.clientX, t.client.y = s.clientY, t.ctrlKey = s.ctrlKey, t.metaKey = s.metaKey, t.movement.x = s.movementX, t.movement.y = s.movementY, t.page.x = s.pageX, t.page.y = s.pageY, t.relatedTarget = null, t.shiftKey = s.shiftKey } }; sh.extension = { name: "events", type: [r.WebGLSystem, r.CanvasSystem, r.WebGPUSystem], priority: -1 }, sh.defaultEventFeatures = { move: !0, globalMove: !0, click: !0, wheel: !0 }; let eh = sh; const ih = { onclick: null, onmousedown: null, onmouseenter: null, onmouseleave: null, onmousemove: null, onglobalmousemove: null, onmouseout: null, onmouseover: null, onmouseup: null, onmouseupoutside: null, onpointercancel: null, onpointerdown: null, onpointerenter: null, onpointerleave: null, onpointermove: null, onglobalpointermove: null, onpointerout: null, onpointerover: null, onpointertap: null, onpointerup: null, onpointerupoutside: null, onrightclick: null, onrightdown: null, onrightup: null, onrightupoutside: null, ontap: null, ontouchcancel: null, ontouchend: null, ontouchendoutside: null, ontouchmove: null, onglobaltouchmove: null, ontouchstart: null, onwheel: null, get interactive() { return "dynamic" === this.eventMode || "static" === this.eventMode }, set interactive(t) { this.eventMode = t ? "static" : "passive" }, To: void 0, get eventMode() { return this.To ?? eh.defaultEventMode }, set eventMode(t) { this.To = t }, isInteractive() { return "static" === this.eventMode || "dynamic" === this.eventMode }, interactiveChildren: !0, hitArea: null, addEventListener(t, s, e) { const i = "boolean" == typeof e && e || "object" == typeof e && e.capture, n = "object" == typeof e ? e.signal : void 0, r = "object" == typeof e && !0 === e.once, o = "function" == typeof s ? void 0 : s; t = i ? `${t}capture` : t; const h = "function" == typeof s ? s : s.handleEvent, a = this; n && n.addEventListener("abort", () => { a.off(t, h, o) }), r ? a.once(t, h, o) : a.on(t, h, o) }, removeEventListener(t, s, e) { const i = "function" == typeof s ? void 0 : s; t = "boolean" == typeof e && e || "object" == typeof e && e.capture ? `${t}capture` : t, s = "function" == typeof s ? s : s.handleEvent, this.off(t, s, i) }, dispatchEvent(t) { if (!(t instanceof ne)) throw new Error("Container cannot propagate events outside of the Federated Events API"); return t.defaultPrevented = !1, t.path = null, t.target = this, t.manager.dispatchEvent(t), !t.defaultPrevented } }; var nh = "struct GlobalFilterUniforms {\n  uInputSize: vec4<f32>,\n  uInputPixel: vec4<f32>,\n  uInputClamp: vec4<f32>,\n  uOutputFrame: vec4<f32>,\n  uGlobalFrame: vec4<f32>,\n  uOutputTexture: vec4<f32>,\n};\n\n@group(0) @binding(0) var <uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\n@group(0) @binding(2) var uSampler: sampler;\n\nstruct VSOutput {\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv: vec2<f32>\n};\n\nfn filterVertexPosition(aPosition: vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0 * gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord(aPosition: vec2<f32>) -> vec2<f32>\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\n@vertex\nfn mainVertex(\n  @location(0) aPosition: vec2<f32>,\n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition)\n  );\n}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n) -> @location(0) vec4<f32> {\n    return textureSample(uTexture, uSampler, uv);\n}\n"; class rh extends ii { constructor() { super({ gpuProgram: Ne.from({ vertex: { source: nh, entryPoint: "mainVertex" }, fragment: { source: nh, entryPoint: "mainFragment" }, name: "passthrough-filter" }), glProgram: $e.from({ vertex: "in vec2 aPosition;\nout vec2 vTextureCoord;\n\nuniform vec4 uInputSize;\nuniform vec4 uOutputFrame;\nuniform vec4 uOutputTexture;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\n    \n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n", fragment: "in vec2 vTextureCoord;\nout vec4 finalColor;\nuniform sampler2D uTexture;\nvoid main() {\n    finalColor = texture(uTexture, vTextureCoord);\n}\n", name: "passthrough-filter" }) }) } } class oh { constructor(t) { this.Be = t } push(t, s, e) { this.Be.renderPipes.batch.break(e), e.add({ renderPipeId: "filter", canBundle: !1, action: "pushFilter", container: s, filterEffect: t }) } pop(t, s, e) { this.Be.renderPipes.batch.break(e), e.add({ renderPipeId: "filter", action: "popFilter", canBundle: !1 }) } execute(t) { "pushFilter" === t.action ? this.Be.filter.push(t) : "popFilter" === t.action && this.Be.filter.pop() } destroy() { this.Be = null } } oh.extension = { type: [r.WebGLPipes, r.WebGPUPipes, r.CanvasPipes], name: "filter" }; const hh = new w, ah = new Wn({ attributes: { aPosition: { buffer: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]), format: "float32x2", stride: 8, offset: 0 } }, indexBuffer: new Uint32Array([0, 1, 2, 0, 2, 3]) }); class lh { constructor() { this.skip = !1, this.inputTexture = null, this.backTexture = null, this.filters = null, this.bounds = new tt, this.container = null, this.blendRequired = !1, this.outputRenderSurface = null, this.globalFrame = { x: 0, y: 0, width: 0, height: 0 }, this.firstEnabledIndex = -1, this.lastEnabledIndex = -1 } } class uh { constructor(t) { this.Ao = 0, this.Co = [], this._o = new Ye({ uInputSize: { value: new Float32Array(4), type: "vec4<f32>" }, uInputPixel: { value: new Float32Array(4), type: "vec4<f32>" }, uInputClamp: { value: new Float32Array(4), type: "vec4<f32>" }, uOutputFrame: { value: new Float32Array(4), type: "vec4<f32>" }, uGlobalFrame: { value: new Float32Array(4), type: "vec4<f32>" }, uOutputTexture: { value: new Float32Array(4), type: "vec4<f32>" } }), this.So = new Ke({}), this.renderer = t } get activeBackTexture() { return this.Po?.backTexture } push(t) { const s = this.renderer, e = t.filterEffect.filters, i = this.ko(); i.skip = !1, i.filters = e, i.container = t.container, i.outputRenderSurface = s.renderTarget.renderSurface; const n = s.renderTarget.renderTarget.colorTexture.source, r = n.resolution, o = n.antialias; if (e.every(t => !t.enabled)) return void (i.skip = !0); const h = i.bounds; if (this.Fo(t, h), this.Eo(i, s.renderTarget.rootViewPort, o, r, 1), i.skip) return; const a = this.Ro(), l = this.Oo(r); let u = 0, c = 0; a && (u = a.bounds.minX, c = a.bounds.minY), this.Uo(i, u, c, l, n.width, n.height), this.Io(i, h, s, a) } generateFilteredTexture({ texture: t, filters: s }) { const e = this.ko(); this.Po = e, e.skip = !1, e.filters = s; const i = t.source, n = i.resolution, r = i.antialias; if (s.every(t => !t.enabled)) return e.skip = !0, t; const o = e.bounds; if (o.addRect(t.frame), this.Eo(e, o.rectangle, r, n, 0), e.skip) return t; const h = n; this.Uo(e, 0, 0, h, i.width, i.height), e.outputRenderSurface = fs.getOptimalTexture(o.width, o.height, e.resolution, e.antialias), e.backTexture = Z.EMPTY, e.inputTexture = t, this.renderer.renderTarget.finishRenderPass(), this.Bo(e, !0); const a = e.outputRenderSurface; return a.source.alphaMode = "premultiplied-alpha", a } pop() { const t = this.renderer, s = this.$o(); s.skip || (t.globalUniforms.pop(), t.renderTarget.finishRenderPass(), this.Po = s, this.Bo(s, !1), s.blendRequired && fs.returnTexture(s.backTexture), fs.returnTexture(s.inputTexture)) } getBackTexture(t, s, e) { const i = t.colorTexture.source.$, n = fs.getOptimalTexture(s.width, s.height, i, !1); let r = s.minX, o = s.minY; e && (r -= e.minX, o -= e.minY), r = Math.floor(r * i), o = Math.floor(o * i); const h = Math.ceil(s.width * i), a = Math.ceil(s.height * i); return this.renderer.renderTarget.copyToTexture(t, n, { x: r, y: o }, { width: h, height: a }, { x: 0, y: 0 }), n } applyFilter(t, s, e, i) { const n = this.renderer, r = this.Po, o = r.outputRenderSurface === e, h = n.renderTarget.rootRenderTarget.colorTexture.source.$, a = this.Oo(h); let l = 0, u = 0; if (o) { const t = this.Go(); l = t.x, u = t.y } this.zo(s, e, r, l, u, a, o, i); const c = t.enabled ? t : this.Do(); this.jo(c, s, n) } calculateSpriteMatrix(t, s) { const e = this.Po, i = t.set(e.inputTexture.K.width, 0, 0, e.inputTexture.K.height, e.bounds.minX, e.bounds.minY), n = s.worldTransform.copyTo(w.shared), r = s.renderGroup || s.parentRenderGroup; return r && r.cacheToLocalTransform && n.prepend(r.cacheToLocalTransform), n.invert(), i.prepend(n), i.scale(1 / s.texture.orig.width, 1 / s.texture.orig.height), i.translate(s.anchor.x, s.anchor.y), i } destroy() { this.Lo?.destroy(!0), this.Lo = null } Do() { return this.Lo ?? (this.Lo = new rh), this.Lo } jo(t, s, e) { if (e.renderPipes.uniformBatch) { const t = e.renderPipes.uniformBatch.getUboResource(this._o); this.So.setResource(t, 0) } else this.So.setResource(this._o, 0); this.So.setResource(s.source, 1), this.So.setResource(s.source.style, 2), t.groups[0] = this.So, e.encoder.draw({ geometry: ah, shader: t, state: t.ji, topology: "triangle-list" }), e.type === Ze.WEBGL && e.renderTarget.finishRenderPass() } Io(t, s, e, i) { if (t.backTexture = Z.EMPTY, t.inputTexture = fs.getOptimalTexture(s.width, s.height, t.resolution, t.antialias), t.blendRequired) { e.renderTarget.finishRenderPass(); const n = e.renderTarget.getRenderTarget(t.outputRenderSurface); t.backTexture = this.getBackTexture(n, s, i?.bounds) } e.renderTarget.bind(t.inputTexture, !0), e.globalUniforms.push({ offset: s }) } Uo(t, s, e, i, n, r) { const o = t.globalFrame; o.x = s * i, o.y = e * i, o.width = n * i, o.height = r * i } zo(t, s, e, i, n, r, o, h) { const a = this._o.uniforms, l = a.uOutputFrame, u = a.uInputSize, c = a.uInputPixel, f = a.uInputClamp, d = a.uGlobalFrame, p = a.uOutputTexture; o ? (l[0] = e.bounds.minX - i, l[1] = e.bounds.minY - n) : (l[0] = 0, l[1] = 0), l[2] = t.frame.width, l[3] = t.frame.height, u[0] = t.source.width, u[1] = t.source.height, u[2] = 1 / u[0], u[3] = 1 / u[1], c[0] = t.source.pixelWidth, c[1] = t.source.pixelHeight, c[2] = 1 / c[0], c[3] = 1 / c[1], f[0] = .5 * c[2], f[1] = .5 * c[3], f[2] = t.frame.width * u[2] - .5 * c[2], f[3] = t.frame.height * u[3] - .5 * c[3]; const m = this.renderer.renderTarget.rootRenderTarget.colorTexture; d[0] = i * r, d[1] = n * r, d[2] = m.source.width * r, d[3] = m.source.height * r, s instanceof Z && (s.source.resource = null); const g = this.renderer.renderTarget.getRenderTarget(s); this.renderer.renderTarget.bind(s, !!h), s instanceof Z ? (p[0] = s.frame.width, p[1] = s.frame.height) : (p[0] = g.width, p[1] = g.height), p[2] = g.isRoot ? -1 : 1, this._o.update() } Oo(t) { let s = this.Ao - 1; for (; s > 0 && this.Co[s].skip;)--s; return s > 0 && this.Co[s].inputTexture ? this.Co[s].inputTexture.source.$ : t } Go() { let t = 0, s = 0, e = this.Ao; for (; e > 0;) { e--; const i = this.Co[e]; if (!i.skip) { t = i.bounds.minX, s = i.bounds.minY; break } } return { x: t, y: s } } Fo(t, s) { if (t.renderables ? function (t, s) { s.clear(); const e = s.matrix; for (let i = 0; i < t.length; i++) { const e = t[i]; if (e.globalDisplayStatus < 7) continue; const n = e.renderGroup ?? e.parentRenderGroup; s.matrix = n?.isCachedAsTexture ? hh.copyFrom(n.textureOffsetInverseTransform).append(e.worldTransform) : n?.Vt ? hh.copyFrom(n.Vt.inverseWorldTransform).append(e.groupTransform) : e.worldTransform, s.addBounds(e.bounds) } s.matrix = e }(t.renderables, s) : t.filterEffect.filterArea ? (s.clear(), s.addRect(t.filterEffect.filterArea), s.applyMatrix(t.container.worldTransform)) : t.container.getFastGlobalBounds(!0, s), t.container) { const e = (t.container.renderGroup || t.container.parentRenderGroup).cacheToLocalTransform; e && s.applyMatrix(e) } } Bo(t, s) { const e = t.inputTexture, i = t.bounds, n = t.filters, r = t.firstEnabledIndex, o = t.lastEnabledIndex; if (this.So.setResource(e.source.style, 2), this.So.setResource(t.backTexture.source, 3), r === o) n[r].apply(this, e, t.outputRenderSurface, s); else { let e = t.inputTexture; const h = fs.getOptimalTexture(i.width, i.height, e.source.$, !1); let a = h; for (let t = r; t < o; t++) { const s = n[t]; if (!s.enabled) continue; s.apply(this, e, a, !0); const i = e; e = a, a = i } n[o].apply(this, e, t.outputRenderSurface, s), fs.returnTexture(h) } } Eo(t, s, e, i, n) { const r = this.renderer, o = t.bounds, h = t.filters; let a = 1 / 0, l = 0, u = !0, c = !1, f = !1, d = !0, p = -1, m = -1; for (let g = 0; g < h.length; g++) { const t = h[g]; if (t.enabled) { if (-1 === p && (p = g), m = g, a = Math.min(a, "inherit" === t.resolution ? i : t.resolution), l += t.padding, "off" === t.antialias ? u = !1 : "inherit" === t.antialias && u && (u = e), t.clipToViewport || (d = !1), !(t.compatibleRenderers & r.type)) { f = !1; break } if (t.blendRequired && !(r.backBuffer?.useBackBuffer ?? 1)) { Et(), f = !1; break } f = !0, c || (c = t.blendRequired) } } f ? (d && o.fitBounds(0, s.width / i, 0, s.height / i), o.scale(a).ceil().scale(1 / a).pad((0 | l) * n), o.isPositive ? (t.antialias = u, t.resolution = a, t.blendRequired = c, t.firstEnabledIndex = p, t.lastEnabledIndex = m) : t.skip = !0) : t.skip = !0 } $o() { return this.Ao--, this.Co[this.Ao] } Ro() { let t, s = this.Ao - 1; for (; s > 0 && (s--, t = this.Co[s], t.skip);); return t } ko() { let t = this.Co[this.Ao]; return t || (t = this.Co[this.Ao] = new lh), this.Ao++, t } } uh.extension = { type: [r.WebGLSystem, r.WebGPUSystem], name: "filter" }; var ch = "struct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\nstruct MaskUniforms {\n  uFilterMatrix:mat3x3<f32>,\n  uMaskClamp:vec4<f32>,\n  uAlpha:f32,\n  uInverse:f32,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\n@group(0) @binding(2) var uSampler : sampler;\n\n@group(1) @binding(0) var<uniform> filterUniforms : MaskUniforms;\n@group(1) @binding(1) var uMaskTexture: texture_2d<f32>;\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>,\n    @location(1) filterUv : vec2<f32>,\n};\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);\n}\n\nfn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return ( filterUniforms.uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\n}\n\nfn getSize() -> vec2<f32>\n{\n  return gfu.uGlobalFrame.zw;\n}\n\n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>,\n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition),\n   getFilterCoord(aPosition)\n  );\n}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @location(1) filterUv: vec2<f32>,\n  @builtin(position) position: vec4<f32>\n) -> @location(0) vec4<f32> {\n\n    var maskClamp = filterUniforms.uMaskClamp;\n    var uAlpha = filterUniforms.uAlpha;\n\n    var clip = step(3.5,\n      step(maskClamp.x, filterUv.x) +\n      step(maskClamp.y, filterUv.y) +\n      step(filterUv.x, maskClamp.z) +\n      step(filterUv.y, maskClamp.w));\n\n    var mask = textureSample(uMaskTexture, uSampler, filterUv);\n    var source = textureSample(uTexture, uSampler, uv);\n    var alphaMul = 1.0 - uAlpha * (1.0 - mask.a);\n\n    var a: f32 = alphaMul * mask.r * uAlpha * clip;\n\n    if (filterUniforms.uInverse == 1.0) {\n        a = 1.0 - a;\n    }\n\n    return source * a;\n}\n"; class fh extends ii { constructor(t) { const { sprite: s, ...e } = t, i = new K(s.texture), n = new Ye({ uFilterMatrix: { value: new w, type: "mat3x3<f32>" }, uMaskClamp: { value: i.uClampFrame, type: "vec4<f32>" }, uAlpha: { value: 1, type: "f32" }, uInverse: { value: t.inverse ? 1 : 0, type: "f32" } }); super({ ...e, gpuProgram: Ne.from({ vertex: { source: ch, entryPoint: "mainVertex" }, fragment: { source: ch, entryPoint: "mainFragment" } }), glProgram: $e.from({ vertex: "in vec2 aPosition;\n\nout vec2 vTextureCoord;\nout vec2 vMaskCoord;\n\n\nuniform vec4 uInputSize;\nuniform vec4 uOutputFrame;\nuniform vec4 uOutputTexture;\nuniform mat3 uFilterMatrix;\n\nvec4 filterVertexPosition(  vec2 aPosition )\n{\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\n       \n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord(  vec2 aPosition )\n{\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\n}\n\nvec2 getFilterCoord( vec2 aPosition )\n{\n    return  ( uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\n}   \n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition(aPosition);\n    vTextureCoord = filterTextureCoord(aPosition);\n    vMaskCoord = getFilterCoord(aPosition);\n}\n", fragment: "in vec2 vMaskCoord;\nin vec2 vTextureCoord;\n\nuniform sampler2D uTexture;\nuniform sampler2D uMaskTexture;\n\nuniform float uAlpha;\nuniform vec4 uMaskClamp;\nuniform float uInverse;\n\nout vec4 finalColor;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(uMaskClamp.x, vMaskCoord.x) +\n        step(uMaskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, uMaskClamp.z) +\n        step(vMaskCoord.y, uMaskClamp.w));\n\n    // TODO look into why this is needed\n    float npmAlpha = uAlpha;\n    vec4 original = texture(uTexture, vTextureCoord);\n    vec4 masky = texture(uMaskTexture, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    float a = alphaMul * masky.r * npmAlpha * clip;\n\n    if (uInverse == 1.0) {\n        a = 1.0 - a;\n    }\n\n    finalColor = original * a;\n}\n", name: "mask-filter" }), clipToViewport: !1, resources: { filterUniforms: n, uMaskTexture: s.texture.source } }), this.sprite = s, this.Z = i } set inverse(t) { this.resources.filterUniforms.uniforms.uInverse = t ? 1 : 0 } get inverse() { return 1 === this.resources.filterUniforms.uniforms.uInverse } apply(t, s, e, i) { this.Z.texture = this.sprite.texture, t.calculateSpriteMatrix(this.resources.filterUniforms.uniforms.uFilterMatrix, this.sprite).prepend(this.Z.mapCoord), this.resources.uMaskTexture = this.sprite.texture.source, t.applyFilter(this, s, e, i) } } class dh extends xs { constructor(t) { t instanceof Io && (t = { context: t }); const { context: s, roundPixels: e, ...i } = t || {}; super({ label: "Graphics", ...i }), this.renderPipeId = "graphics", this.Cs = s || (this.Vo = new Io), this.Cs.on("update", this.onViewUpdate, this), this.didViewUpdate = !0, this.allowChildren = !1, this.roundPixels = e ?? !1 } set context(t) { t !== this.Cs && (this.Cs.off("update", this.onViewUpdate, this), this.Cs = t, this.Cs.on("update", this.onViewUpdate, this), this.onViewUpdate()) } get context() { return this.Cs } get bounds() { return this.Cs.bounds } updateBounds() { } containsPoint(t) { return this.Cs.containsPoint(t) } destroy(t) { this.Vo && !t ? this.Vo.destroy(t) : !0 !== t && !0 !== t?.context || this.Cs.destroy(t), this.Vo = null, this.Cs = null, super.destroy(t) } No(t, s) { return this.context[t](...s), this } setFillStyle(...t) { return this.No("setFillStyle", t) } setStrokeStyle(...t) { return this.No("setStrokeStyle", t) } fill(...t) { return this.No("fill", t) } stroke(...t) { return this.No("stroke", t) } texture(...t) { return this.No("texture", t) } beginPath() { return this.No("beginPath", []) } cut() { return this.No("cut", []) } arc(...t) { return this.No("arc", t) } arcTo(...t) { return this.No("arcTo", t) } arcToSvg(...t) { return this.No("arcToSvg", t) } bezierCurveTo(...t) { return this.No("bezierCurveTo", t) } closePath() { return this.No("closePath", []) } ellipse(...t) { return this.No("ellipse", t) } circle(...t) { return this.No("circle", t) } path(...t) { return this.No("path", t) } lineTo(...t) { return this.No("lineTo", t) } moveTo(...t) { return this.No("moveTo", t) } quadraticCurveTo(...t) { return this.No("quadraticCurveTo", t) } rect(...t) { return this.No("rect", t) } roundRect(...t) { return this.No("roundRect", t) } poly(...t) { return this.No("poly", t) } regularPoly(...t) { return this.No("regularPoly", t) } roundPoly(...t) { return this.No("roundPoly", t) } roundShape(...t) { return this.No("roundShape", t) } filletRect(...t) { return this.No("filletRect", t) } chamferRect(...t) { return this.No("chamferRect", t) } star(...t) { return this.No("star", t) } svg(...t) { return this.No("svg", t) } restore(...t) { return this.No("restore", t) } save() { return this.No("save", []) } getTransform() { return this.context.getTransform() } resetTransform() { return this.No("resetTransform", []) } rotateTransform(...t) { return this.No("rotate", t) } scaleTransform(...t) { return this.No("scale", t) } setTransform(...t) { return this.No("setTransform", t) } transform(...t) { return this.No("transform", t) } translateTransform(...t) { return this.No("translate", t) } clear() { return this.No("clear", []) } get fillStyle() { return this.Cs.fillStyle } set fillStyle(t) { this.Cs.fillStyle = t } get strokeStyle() { return this.Cs.strokeStyle } set strokeStyle(t) { this.Cs.strokeStyle = t } clone(t = !1) { return t ? new dh(this.Cs.clone()) : (this.Vo = null, new dh(this.Cs)) } lineStyle(t, s, e) { G(0, "Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style."); const i = {}; return t && (i.width = t), s && (i.color = s), e && (i.alpha = e), this.context.strokeStyle = i, this } beginFill(t, s) { G(0, "Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style."); const e = {}; return void 0 !== t && (e.color = t), void 0 !== s && (e.alpha = s), this.context.fillStyle = e, this } endFill() { G(0, "Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style."), this.context.fill(); const t = this.context.strokeStyle; return t.width === Io.defaultStrokeStyle.width && t.color === Io.defaultStrokeStyle.color && t.alpha === Io.defaultStrokeStyle.alpha || this.context.stroke(), this } drawCircle(...t) { return G(0, "Graphics#drawCircle has been renamed to Graphics#circle"), this.No("circle", t) } drawEllipse(...t) { return G(0, "Graphics#drawEllipse has been renamed to Graphics#ellipse"), this.No("ellipse", t) } drawPolygon(...t) { return G(0, "Graphics#drawPolygon has been renamed to Graphics#poly"), this.No("poly", t) } drawRect(...t) { return G(0, "Graphics#drawRect has been renamed to Graphics#rect"), this.No("rect", t) } drawRoundedRect(...t) { return G(0, "Graphics#drawRoundedRect has been renamed to Graphics#roundRect"), this.No("roundRect", t) } drawStar(...t) { return G(0, "Graphics#drawStar has been renamed to Graphics#star"), this.No("star", t) } } const ph = class t extends Wn { constructor(...s) { let e = s[0] ?? {}; e instanceof Float32Array && (G(0, "use new MeshGeometry({ positions, uvs, indices }) instead"), e = { positions: e, uvs: s[1], indices: s[2] }), e = { ...t.defaultOptions, ...e }; const i = e.positions || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]); let n = e.uvs; n || (n = e.positions ? new Float32Array(i.length) : new Float32Array([0, 0, 1, 0, 1, 1, 0, 1])); const r = e.indices || new Uint32Array([0, 1, 2, 0, 2, 3]), o = e.shrinkBuffersToFit; super({ attributes: { aPosition: { buffer: new Vn({ data: i, label: "attribute-mesh-positions", shrinkToFit: o, usage: Ln.VERTEX | Ln.COPY_DST }), format: "float32x2", stride: 8, offset: 0 }, aUV: { buffer: new Vn({ data: n, label: "attribute-mesh-uvs", shrinkToFit: o, usage: Ln.VERTEX | Ln.COPY_DST }), format: "float32x2", stride: 8, offset: 0 } }, indexBuffer: new Vn({ data: r, label: "index-mesh-buffer", shrinkToFit: o, usage: Ln.INDEX | Ln.COPY_DST }), topology: e.topology }), this.batchMode = "auto" } get positions() { return this.attributes.aPosition.buffer.data } set positions(t) { this.attributes.aPosition.buffer.data = t } get uvs() { return this.attributes.aUV.buffer.data } set uvs(t) { this.attributes.aUV.buffer.data = t } get indices() { return this.indexBuffer.data } set indices(t) { this.indexBuffer.data = t } }; ph.defaultOptions = { topology: "triangle-list", shrinkBuffersToFit: !1 }; let mh = ph; class gh extends xs { constructor(t, s) { const { text: e, resolution: i, style: n, anchor: r, width: o, height: h, roundPixels: a, ...l } = t; super({ ...l }), this.batched = !0, this.$ = null, this.Wo = !0, this.Ho = !0, this.qo = s, this.text = e ?? "", this.style = n, this.resolution = i ?? null, this.allowChildren = !1, this.xs = new c({ C: () => { this.onViewUpdate() } }), r && (this.anchor = r), this.roundPixels = a ?? !1, void 0 !== o && (this.width = o), void 0 !== h && (this.height = h) } get anchor() { return this.xs } set anchor(t) { "number" == typeof t ? this.xs.set(t) : this.xs.copyFrom(t) } set text(t) { t = t.toString(), this.Xo !== t && (this.Xo = t, this.onViewUpdate()) } get text() { return this.Xo } set resolution(t) { this.Wo = null === t, this.$ = t, this.onViewUpdate() } get resolution() { return this.$ } get style() { return this.L } set style(t) { t || (t = {}), this.L?.off("update", this.onViewUpdate, this), t instanceof this.qo ? this.L = t : this.L = new this.qo(t), this.L.on("update", this.onViewUpdate, this), this.onViewUpdate() } get width() { return Math.abs(this.scale.x) * this.bounds.width } set width(t) { this.Ut(t, this.bounds.width) } get height() { return Math.abs(this.scale.y) * this.bounds.height } set height(t) { this.It(t, this.bounds.height) } getSize(t) { return t || (t = {}), t.width = Math.abs(this.scale.x) * this.bounds.width, t.height = Math.abs(this.scale.y) * this.bounds.height, t } setSize(t, s) { "object" == typeof t ? (s = t.height ?? t.width, t = t.width) : s ?? (s = t), void 0 !== t && this.Ut(t, this.bounds.width), void 0 !== s && this.It(s, this.bounds.height) } containsPoint(t) { const s = this.bounds.width, e = this.bounds.height, i = -s * this.anchor.x; let n = 0; return t.x >= i && t.x <= i + s && (n = -e * this.anchor.y, t.y >= n && t.y <= n + e) } onViewUpdate() { this.didViewUpdate || (this.Ho = !0), super.onViewUpdate() } destroy(t = !1) { super.destroy(t), this.owner = null, this.gs = null, this.xs = null, ("boolean" == typeof t ? t : t?.style) && this.L.destroy(t), this.L = null, this.Xo = null } get styleKey() { return `${this.Xo}:${this.L.styleKey}:${this.$}` } } let vh = null, bh = null; function xh(t, s, e) { for (let i = 0, n = 4 * e * s; i < s; ++i, n += 4)if (0 !== t[n + 3]) return !1; return !0 } function yh(t, s, e, i, n) { const r = 4 * s; for (let o = i, h = i * r + 4 * e; o <= n; ++o, h += r)if (0 !== t[h + 3]) return !1; return !0 } function wh(...t) { let s = t[0]; s.canvas || (s = { canvas: t[0], resolution: t[1] }); const { canvas: e } = s, i = Math.min(s.resolution ?? 1, 1), n = s.width ?? e.width, r = s.height ?? e.height; let o = s.output; if (function (t, s) { vh || (vh = ks.get().createCanvas(256, 128), bh = vh.getContext("2d", { willReadFrequently: !0 }), bh.globalCompositeOperation = "copy", bh.globalAlpha = 1), (vh.width < t || vh.height < s) && (vh.width = D(t), vh.height = D(s)) }(n, r), !bh) throw new TypeError("Failed to get canvas 2D context"); bh.drawImage(e, 0, 0, n, r, 0, 0, n * i, r * i); const h = bh.getImageData(0, 0, n, r).data; let a = 0, l = 0, u = n - 1, c = r - 1; for (; l < r && xh(h, n, l);)++l; if (l === r) return O.EMPTY; for (; xh(h, n, c);)--c; for (; yh(h, n, a, l, c);)++a; for (; yh(h, n, u, l, c);)--u; return ++u, ++c, bh.globalCompositeOperation = "source-over", bh.strokeRect(a, l, u - a, c - l), bh.globalCompositeOperation = "copy", o ?? (o = new O), o.set(a / i, l / i, (u - a) / i, (c - l) / i), o } const Mh = new O, Th = new class { getCanvasAndContext(t) { const { text: s, style: e, resolution: i = 1 } = t, n = e.Er(), r = rn.measureText(s || " ", e), o = Math.ceil(Math.ceil(Math.max(1, r.width) + 2 * n) * i), h = Math.ceil(Math.ceil(Math.max(1, r.height) + 2 * n) * i), a = Go.getOptimalCanvasAndContext(o, h); return this.Yo(s, e, n, i, a), { canvasAndContext: a, frame: e.trim ? wh({ canvas: a.canvas, width: o, height: h, resolution: 1, output: Mh }) : Mh.set(0, 0, o, h) } } returnCanvasAndContext(t) { Go.returnCanvasAndContext(t) } Yo(t, s, e, i, n) { const { canvas: r, context: o } = n, h = sn(s), a = rn.measureText(t || " ", s), l = a.lines, u = a.lineHeight, c = a.lineWidths, f = a.maxLineWidth, d = a.fontProperties, p = r.height; if (o.resetTransform(), o.scale(i, i), o.textBaseline = s.textBaseline, s.ln?.width) { const t = s.ln; o.lineWidth = t.width, o.miterLimit = t.miterLimit, o.lineJoin = t.join, o.lineCap = t.cap } let m, g; o.font = h; const v = s.dropShadow ? 2 : 1; for (let b = 0; b < v; ++b) { const t = s.dropShadow && 0 === b, r = t ? Math.ceil(Math.max(1, p) + 2 * e) : 0, h = r * i; if (t) { o.fillStyle = "black", o.strokeStyle = "black"; const t = s.dropShadow, e = t.color, n = t.alpha; o.shadowColor = kt.shared.setValue(e).setAlpha(n).toRgbaString(); const r = t.blur * i, a = t.distance * i; o.shadowBlur = r, o.shadowOffsetX = Math.cos(t.angle) * a, o.shadowOffsetY = Math.sin(t.angle) * a + h } else { if (o.fillStyle = s.kr ? Do(s.kr, o, a, 2 * e) : null, s.ln?.width) { const t = .5 * s.ln.width + 2 * e; o.strokeStyle = Do(s.ln, o, a, t) } o.shadowColor = "black" } let v = (u - d.fontSize) / 2; u - d.fontSize < 0 && (v = 0); const x = s.ln?.width ?? 0; for (let i = 0; i < l.length; i++)m = x / 2, g = x / 2 + i * u + d.ascent + v, "right" === s.align ? m += f - c[i] : "center" === s.align && (m += (f - c[i]) / 2), s.ln?.width && this.Ko(l[i], s, n, m + e, g + e - r, !0), void 0 !== s.kr && this.Ko(l[i], s, n, m + e, g + e - r) } } Ko(t, s, e, i, n, r = !1) { const { context: o } = e, h = s.letterSpacing; let a = !1; if (rn.experimentalLetterSpacingSupported && (rn.experimentalLetterSpacing ? (o.letterSpacing = `${h}px`, o.textLetterSpacing = `${h}px`, a = !0) : (o.letterSpacing = "0px", o.textLetterSpacing = "0px")), 0 === h || a) return void (r ? o.strokeText(t, i, n) : o.fillText(t, i, n)); let l = i; const u = rn.graphemeSegmenter(t); let c = o.measureText(t).width, f = 0; for (let d = 0; d < u.length; ++d) { const t = u[d]; r ? o.strokeText(t, l, n) : o.fillText(t, l, n); let s = ""; for (let e = d + 1; e < u.length; ++e)s += u[e]; f = o.measureText(s).width, l += c - f + h, c = f } } }; class Ah extends gh { constructor(...t) { const s = function (t) { let s = t[0] ?? {}; return ("string" == typeof s || t[1]) && (G(0, 'use new Text({ text: "hi!", style }) instead'), s = { text: s, style: t[1] }), s }(t); super(s, $o), this.renderPipeId = "text", s.textureStyle && (this.textureStyle = s.textureStyle instanceof W ? s.textureStyle : new W(s.textureStyle)) } updateBounds() { const t = this.gs, s = this.xs; let e = 0, i = 0; if (this.L.trim) { const { frame: t, canvasAndContext: s } = Th.getCanvasAndContext({ text: this.text, style: this.L, resolution: 1 }); Th.returnCanvasAndContext(s), e = t.width, i = t.height } else { const t = rn.measureText(this.Xo, this.L); e = t.width, i = t.height } t.minX = -s.M * e, t.maxX = t.minX + e, t.minY = -s.T * i, t.maxY = t.minY + i } } const Ch = "http://www.w3.org/2000/svg", _h = "http://www.w3.org/1999/xhtml"; class Sh { constructor() { this.svgRoot = document.createElementNS(Ch, "svg"), this.foreignObject = document.createElementNS(Ch, "foreignObject"), this.domElement = document.createElementNS(_h, "div"), this.styleElement = document.createElementNS(_h, "style"); const { foreignObject: t, svgRoot: s, styleElement: e, domElement: i } = this; t.setAttribute("width", "10000"), t.setAttribute("height", "10000"), t.style.overflow = "hidden", s.appendChild(t), t.appendChild(e), t.appendChild(i), this.image = ks.get().createImage() } destroy() { this.svgRoot.remove(), this.foreignObject.remove(), this.styleElement.remove(), this.domElement.remove(), this.image.src = "", this.image.remove(), this.svgRoot = null, this.foreignObject = null, this.styleElement = null, this.domElement = null, this.image = null, this.canvasAndContext = null } } let Ph; class kh { constructor() { this.Zo = si.for2d(), this.Qo = {} } init(t) { t.renderer.runners.contextChange.add(this) } contextChange() { this.Qo = {} } start(t, s, e) { const i = t.renderer, n = this.Qo[e.uid]; i.shader.bind(e, n), n || (this.Qo[e.uid] = !0), i.shader.updateUniformGroup(i.globalUniforms.uniformGroup), i.geometry.bind(s, e.glProgram) } execute(t, s) { const e = t.renderer; this.Zo.blendMode = s.blendMode, e.state.set(this.Zo); const i = s.textures.textures; for (let n = 0; n < s.textures.count; n++)e.texture.bind(i[n], n); e.geometry.draw(s.topology, s.size, s.start) } } kh.extension = { type: [r.WebGLPipesAdaptor], name: "batch" }; const Fh = si.for2d(); class Eh { start(t, s, e) { const i = t.renderer, n = i.encoder, r = e.gpuProgram; this.Jo = e, this.th = s, n.setGeometry(s, r), Fh.blendMode = "normal", i.pipeline.getPipeline(s, r, Fh); const o = i.globalUniforms.bindGroup; n.resetBindGroup(1), n.setBindGroup(0, o, r) } execute(t, s) { const e = this.Jo.gpuProgram, i = t.renderer, n = i.encoder; if (!s.bindGroup) { const t = s.textures; s.bindGroup = Tn(t.textures, t.count, i.limits.maxBatchableTextures) } Fh.blendMode = s.blendMode; const r = i.bindGroup.getBindGroup(s.bindGroup, e, 1), o = i.pipeline.getPipeline(this.th, e, Fh, s.topology); s.bindGroup.Ui(i.textureGC.count), n.setPipeline(o), n.renderPassEncoder.setBindGroup(1, r), n.renderPassEncoder.drawIndexed(s.size, 1, s.start) } } Eh.extension = { type: [r.WebGPUPipesAdaptor], name: "batch" }; const Rh = class t { constructor(t, s) { this.state = si.for2d(), this.sh = Object.create(null), this.eh = Object.create(null), this.renderer = t, this.ih = s, this.ih.init?.(this) } static getBatcher(t) { return new this.nh[t] } buildStart(t) { let s = this.sh[t.uid]; s || (s = this.sh[t.uid] = Object.create(null), s.default || (s.default = new Pr({ maxTextures: this.renderer.limits.maxBatchableTextures }))), this.eh = s, this.rh = this.eh.default; for (const e in this.eh) this.eh[e].begin() } addToBatch(s, e) { if (this.rh.name !== s.batcherName) { this.rh.break(e); let i = this.eh[s.batcherName]; i || (i = this.eh[s.batcherName] = t.getBatcher(s.batcherName), i.begin()), this.rh = i } this.rh.add(s) } break(t) { this.rh.break(t) } buildEnd(t) { this.rh.break(t); const s = this.eh; for (const e in s) { const t = s[e], i = t.geometry; i.indexBuffer.setDataWithSize(t.indexBuffer, t.indexSize, !0), i.buffers[0].setDataWithSize(t.attributeBuffer.float32View, t.attributeSize, !1) } } upload(t) { const s = this.sh[t.uid]; for (const e in s) { const t = s[e], i = t.geometry; t.dirty && (t.dirty = !1, i.buffers[0].update(4 * t.attributeSize)) } } execute(t) { if ("startBatch" === t.action) { const s = t.batcher, e = s.geometry, i = s.shader; this.ih.start(this, e, i) } this.ih.execute(this, t) } destroy() { this.state = null, this.renderer = null, this.ih = null; for (const t in this.eh) this.eh[t].destroy(); this.eh = null } }; Rh.extension = { type: [r.WebGLPipes, r.WebGPUPipes, r.CanvasPipes], name: "batch" }, Rh.nh = Object.create(null); let Oh = Rh; a.handleByMap(r.Batcher, Oh.nh), a.add(Pr); const Uh = { name: "local-uniform-bit", vertex: { header: "\n\n            struct LocalUniforms {\n                uTransformMatrix:mat3x3<f32>,\n                uColor:vec4<f32>,\n                uRound:f32,\n            }\n\n            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        ", main: "\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        ", end: "\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        " } }, Ih = { ...Uh, vertex: { ...Uh.vertex, header: Uh.vertex.header.replace("group(1)", "group(2)") } }, Bh = { name: "local-uniform-bit", vertex: { header: "\n\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        ", main: "\n            vColor *= uColor;\n            modelMatrix = uTransformMatrix;\n        ", end: "\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        " } }, $h = { name: "texture-bit", vertex: { header: "\n\n        struct TextureUniforms {\n            uTextureMatrix:mat3x3<f32>,\n        }\n\n        @group(2) @binding(2) var<uniform> textureUniforms : TextureUniforms;\n        ", main: "\n            uv = (textureUniforms.uTextureMatrix * vec3(uv, 1.0)).xy;\n        " }, fragment: { header: "\n            @group(2) @binding(0) var uTexture: texture_2d<f32>;\n            @group(2) @binding(1) var uSampler: sampler;\n\n\n        ", main: "\n            outColor = textureSample(uTexture, uSampler, vUV);\n        " } }, Gh = { name: "texture-bit", vertex: { header: "\n            uniform mat3 uTextureMatrix;\n        ", main: "\n            uv = (uTextureMatrix * vec3(uv, 1.0)).xy;\n        " }, fragment: { header: "\n        uniform sampler2D uTexture;\n\n\n        ", main: "\n            outColor = texture(uTexture, vUV);\n        " } }, zh = new tt; class Dh extends zt { constructor() { super(), this.filters = [new fh({ sprite: new ys(Z.EMPTY), inverse: !1, resolution: "inherit", antialias: "inherit" })] } get sprite() { return this.filters[0].sprite } set sprite(t) { this.filters[0].sprite = t } get inverse() { return this.filters[0].inverse } set inverse(t) { this.filters[0].inverse = t } } class jh { constructor(t) { this.oh = [], this.Be = t } push(t, s, e) { const i = this.Be; if (i.renderPipes.batch.break(e), e.add({ renderPipeId: "alphaMask", action: "pushMaskBegin", mask: t, inverse: s.St.inverse, canBundle: !1, maskedContainer: s }), t.inverse = s.St.inverse, t.renderMaskToTexture) { const s = t.mask; s.includeInBuild = !0, s.collectRenderables(e, i, null), s.includeInBuild = !1 } i.renderPipes.batch.break(e), e.add({ renderPipeId: "alphaMask", action: "pushMaskEnd", mask: t, maskedContainer: s, inverse: s.St.inverse, canBundle: !1 }) } pop(t, s, e) { this.Be.renderPipes.batch.break(e), e.add({ renderPipeId: "alphaMask", action: "popMaskEnd", mask: t, inverse: s.St.inverse, canBundle: !1 }) } execute(t) { const s = this.Be, e = t.mask.renderMaskToTexture; if ("pushMaskBegin" === t.action) { const i = Ut.get(Dh); if (i.inverse = t.inverse, e) { t.mask.mask.measurable = !0; const e = qt(t.mask.mask, !0, zh); t.mask.mask.measurable = !1, e.ceil(); const n = s.renderTarget.renderTarget.colorTexture.source, r = fs.getOptimalTexture(e.width, e.height, n.$, n.antialias); s.renderTarget.push(r, !0), s.globalUniforms.push({ offset: e, worldColor: 4294967295 }); const o = i.sprite; o.texture = r, o.worldTransform.tx = e.minX, o.worldTransform.ty = e.minY, this.oh.push({ filterEffect: i, maskedContainer: t.maskedContainer, filterTexture: r }) } else i.sprite = t.mask.mask, this.oh.push({ filterEffect: i, maskedContainer: t.maskedContainer }) } else if ("pushMaskEnd" === t.action) { const t = this.oh[this.oh.length - 1]; e && (s.type === Ze.WEBGL && s.renderTarget.finishRenderPass(), s.renderTarget.pop(), s.globalUniforms.pop()), s.filter.push({ renderPipeId: "filter", action: "pushFilter", container: t.maskedContainer, filterEffect: t.filterEffect, canBundle: !1 }) } else if ("popMaskEnd" === t.action) { s.filter.pop(); const t = this.oh.pop(); e && fs.returnTexture(t.filterTexture), Ut.return(t.filterEffect) } } destroy() { this.Be = null, this.oh = null } } jh.extension = { type: [r.WebGLPipes, r.WebGPUPipes, r.CanvasPipes], name: "alphaMask" }; class Lh { constructor(t) { this.hh = [], this.ah = 0, this.uh = 0, this.Be = t } buildStart() { this.hh[0] = 15, this.ah = 1, this.uh = 15 } push(t, s, e) { this.Be.renderPipes.batch.break(e); const i = this.hh; i[this.ah] = i[this.ah - 1] & t.mask; const n = this.hh[this.ah]; n !== this.uh && (this.uh = n, e.add({ renderPipeId: "colorMask", colorMask: n, canBundle: !1 })), this.ah++ } pop(t, s, e) { this.Be.renderPipes.batch.break(e); const i = this.hh; this.ah--; const n = i[this.ah - 1]; n !== this.uh && (this.uh = n, e.add({ renderPipeId: "colorMask", colorMask: n, canBundle: !1 })) } execute(t) { this.Be.colorMask.setMask(t.colorMask) } destroy() { this.Be = null, this.hh = null } } Lh.extension = { type: [r.WebGLPipes, r.WebGPUPipes, r.CanvasPipes], name: "colorMask" }; class Vh { constructor(t) { this.fh = {}, this.ph = new WeakMap, this.Be = t } push(t, s, e) { var i; const n = t, r = this.Be; r.renderPipes.batch.break(e), r.renderPipes.blendMode.setBlendMode(n.mask, "none", e), e.add({ renderPipeId: "stencilMask", action: "pushMaskBegin", mask: t, inverse: s.St.inverse, canBundle: !1 }); const o = n.mask; o.includeInBuild = !0, this.ph.has(n) || this.ph.set(n, { instructionsStart: 0, instructionsLength: 0 }); const h = this.ph.get(n); h.instructionsStart = e.instructionSize, o.collectRenderables(e, r, null), o.includeInBuild = !1, r.renderPipes.batch.break(e), e.add({ renderPipeId: "stencilMask", action: "pushMaskEnd", mask: t, inverse: s.St.inverse, canBundle: !1 }); const a = e.instructionSize - h.instructionsStart - 1; h.instructionsLength = a; const l = r.renderTarget.renderTarget.uid; (i = this.fh)[l] ?? (i[l] = 0) } pop(t, s, e) { const i = t, n = this.Be; n.renderPipes.batch.break(e), n.renderPipes.blendMode.setBlendMode(i.mask, "none", e), e.add({ renderPipeId: "stencilMask", action: "popMaskBegin", inverse: s.St.inverse, canBundle: !1 }); const r = this.ph.get(t); for (let o = 0; o < r.instructionsLength; o++)e.instructions[e.instructionSize++] = e.instructions[r.instructionsStart++]; e.add({ renderPipeId: "stencilMask", action: "popMaskEnd", canBundle: !1 }) } execute(t) { var s; const e = this.Be, i = e.renderTarget.renderTarget.uid; let n = (s = this.fh)[i] ?? (s[i] = 0); "pushMaskBegin" === t.action ? (e.renderTarget.ensureDepthStencil(), e.stencil.setStencilMode(Sn.RENDERING_MASK_ADD, n), n++, e.colorMask.setMask(0)) : "pushMaskEnd" === t.action ? (t.inverse ? e.stencil.setStencilMode(Sn.INVERSE_MASK_ACTIVE, n) : e.stencil.setStencilMode(Sn.MASK_ACTIVE, n), e.colorMask.setMask(15)) : "popMaskBegin" === t.action ? (e.colorMask.setMask(0), 0 !== n ? e.stencil.setStencilMode(Sn.RENDERING_MASK_REMOVE, n) : (e.renderTarget.clear(null, Ui.STENCIL), e.stencil.setStencilMode(Sn.DISABLED, n)), n--) : "popMaskEnd" === t.action && (t.inverse ? e.stencil.setStencilMode(Sn.INVERSE_MASK_ACTIVE, n) : e.stencil.setStencilMode(Sn.MASK_ACTIVE, n), e.colorMask.setMask(15)), this.fh[i] = n } destroy() { this.Be = null, this.fh = null, this.ph = null } } Vh.extension = { type: [r.WebGLPipes, r.WebGPUPipes, r.CanvasPipes], name: "stencilMask" }; var Nh = (t => (t[t.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", t[t.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", t[t.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER", t))(Nh || {}); class Wh { constructor(t, s) { this.mh = -1, this.gh = -1, this.buffer = t || null, this.updateID = -1, this.byteLength = -1, this.type = s } } class Hh { constructor(t) { this.bh = Object.create(null), this.xh = Object.create(null), this.yh = 0, this.wh = this.yh, this.Mh = 0, this.Be = t, this.Be.renderableGC.addManagedHash(this, "_gpuBuffers") } destroy() { this.destroyAll(), this.Be = null, this.Th = null, this.bh = {}, this.xh = {} } contextChange() { this.Th = this.Be.gl, this.bh = Object.create(null), this.Ah = this.Be.limits.maxUniformBindings } getGlBuffer(t) { return this.bh[t.uid] || this.createGLBuffer(t) } bind(t) { const { Th: s } = this, e = this.getGlBuffer(t); s.bindBuffer(e.type, e.buffer) } bindBufferBase(t, s) { const { Th: e } = this; this.xh[s] !== t && (this.xh[s] = t, t.mh = s, e.bindBufferBase(e.UNIFORM_BUFFER, s, t.buffer)) } nextBindBase(t) { this.Mh++, this.yh = 0, t && (this.xh[0] = null, this.yh = 1, this.wh < 1 && (this.wh = 1)) } freeLocationForBufferBase(t) { let s = this.getLastBindBaseLocation(t); if (s >= this.yh) return t.gh = this.Mh, s; let e = 0, i = this.wh; for (; e < 2;) { i >= this.Ah && (i = this.yh, e++); const t = this.xh[i]; if (!t || t.gh !== this.Mh) break; i++ } return s = i, this.wh = i + 1, e >= 2 ? -1 : (t.gh = this.Mh, this.xh[s] = null, s) } getLastBindBaseLocation(t) { const s = t.mh; return this.xh[s] === t ? s : -1 } bindBufferRange(t, s, e, i) { const { Th: n } = this; e || (e = 0), s || (s = 0), this.xh[s] = null, n.bindBufferRange(n.UNIFORM_BUFFER, s || 0, t.buffer, 256 * e, i || 256) } updateBuffer(t) { const { Th: s } = this, e = this.getGlBuffer(t); if (t.X === e.updateID) return e; e.updateID = t.X, s.bindBuffer(e.type, e.buffer); const i = t.data, n = t.descriptor.usage & Ln.STATIC ? s.STATIC_DRAW : s.DYNAMIC_DRAW; return i ? e.byteLength >= i.byteLength ? s.bufferSubData(e.type, 0, i, 0, t.Vn / i.BYTES_PER_ELEMENT) : (e.byteLength = i.byteLength, s.bufferData(e.type, i, n)) : (e.byteLength = t.descriptor.size, s.bufferData(e.type, e.byteLength, n)), e } destroyAll() { const t = this.Th; for (const s in this.bh) this.bh[s] && t.deleteBuffer(this.bh[s].buffer); this.bh = Object.create(null) } onBufferDestroy(t, s) { if (!this.bh[t.uid]) return; const e = this.bh[t.uid], i = this.Th; s || i.deleteBuffer(e.buffer), t.off("destroy", this.onBufferDestroy, this), this.bh[t.uid] = null } createGLBuffer(t) { const { Th: s } = this; let e = Nh.ARRAY_BUFFER; t.descriptor.usage & Ln.INDEX ? e = Nh.ELEMENT_ARRAY_BUFFER : t.descriptor.usage & Ln.UNIFORM && (e = Nh.UNIFORM_BUFFER); const i = new Wh(s.createBuffer(), e); return this.bh[t.uid] = i, t.on("destroy", this.onBufferDestroy, this), i } resetState() { this.xh = Object.create(null) } } Hh.extension = { type: [r.WebGLSystem], name: "buffer" }; const qh = class t { constructor(t) { this.supports = { uint32Indices: !0, uniformBufferObject: !0, vertexArrayObject: !0, srgbTextures: !0, nonPowOf2wrapping: !0, msaa: !0, nonPowOf2mipmaps: !0 }, this.Be = t, this.extensions = Object.create(null), this.handleContextLost = this.handleContextLost.bind(this), this.handleContextRestored = this.handleContextRestored.bind(this) } get isLost() { return !this.gl || this.gl.isContextLost() } contextChange(t) { this.gl = t, this.Be.gl = t } init(s) { s = { ...t.defaultOptions, ...s }; let e = this.multiView = s.multiView; if (s.context && e && (Et(), e = !1), this.canvas = e ? ks.get().createCanvas(this.Be.canvas.width, this.Be.canvas.height) : this.Be.view.canvas, s.context) this.initFromContext(s.context); else { const t = this.Be.background.alpha < 1, e = s.premultipliedAlpha ?? !0, i = s.antialias && !this.Be.backBuffer.useBackBuffer; this.createContext(s.preferWebGLVersion, { alpha: t, premultipliedAlpha: e, antialias: i, stencil: !0, preserveDrawingBuffer: s.preserveDrawingBuffer, powerPreference: s.powerPreference ?? "default" }) } } ensureCanvasSize(t) { if (!this.multiView) return void (t !== this.canvas && Et()); const { canvas: s } = this; (s.width < t.width || s.height < t.height) && (s.width = Math.max(t.width, t.width), s.height = Math.max(t.height, t.height)) } initFromContext(t) { this.gl = t, this.webGLVersion = t instanceof ks.get().getWebGLRenderingContext() ? 1 : 2, this.getExtensions(), this.validateContext(t), this.Be.runners.contextChange.emit(t); const s = this.Be.view.canvas; s.addEventListener("webglcontextlost", this.handleContextLost, !1), s.addEventListener("webglcontextrestored", this.handleContextRestored, !1) } createContext(t, s) { let e; const i = this.canvas; if (2 === t && (e = i.getContext("webgl2", s)), !e && (e = i.getContext("webgl", s), !e)) throw new Error("This browser does not support WebGL. Try using the canvas renderer"); this.gl = e, this.initFromContext(this.gl) } getExtensions() { const { gl: t } = this, s = { anisotropicFiltering: t.getExtension("EXT_texture_filter_anisotropic"), floatTextureLinear: t.getExtension("OES_texture_float_linear"), s3tc: t.getExtension("WEBGL_compressed_texture_s3tc"), s3tc_sRGB: t.getExtension("WEBGL_compressed_texture_s3tc_srgb"), etc: t.getExtension("WEBGL_compressed_texture_etc"), etc1: t.getExtension("WEBGL_compressed_texture_etc1"), pvrtc: t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"), atc: t.getExtension("WEBGL_compressed_texture_atc"), astc: t.getExtension("WEBGL_compressed_texture_astc"), bptc: t.getExtension("EXT_texture_compression_bptc"), rgtc: t.getExtension("EXT_texture_compression_rgtc"), loseContext: t.getExtension("WEBGL_lose_context") }; if (1 === this.webGLVersion) this.extensions = { ...s, drawBuffers: t.getExtension("WEBGL_draw_buffers"), depthTexture: t.getExtension("WEBGL_depth_texture"), vertexArrayObject: t.getExtension("OES_vertex_array_object") || t.getExtension("MOZ_OES_vertex_array_object") || t.getExtension("WEBKIT_OES_vertex_array_object"), uint32ElementIndex: t.getExtension("OES_element_index_uint"), floatTexture: t.getExtension("OES_texture_float"), floatTextureLinear: t.getExtension("OES_texture_float_linear"), textureHalfFloat: t.getExtension("OES_texture_half_float"), textureHalfFloatLinear: t.getExtension("OES_texture_half_float_linear"), vertexAttribDivisorANGLE: t.getExtension("ANGLE_instanced_arrays"), srgb: t.getExtension("EXT_sRGB") }; else { this.extensions = { ...s, colorBufferFloat: t.getExtension("EXT_color_buffer_float") }; const e = t.getExtension("WEBGL_provoking_vertex"); e && e.provokingVertexWEBGL(e.FIRST_VERTEX_CONVENTION_WEBGL) } } handleContextLost(t) { t.preventDefault(), this.Ch && (this.Ch = !1, setTimeout(() => { this.gl.isContextLost() && this.extensions.loseContext?.restoreContext() }, 0)) } handleContextRestored() { this.getExtensions(), this.Be.runners.contextChange.emit(this.gl) } destroy() { const t = this.Be.view.canvas; this.Be = null, t.removeEventListener("webglcontextlost", this.handleContextLost), t.removeEventListener("webglcontextrestored", this.handleContextRestored), this.gl.useProgram(null), this.extensions.loseContext?.loseContext() } forceContextLoss() { this.extensions.loseContext?.loseContext(), this.Ch = !0 } validateContext(t) { const s = t.getContextAttributes(); s && !s.stencil && Et(); const e = this.supports, i = 2 === this.webGLVersion, n = this.extensions; e.uint32Indices = i || !!n.uint32ElementIndex, e.uniformBufferObject = i, e.vertexArrayObject = i || !!n.vertexArrayObject, e.srgbTextures = i || !!n.srgb, e.nonPowOf2wrapping = i, e.nonPowOf2mipmaps = i, e.msaa = i, e.uint32Indices || Et() } }; qh.extension = { type: [r.WebGLSystem], name: "context" }, qh.defaultOptions = { context: null, premultipliedAlpha: !0, preserveDrawingBuffer: !1, powerPreference: void 0, preferWebGLVersion: 2, multiView: !1 }; let Xh = qh; function Yh(t, s) { for (const e in t.attributes) { const i = t.attributes[e], n = s[e]; n ? (i.format ?? (i.format = n.format), i.offset ?? (i.offset = n.offset), i.instance ?? (i.instance = n.instance)) : Et() } !function (t) { const { buffers: s, attributes: e } = t, i = {}, n = {}; for (const r in s) { const t = s[r]; i[t.uid] = 0, n[t.uid] = 0 } for (const r in e) { const t = e[r]; i[t.buffer.uid] += ze(t.format).stride } for (const r in e) { const t = e[r]; t.stride ?? (t.stride = i[t.buffer.uid]), t.start ?? (t.start = n[t.buffer.uid]), n[t.buffer.uid] += ze(t.format).stride } }(t) } var Kh = (t => (t[t.RGBA = 6408] = "RGBA", t[t.RGB = 6407] = "RGB", t[t.RG = 33319] = "RG", t[t.RED = 6403] = "RED", t[t.RGBA_INTEGER = 36249] = "RGBA_INTEGER", t[t.RGB_INTEGER = 36248] = "RGB_INTEGER", t[t.RG_INTEGER = 33320] = "RG_INTEGER", t[t.RED_INTEGER = 36244] = "RED_INTEGER", t[t.ALPHA = 6406] = "ALPHA", t[t.LUMINANCE = 6409] = "LUMINANCE", t[t.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", t[t.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", t[t.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL", t))(Kh || {}), Zh = (t => (t[t.TEXTURE_2D = 3553] = "TEXTURE_2D", t[t.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", t[t.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", t[t.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", t[t.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", t[t.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", t[t.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", t[t.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", t[t.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z", t))(Zh || {}), Qh = (t => (t[t.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", t[t.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", t[t.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", t[t.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", t[t.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", t[t.UNSIGNED_INT = 5125] = "UNSIGNED_INT", t[t.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", t[t.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", t[t.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", t[t.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", t[t.BYTE = 5120] = "BYTE", t[t.SHORT = 5122] = "SHORT", t[t.INT = 5124] = "INT", t[t.FLOAT = 5126] = "FLOAT", t[t.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", t[t.HALF_FLOAT = 36193] = "HALF_FLOAT", t))(Qh || {}); const Jh = { uint8x2: Qh.UNSIGNED_BYTE, uint8x4: Qh.UNSIGNED_BYTE, sint8x2: Qh.BYTE, sint8x4: Qh.BYTE, unorm8x2: Qh.UNSIGNED_BYTE, unorm8x4: Qh.UNSIGNED_BYTE, snorm8x2: Qh.BYTE, snorm8x4: Qh.BYTE, uint16x2: Qh.UNSIGNED_SHORT, uint16x4: Qh.UNSIGNED_SHORT, sint16x2: Qh.SHORT, sint16x4: Qh.SHORT, unorm16x2: Qh.UNSIGNED_SHORT, unorm16x4: Qh.UNSIGNED_SHORT, snorm16x2: Qh.SHORT, snorm16x4: Qh.SHORT, float16x2: Qh.HALF_FLOAT, float16x4: Qh.HALF_FLOAT, float32: Qh.FLOAT, float32x2: Qh.FLOAT, float32x3: Qh.FLOAT, float32x4: Qh.FLOAT, uint32: Qh.UNSIGNED_INT, uint32x2: Qh.UNSIGNED_INT, uint32x3: Qh.UNSIGNED_INT, uint32x4: Qh.UNSIGNED_INT, sint32: Qh.INT, sint32x2: Qh.INT, sint32x3: Qh.INT, sint32x4: Qh.INT }; function ta(t) { return Jh[t] ?? Jh.float32 } const sa = { "point-list": 0, "line-list": 1, "line-strip": 3, "triangle-list": 4, "triangle-strip": 5 }; class ea { constructor(t) { this._h = Object.create(null), this.Be = t, this.Sh = null, this.Ph = null, this.hasVao = !0, this.hasInstance = !0, this.Be.renderableGC.addManagedHash(this, "_geometryVaoHash") } contextChange() { const t = this.gl = this.Be.gl; if (!this.Be.context.supports.vertexArrayObject) throw new Error("[PixiJS] Vertex Array Objects are not supported on this device"); const s = this.Be.context.extensions.vertexArrayObject; s && (t.createVertexArray = () => s.createVertexArrayOES(), t.bindVertexArray = t => s.bindVertexArrayOES(t), t.deleteVertexArray = t => s.deleteVertexArrayOES(t)); const e = this.Be.context.extensions.vertexAttribDivisorANGLE; e && (t.drawArraysInstanced = (t, s, i, n) => { e.drawArraysInstancedANGLE(t, s, i, n) }, t.drawElementsInstanced = (t, s, i, n, r) => { e.drawElementsInstancedANGLE(t, s, i, n, r) }, t.vertexAttribDivisor = (t, s) => e.vertexAttribDivisorANGLE(t, s)), this.Sh = null, this.Ph = null, this._h = Object.create(null) } bind(t, s) { const e = this.gl; this.Sh = t; const i = this.getVao(t, s); this.Ph !== i && (this.Ph = i, e.bindVertexArray(i)), this.updateBuffers() } resetState() { this.unbind() } updateBuffers() { const t = this.Sh, s = this.Be.buffer; for (let e = 0; e < t.buffers.length; e++) { const i = t.buffers[e]; s.updateBuffer(i) } } checkCompatibility(t, s) { const e = t.attributes, i = s.Ti; for (const n in i) if (!e[n]) throw new Error(`shader and geometry incompatible, geometry missing the "${n}" attribute`) } getSignature(t, s) { const e = t.attributes, i = s.Ti, n = ["g", t.uid]; for (const r in e) i[r] && n.push(r, i[r].location); return n.join("-") } getVao(t, s) { return this._h[t.uid]?.[s.Mi] || this.initGeometryVao(t, s) } initGeometryVao(t, s, e = !0) { const i = this.Be.gl, n = this.Be.buffer; this.Be.shader.kh(s), this.checkCompatibility(t, s); const r = this.getSignature(t, s); this._h[t.uid] || (this._h[t.uid] = Object.create(null), t.on("destroy", this.onGeometryDestroy, this)); const o = this._h[t.uid]; let h = o[r]; if (h) return o[s.Mi] = h, h; Yh(t, s.Ti); const a = t.buffers; h = i.createVertexArray(), i.bindVertexArray(h); for (let l = 0; l < a.length; l++) { const t = a[l]; n.bind(t) } return this.activateVao(t, s), o[s.Mi] = h, o[r] = h, i.bindVertexArray(null), h } onGeometryDestroy(t, s) { const e = this._h[t.uid], i = this.gl; if (e) { if (s) for (const t in e) this.Ph !== e[t] && this.unbind(), i.deleteVertexArray(e[t]); this._h[t.uid] = null } } destroyAll(t = !1) { const s = this.gl; for (const e in this._h) { if (t) for (const t in this._h[e]) { const i = this._h[e]; this.Ph !== i && this.unbind(), s.deleteVertexArray(i[t]) } this._h[e] = null } } activateVao(t, s) { const e = this.Be.gl, i = this.Be.buffer, n = t.attributes; t.indexBuffer && i.bind(t.indexBuffer); let r = null; for (const o in n) { const t = n[o], h = t.buffer, a = i.getGlBuffer(h), l = s.Ti[o]; if (l) { r !== a && (i.bind(h), r = a); const s = l.location; e.enableVertexAttribArray(s); const n = ze(t.format), o = ta(t.format); if ("int" === l.format?.substring(1, 4) ? e.vertexAttribIPointer(s, n.size, o, t.stride, t.offset) : e.vertexAttribPointer(s, n.size, o, n.normalised, t.stride, t.offset), t.instance) { if (!this.hasInstance) throw new Error("geometry error, GPU Instancing is not supported on this device"); { const i = t.divisor ?? 1; e.vertexAttribDivisor(s, i) } } } } } draw(t, s, e, i) { const { gl: n } = this.Be, r = this.Sh, o = sa[t || r.topology]; if (i ?? (i = r.instanceCount), r.indexBuffer) { const t = r.indexBuffer.data.BYTES_PER_ELEMENT, h = 2 === t ? n.UNSIGNED_SHORT : n.UNSIGNED_INT; 1 !== i ? n.drawElementsInstanced(o, s || r.indexBuffer.data.length, h, (e || 0) * t, i) : n.drawElements(o, s || r.indexBuffer.data.length, h, (e || 0) * t) } else 1 !== i ? n.drawArraysInstanced(o, e || 0, s || r.getSize(), i) : n.drawArrays(o, e || 0, s || r.getSize()); return this } unbind() { this.gl.bindVertexArray(null), this.Ph = null, this.Sh = null } destroy() { this.Be = null, this.gl = null, this.Ph = null, this.Sh = null, this._h = {} } } ea.extension = { type: [r.WebGLSystem], name: "geometry" }; const ia = new Wn({ attributes: { aPosition: [-1, -1, 3, -1, -1, 3] } }), na = class t { constructor(t) { this.useBackBuffer = !1, this.Fh = !1, this.Be = t } init(s = {}) { const { useBackBuffer: e, antialias: i } = { ...t.defaultOptions, ...s }; this.useBackBuffer = e, this.Eh = i, this.Be.context.supports.msaa || (Et(), this.Eh = !1), this.ji = si.for2d(); const n = new $e({ vertex: "\n                attribute vec2 aPosition;\n                out vec2 vUv;\n\n                void main() {\n                    gl_Position = vec4(aPosition, 0.0, 1.0);\n\n                    vUv = (aPosition + 1.0) / 2.0;\n\n                    // flip dem UVs\n                    vUv.y = 1.0 - vUv.y;\n                }", fragment: "\n                in vec2 vUv;\n                out vec4 finalColor;\n\n                uniform sampler2D uTexture;\n\n                void main() {\n                    finalColor = texture(uTexture, vUv);\n                }", name: "big-triangle" }); this.Rh = new Qe({ glProgram: n, resources: { uTexture: Z.WHITE.source } }) } renderStart(t) { const s = this.Be.renderTarget.getRenderTarget(t.target); if (this.Fh = this.useBackBuffer && !!s.isRoot, this.Fh) { const s = this.Be.renderTarget.getRenderTarget(t.target); this.Oh = s.colorTexture, t.target = this.Uh(s.colorTexture) } } renderEnd() { this.Ih() } Ih() { const t = this.Be; t.renderTarget.finishRenderPass(), this.Fh && (t.renderTarget.bind(this.Oh, !1), this.Rh.resources.uTexture = this.Bh.source, t.encoder.draw({ geometry: ia, shader: this.Rh, state: this.ji })) } Uh(t) { return this.Bh = this.Bh || new Z({ source: new q({ width: t.width, height: t.height, resolution: t.$, antialias: this.Eh }) }), this.Bh.source.resize(t.width, t.height, t.$), this.Bh } destroy() { this.Bh && (this.Bh.destroy(), this.Bh = null) } }; na.extension = { type: [r.WebGLSystem], name: "backBuffer", priority: 1 }, na.defaultOptions = { useBackBuffer: !1 }; let ra = na; class oa { constructor(t) { this.$h = 15, this.Be = t } setMask(t) { this.$h !== t && (this.$h = t, this.Be.gl.colorMask(!!(8 & t), !!(4 & t), !!(2 & t), !!(1 & t))) } } oa.extension = { type: [r.WebGLSystem], name: "colorMask" }; class ha { constructor(t) { this.commandFinished = Promise.resolve(), this.Be = t } setGeometry(t, s) { this.Be.geometry.bind(t, s.glProgram) } finishRenderPass() { } draw(t) { const s = this.Be, { geometry: e, shader: i, state: n, skipSync: r, topology: o, size: h, start: a, instanceCount: l } = t; s.shader.bind(i, r), s.geometry.bind(e, s.shader.Gh), n && s.state.set(n), s.geometry.draw(o, h, a, l ?? e.instanceCount) } destroy() { this.Be = null } } ha.extension = { type: [r.WebGLSystem], name: "encoder" }; class aa { constructor(t) { this.Be = t } contextChange() { const t = this.Be.gl; this.maxTextures = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS), this.maxBatchableTextures = En(this.maxTextures, t); const s = 2 === this.Be.context.webGLVersion; this.maxUniformBindings = s ? t.getParameter(t.MAX_UNIFORM_BUFFER_BINDINGS) : 0 } destroy() { } } aa.extension = { type: [r.WebGLSystem], name: "limits" }; class la { constructor() { this.width = -1, this.height = -1, this.msaa = !1, this.msaaRenderBuffer = [] } } const ua = []; ua[Sn.NONE] = void 0, ua[Sn.DISABLED] = { stencilWriteMask: 0, stencilReadMask: 0 }, ua[Sn.RENDERING_MASK_ADD] = { stencilFront: { compare: "equal", passOp: "increment-clamp" }, stencilBack: { compare: "equal", passOp: "increment-clamp" } }, ua[Sn.RENDERING_MASK_REMOVE] = { stencilFront: { compare: "equal", passOp: "decrement-clamp" }, stencilBack: { compare: "equal", passOp: "decrement-clamp" } }, ua[Sn.MASK_ACTIVE] = { stencilWriteMask: 0, stencilFront: { compare: "equal", passOp: "keep" }, stencilBack: { compare: "equal", passOp: "keep" } }, ua[Sn.INVERSE_MASK_ACTIVE] = { stencilWriteMask: 0, stencilFront: { compare: "not-equal", passOp: "keep" }, stencilBack: { compare: "not-equal", passOp: "keep" } }; class ca { constructor(t) { this.zh = { enabled: !1, stencilReference: 0, stencilMode: Sn.NONE }, this.Dh = Object.create(null), t.renderTarget.onRenderTargetChange.add(this) } contextChange(t) { this.Th = t, this.jh = { always: t.ALWAYS, never: t.NEVER, equal: t.EQUAL, "not-equal": t.NOTEQUAL, less: t.LESS, "less-equal": t.LEQUAL, greater: t.GREATER, "greater-equal": t.GEQUAL }, this.Lh = { keep: t.KEEP, zero: t.ZERO, replace: t.REPLACE, invert: t.INVERT, "increment-clamp": t.INCR, "decrement-clamp": t.DECR, "increment-wrap": t.INCR_WRAP, "decrement-wrap": t.DECR_WRAP }, this.resetState() } onRenderTargetChange(t) { if (this.Vh === t) return; this.Vh = t; let s = this.Dh[t.uid]; s || (s = this.Dh[t.uid] = { stencilMode: Sn.DISABLED, stencilReference: 0 }), this.setStencilMode(s.stencilMode, s.stencilReference) } resetState() { this.zh.enabled = !1, this.zh.stencilMode = Sn.NONE, this.zh.stencilReference = 0 } setStencilMode(t, s) { const e = this.Dh[this.Vh.uid], i = this.Th, n = ua[t], r = this.zh; e.stencilMode = t, e.stencilReference = s, t !== Sn.DISABLED ? (this.zh.enabled || (this.zh.enabled = !0, i.enable(i.STENCIL_TEST)), t === r.stencilMode && r.stencilReference === s || (r.stencilMode = t, r.stencilReference = s, i.stencilFunc(this.jh[n.stencilBack.compare], s, 255), i.stencilOp(i.KEEP, i.KEEP, this.Lh[n.stencilBack.passOp]))) : this.zh.enabled && (this.zh.enabled = !1, i.disable(i.STENCIL_TEST)) } } ca.extension = { type: [r.WebGLSystem], name: "stencil" }; class fa { constructor(t) { this.Nh = Object.create(null), this.ih = t, this.Wh() } Wh() { if (!oi()) throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.") } ensureUniformGroup(t) { const s = this.getUniformGroupData(t); t.buffer || (t.buffer = new Vn({ data: new Float32Array(s.layout.size / 4), usage: Ln.UNIFORM | Ln.COPY_DST })) } getUniformGroupData(t) { return this.Nh[t.Ei] || this.Hh(t) } Hh(t) { const s = t.Ei; let e = this.Nh[s]; if (!e) { const i = Object.keys(t.uniformStructures).map(s => t.uniformStructures[s]), n = this.ih.createUboElements(i), r = this.qh(n.uboElements); e = this.Nh[s] = { layout: n, syncFunction: r } } return this.Nh[s] } qh(t) { return this.ih.generateUboSync(t) } syncUniformGroup(t, s, e) { const i = this.getUniformGroupData(t); t.buffer || (t.buffer = new Vn({ data: new Float32Array(i.layout.size / 4), usage: Ln.UNIFORM | Ln.COPY_DST })); let n = null; return s || (s = t.buffer.data, n = t.buffer.dataInt32), e || (e = 0), i.syncFunction(t.uniforms, s, n, e), !0 } updateUniformGroup(t) { if (t.isStatic && !t.Fi) return !1; t.Fi = 0; const s = this.syncUniformGroup(t); return t.buffer.update(), s } destroy() { this.Nh = null } } const da = { f32: 4, i32: 4, "vec2<f32>": 8, "vec3<f32>": 12, "vec4<f32>": 16, "vec2<i32>": 8, "vec3<i32>": 12, "vec4<i32>": 16, "mat2x2<f32>": 32, "mat3x3<f32>": 48, "mat4x4<f32>": 64 }; function pa(t) { const s = t.map(t => ({ data: t, offset: 0, size: 0 })); let e = 0, i = 0; for (let n = 0; n < s.length; n++) { const t = s[n]; if (e = da[t.data.type], !e) throw new Error(`Unknown type ${t.data.type}`); t.data.size > 1 && (e = Math.max(e, 16) * t.data.size); const r = 12 === e ? 16 : e; t.size = e; const o = i % 16; i += o > 0 && 16 - o < r ? (16 - o) % 16 : (e - o % e) % e, t.offset = i, i += e } return i = 16 * Math.ceil(i / 16), { uboElements: s, size: i } } const ma = [{ type: "mat3x3<f32>", test: t => void 0 !== t.value.a, ubo: "\n            var matrix = uv[name].toArray(true);\n            data[offset] = matrix[0];\n            data[offset + 1] = matrix[1];\n            data[offset + 2] = matrix[2];\n            data[offset + 4] = matrix[3];\n            data[offset + 5] = matrix[4];\n            data[offset + 6] = matrix[5];\n            data[offset + 8] = matrix[6];\n            data[offset + 9] = matrix[7];\n            data[offset + 10] = matrix[8];\n        ", uniform: "\n            gl.uniformMatrix3fv(ud[name].location, false, uv[name].toArray(true));\n        " }, { type: "vec4<f32>", test: t => "vec4<f32>" === t.type && 1 === t.size && void 0 !== t.value.width, ubo: "\n            v = uv[name];\n            data[offset] = v.x;\n            data[offset + 1] = v.y;\n            data[offset + 2] = v.width;\n            data[offset + 3] = v.height;\n        ", uniform: "\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height) {\n                cv[0] = v.x;\n                cv[1] = v.y;\n                cv[2] = v.width;\n                cv[3] = v.height;\n                gl.uniform4f(ud[name].location, v.x, v.y, v.width, v.height);\n            }\n        " }, { type: "vec2<f32>", test: t => "vec2<f32>" === t.type && 1 === t.size && void 0 !== t.value.x, ubo: "\n            v = uv[name];\n            data[offset] = v.x;\n            data[offset + 1] = v.y;\n        ", uniform: "\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.x || cv[1] !== v.y) {\n                cv[0] = v.x;\n                cv[1] = v.y;\n                gl.uniform2f(ud[name].location, v.x, v.y);\n            }\n        " }, { type: "vec4<f32>", test: t => "vec4<f32>" === t.type && 1 === t.size && void 0 !== t.value.red, ubo: "\n            v = uv[name];\n            data[offset] = v.red;\n            data[offset + 1] = v.green;\n            data[offset + 2] = v.blue;\n            data[offset + 3] = v.alpha;\n        ", uniform: "\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha) {\n                cv[0] = v.red;\n                cv[1] = v.green;\n                cv[2] = v.blue;\n                cv[3] = v.alpha;\n                gl.uniform4f(ud[name].location, v.red, v.green, v.blue, v.alpha);\n            }\n        " }, { type: "vec3<f32>", test: t => "vec3<f32>" === t.type && 1 === t.size && void 0 !== t.value.red, ubo: "\n            v = uv[name];\n            data[offset] = v.red;\n            data[offset + 1] = v.green;\n            data[offset + 2] = v.blue;\n        ", uniform: "\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue) {\n                cv[0] = v.red;\n                cv[1] = v.green;\n                cv[2] = v.blue;\n                gl.uniform3f(ud[name].location, v.red, v.green, v.blue);\n            }\n        " }]; function ga(t, s, e, i) { const n = ["\n        var v = null;\n        var v2 = null;\n        var t = 0;\n        var index = 0;\n        var name = null;\n        var arrayOffset = null;\n    "]; let r = 0; for (let h = 0; h < t.length; h++) { const o = t[h], a = o.data.name; let l = !1, u = 0; for (let t = 0; t < ma.length; t++)if (ma[t].test(o.data)) { u = o.offset / 4, n.push(`name = "${a}";`, `offset += ${u - r};`, ma[t][s] || ma[t].ubo), l = !0; break } if (!l) if (o.data.size > 1) u = o.offset / 4, n.push(e(o, u - r)); else { const t = i[o.data.type]; u = o.offset / 4, n.push(`\n                    v = uv.${a};\n                    offset += ${u - r};\n                    ${t};\n                `) } r = u } const o = n.join("\n"); return new Function("uv", "data", "dataInt32", "offset", o) } function va(t, s) { return `\n        for (let i = 0; i < ${t * s}; i++) {\n            data[offset + (((i / ${t})|0) * 4) + (i % ${t})] = v[i];\n        }\n    ` } const ba = { f32: "\n        data[offset] = v;", i32: "\n        dataInt32[offset] = v;", "vec2<f32>": "\n        data[offset] = v[0];\n        data[offset + 1] = v[1];", "vec3<f32>": "\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];", "vec4<f32>": "\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 3] = v[3];", "vec2<i32>": "\n        dataInt32[offset] = v[0];\n        dataInt32[offset + 1] = v[1];", "vec3<i32>": "\n        dataInt32[offset] = v[0];\n        dataInt32[offset + 1] = v[1];\n        dataInt32[offset + 2] = v[2];", "vec4<i32>": "\n        dataInt32[offset] = v[0];\n        dataInt32[offset + 1] = v[1];\n        dataInt32[offset + 2] = v[2];\n        dataInt32[offset + 3] = v[3];", "mat2x2<f32>": "\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 4] = v[2];\n        data[offset + 5] = v[3];", "mat3x3<f32>": "\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 4] = v[3];\n        data[offset + 5] = v[4];\n        data[offset + 6] = v[5];\n        data[offset + 8] = v[6];\n        data[offset + 9] = v[7];\n        data[offset + 10] = v[8];", "mat4x4<f32>": "\n        for (let i = 0; i < 16; i++) {\n            data[offset + i] = v[i];\n        }", "mat3x2<f32>": va(3, 2), "mat4x2<f32>": va(4, 2), "mat2x3<f32>": va(2, 3), "mat4x3<f32>": va(4, 3), "mat2x4<f32>": va(2, 4), "mat3x4<f32>": va(3, 4) }, xa = { ...ba, "mat2x2<f32>": "\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 3] = v[3];\n    " }; function ya(t, s) { const e = Math.max(da[t.data.type] / 16, 1), i = t.data.value.length / t.data.size, n = (4 - i % 4) % 4, r = t.data.type.indexOf("i32") >= 0 ? "dataInt32" : "data"; return `\n        v = uv.${t.data.name};\n        offset += ${s};\n\n        arrayOffset = offset;\n\n        t = 0;\n\n        for(var i=0; i < ${t.data.size * e}; i++)\n        {\n            for(var j = 0; j < ${i}; j++)\n            {\n                ${r}[arrayOffset++] = v[t++];\n            }\n            ${0 !== n ? `arrayOffset += ${n};` : ""}\n        }\n    ` } function wa(t) { return ga(t, "uboStd40", ya, ba) } class Ma extends fa { constructor() { super({ createUboElements: pa, generateUboSync: wa }) } } Ma.extension = { type: [r.WebGLSystem], name: "ubo" }; class Ta { constructor() { this.Xh = [0, 0, 0, 0], this.Yh = new O } init(t, s) { this.Be = t, this.Kh = s, t.runners.contextChange.add(this) } contextChange() { this.Xh = [0, 0, 0, 0], this.Yh = new O } copyToTexture(t, s, e, i, n) { const r = this.Kh, o = this.Be, h = r.getGpuRenderTarget(t), a = o.gl; return this.finishRenderPass(t), a.bindFramebuffer(a.FRAMEBUFFER, h.resolveTargetFramebuffer), o.texture.bind(s, 0), a.copyTexSubImage2D(a.TEXTURE_2D, 0, n.x, n.y, e.x, e.y, i.width, i.height), s } startRenderPass(t, s = !0, e, i) { const n = this.Kh, r = t.colorTexture, o = n.getGpuRenderTarget(t); let h = i.y; t.isRoot && (h = r.pixelHeight - i.height), t.colorTextures.forEach(t => { this.Be.texture.unbind(t) }); const a = this.Be.gl; a.bindFramebuffer(a.FRAMEBUFFER, o.framebuffer); const l = this.Yh; l.x === i.x && l.y === h && l.width === i.width && l.height === i.height || (l.x = i.x, l.y = h, l.width = i.width, l.height = i.height, a.viewport(i.x, h, i.width, i.height)), o.depthStencilRenderBuffer || !t.stencil && !t.depth || this.Zh(o), this.clear(t, s, e) } finishRenderPass(t) { const s = this.Kh.getGpuRenderTarget(t); if (!s.msaa) return; const e = this.Be.gl; e.bindFramebuffer(e.FRAMEBUFFER, s.resolveTargetFramebuffer), e.bindFramebuffer(e.READ_FRAMEBUFFER, s.framebuffer), e.blitFramebuffer(0, 0, s.width, s.height, 0, 0, s.width, s.height, e.COLOR_BUFFER_BIT, e.NEAREST), e.bindFramebuffer(e.FRAMEBUFFER, s.framebuffer) } initGpuRenderTarget(t) { const s = this.Be.gl, e = new la; return t.colorTexture instanceof Fs ? (this.Be.context.ensureCanvasSize(t.colorTexture.resource), e.framebuffer = null, e) : (this.Qh(t, e), s.bindFramebuffer(s.FRAMEBUFFER, null), e) } destroyGpuRenderTarget(t) { const s = this.Be.gl; t.framebuffer && (s.deleteFramebuffer(t.framebuffer), t.framebuffer = null), t.resolveTargetFramebuffer && (s.deleteFramebuffer(t.resolveTargetFramebuffer), t.resolveTargetFramebuffer = null), t.depthStencilRenderBuffer && (s.deleteRenderbuffer(t.depthStencilRenderBuffer), t.depthStencilRenderBuffer = null), t.msaaRenderBuffer.forEach(t => { s.deleteRenderbuffer(t) }), t.msaaRenderBuffer = null } clear(t, s, e) { if (!s) return; const i = this.Kh; "boolean" == typeof s && (s = s ? Ui.ALL : Ui.NONE); const n = this.Be.gl; if (s & Ui.COLOR) { e ?? (e = i.defaultClearColor); const t = this.Xh, s = e; t[0] === s[0] && t[1] === s[1] && t[2] === s[2] && t[3] === s[3] || (t[0] = s[0], t[1] = s[1], t[2] = s[2], t[3] = s[3], n.clearColor(s[0], s[1], s[2], s[3])) } n.clear(s) } resizeGpuRenderTarget(t) { if (t.isRoot) return; const s = this.Kh.getGpuRenderTarget(t); this.Jh(t, s), (t.stencil || t.depth) && this.ta(s) } Qh(t, s) { const e = this.Be, i = e.gl, n = i.createFramebuffer(); if (s.resolveTargetFramebuffer = n, i.bindFramebuffer(i.FRAMEBUFFER, n), s.width = t.colorTexture.source.pixelWidth, s.height = t.colorTexture.source.pixelHeight, t.colorTextures.forEach((t, n) => { const r = t.source; r.antialias && (e.context.supports.msaa ? s.msaa = !0 : Et()), e.texture.bindSource(r, 0); const o = e.texture.getGlSource(r).texture; i.framebufferTexture2D(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0 + n, 3553, o, 0) }), s.msaa) { const e = i.createFramebuffer(); s.framebuffer = e, i.bindFramebuffer(i.FRAMEBUFFER, e), t.colorTextures.forEach((t, e) => { const n = i.createRenderbuffer(); s.msaaRenderBuffer[e] = n }) } else s.framebuffer = n; this.Jh(t, s) } Jh(t, s) { const e = t.colorTexture.source; if (s.width = e.pixelWidth, s.height = e.pixelHeight, t.colorTextures.forEach((t, s) => { 0 !== s && t.source.resize(e.width, e.height, e.$) }), s.msaa) { const e = this.Be, i = e.gl, n = s.framebuffer; i.bindFramebuffer(i.FRAMEBUFFER, n), t.colorTextures.forEach((t, n) => { const r = t.source; e.texture.bindSource(r, 0); const o = e.texture.getGlSource(r).internalFormat, h = s.msaaRenderBuffer[n]; i.bindRenderbuffer(i.RENDERBUFFER, h), i.renderbufferStorageMultisample(i.RENDERBUFFER, 4, o, r.pixelWidth, r.pixelHeight), i.framebufferRenderbuffer(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0 + n, i.RENDERBUFFER, h) }) } } Zh(t) { if (null === t.framebuffer) return; const s = this.Be.gl, e = s.createRenderbuffer(); t.depthStencilRenderBuffer = e, s.bindRenderbuffer(s.RENDERBUFFER, e), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.RENDERBUFFER, e), this.ta(t) } ta(t) { const s = this.Be.gl; s.bindRenderbuffer(s.RENDERBUFFER, t.depthStencilRenderBuffer), t.msaa ? s.renderbufferStorageMultisample(s.RENDERBUFFER, 4, s.DEPTH24_STENCIL8, t.width, t.height) : s.renderbufferStorage(s.RENDERBUFFER, 2 === this.Be.context.webGLVersion ? s.DEPTH24_STENCIL8 : s.DEPTH_STENCIL, t.width, t.height) } prerender(t) { const s = t.colorTexture.resource; this.Be.context.multiView && Fs.test(s) && this.Be.context.ensureCanvasSize(s) } postrender(t) { if (this.Be.context.multiView && Fs.test(t.colorTexture.resource)) { const s = this.Be.context.canvas, e = t.colorTexture; e.context2D.drawImage(s, 0, e.pixelHeight - s.height) } } } const Aa = new Map; function Ca(t, s) { if (!Aa.has(t)) { const e = new Z({ source: new Fs({ resource: t, ...s }) }), i = () => { Aa.get(t) === e && Aa.delete(t) }; e.once("destroy", i), e.source.once("destroy", i), Aa.set(t, e) } return Aa.get(t) } Rt.register(Aa); const _a = class t { constructor(s = {}) { if (this.uid = I("renderTarget"), this.colorTextures = [], this.dirtyId = 0, this.isRoot = !1, this.sa = new Float32Array(2), this.ea = !1, s = { ...t.defaultOptions, ...s }, this.stencil = s.stencil, this.depth = s.depth, this.isRoot = s.isRoot, "number" == typeof s.colorTextures) { this.ea = !0; for (let t = 0; t < s.colorTextures; t++)this.colorTextures.push(new q({ width: s.width, height: s.height, resolution: s.resolution, antialias: s.antialias })) } else { this.colorTextures = [...s.colorTextures.map(t => t.source)]; const t = this.colorTexture.source; this.resize(t.width, t.height, t.$) } this.colorTexture.source.on("resize", this.onSourceResize, this), (s.depthStencilTexture || this.stencil) && (s.depthStencilTexture instanceof Z || s.depthStencilTexture instanceof q ? this.depthStencilTexture = s.depthStencilTexture.source : this.ensureDepthStencilTexture()) } get size() { const t = this.sa; return t[0] = this.pixelWidth, t[1] = this.pixelHeight, t } get width() { return this.colorTexture.source.width } get height() { return this.colorTexture.source.height } get pixelWidth() { return this.colorTexture.source.pixelWidth } get pixelHeight() { return this.colorTexture.source.pixelHeight } get resolution() { return this.colorTexture.source.$ } get colorTexture() { return this.colorTextures[0] } onSourceResize(t) { this.resize(t.width, t.height, t.$, !0) } ensureDepthStencilTexture() { this.depthStencilTexture || (this.depthStencilTexture = new q({ width: this.width, height: this.height, resolution: this.resolution, format: "depth24plus-stencil8", autoGenerateMipmaps: !1, antialias: !1, mipLevelCount: 1 })) } resize(t, s, e = this.resolution, i = !1) { this.dirtyId++, this.colorTextures.forEach((n, r) => { i && 0 === r || n.source.resize(t, s, e) }), this.depthStencilTexture && this.depthStencilTexture.source.resize(t, s, e) } destroy() { this.colorTexture.source.off("resize", this.onSourceResize, this), this.ea && this.colorTextures.forEach(t => { t.destroy() }), this.depthStencilTexture && (this.depthStencilTexture.destroy(), delete this.depthStencilTexture) } }; _a.defaultOptions = { width: 0, height: 0, resolution: 1, colorTextures: 1, stencil: !1, depth: !1, antialias: !1, isRoot: !1 }; let Sa = _a; class Pa { constructor(t) { this.rootViewPort = new O, this.viewport = new O, this.onRenderTargetChange = new Ii("onRenderTargetChange"), this.projectionMatrix = new w, this.defaultClearColor = [0, 0, 0, 0], this.ia = new Map, this.na = Object.create(null), this.ra = [], this.Be = t, t.renderableGC.addManagedHash(this, "_gpuRenderTargetHash") } finishRenderPass() { this.adaptor.finishRenderPass(this.renderTarget) } renderStart({ target: t, clear: s, clearColor: e, frame: i }) { this.ra.length = 0, this.push(t, s, e, i), this.rootViewPort.copyFrom(this.viewport), this.rootRenderTarget = this.renderTarget, this.renderingToScreen = function (t) { const s = t.colorTexture.source.resource; return globalThis.HTMLCanvasElement && s instanceof HTMLCanvasElement && document.body.contains(s) }(this.rootRenderTarget), this.adaptor.prerender?.(this.rootRenderTarget) } postrender() { this.adaptor.postrender?.(this.rootRenderTarget) } bind(t, s = !0, e, i) { const n = this.getRenderTarget(t), r = this.renderTarget !== n; this.renderTarget = n, this.renderSurface = t; const o = this.getGpuRenderTarget(n); n.pixelWidth === o.width && n.pixelHeight === o.height || (this.adaptor.resizeGpuRenderTarget(n), o.width = n.pixelWidth, o.height = n.pixelHeight); const h = n.colorTexture, a = this.viewport, l = h.pixelWidth, u = h.pixelHeight; if (!i && t instanceof Z && (i = t.frame), i) { const t = h.$; a.x = i.x * t + .5 | 0, a.y = i.y * t + .5 | 0, a.width = i.width * t + .5 | 0, a.height = i.height * t + .5 | 0 } else a.x = 0, a.y = 0, a.width = l, a.height = u; return function (t, s, e, i, n, r) { const o = r ? 1 : -1; t.identity(), t.a = 1 / i * 2, t.d = o * (1 / n * 2), t.tx = -1 - 0 * t.a, t.ty = -o - 0 * t.d }(this.projectionMatrix, 0, 0, a.width / h.resolution, a.height / h.resolution, !n.isRoot), this.adaptor.startRenderPass(n, s, e, a), r && this.onRenderTargetChange.emit(n), n } clear(t, s = Ui.ALL, e) { s && (t && (t = this.getRenderTarget(t)), this.adaptor.clear(t || this.renderTarget, s, e, this.viewport)) } contextChange() { this.na = Object.create(null) } push(t, s = Ui.ALL, e, i) { const n = this.bind(t, s, e, i); return this.ra.push({ renderTarget: n, frame: i }), n } pop() { this.ra.pop(); const t = this.ra[this.ra.length - 1]; this.bind(t.renderTarget, !1, null, t.frame) } getRenderTarget(t) { return t.isTexture && (t = t.source), this.ia.get(t) ?? this.oa(t) } copyToTexture(t, s, e, i, n) { e.x < 0 && (i.width += e.x, n.x -= e.x, e.x = 0), e.y < 0 && (i.height += e.y, n.y -= e.y, e.y = 0); const { pixelWidth: r, pixelHeight: o } = t; return i.width = Math.min(i.width, r - e.x), i.height = Math.min(i.height, o - e.y), this.adaptor.copyToTexture(t, s, e, i, n) } ensureDepthStencil() { this.renderTarget.stencil || (this.renderTarget.stencil = !0, this.adaptor.startRenderPass(this.renderTarget, !1, null, this.viewport)) } destroy() { this.Be = null, this.ia.forEach((t, s) => { t !== s && t.destroy() }), this.ia.clear(), this.na = Object.create(null) } oa(t) { let s = null; return Fs.test(t) && (t = Ca(t).source), t instanceof Sa ? s = t : t instanceof q && (s = new Sa({ colorTextures: [t] }), t.source instanceof Fs && (s.isRoot = !0), t.once("destroy", () => { s.destroy(), this.ia.delete(t); const e = this.na[s.uid]; e && (this.na[s.uid] = null, this.adaptor.destroyGpuRenderTarget(e)) })), this.ia.set(t, s), s } getGpuRenderTarget(t) { return this.na[t.uid] || (this.na[t.uid] = this.adaptor.initGpuRenderTarget(t)) } resetState() { this.renderTarget = null, this.renderSurface = null } } class ka extends Pa { constructor(t) { super(t), this.adaptor = new Ta, this.adaptor.init(t, this) } } ka.extension = { type: [r.WebGLSystem], name: "renderTarget" }; class Fa extends m { constructor({ buffer: t, offset: s, size: e }) { super(), this.uid = I("buffer"), this.F = "bufferResource", this.R = 0, this.U = I("resource"), this.ha = !0, this.destroyed = !1, this.buffer = t, this.offset = 0 | s, this.size = e, this.buffer.on("change", this.onBufferChange, this) } onBufferChange() { this.U = I("resource"), this.emit("change", this) } destroy(t = !1) { this.destroyed = !0, t && this.buffer.destroy(), this.emit("change", this), this.buffer = null, this.removeAllListeners() } } class Ea { constructor(t, s) { this.program = t, this.uniformData = s, this.uniformGroups = {}, this.uniformDirtyGroups = {}, this.uniformBlockBindings = {} } destroy() { this.uniformData = null, this.uniformGroups = null, this.uniformDirtyGroups = null, this.uniformBlockBindings = null, this.program = null } } function Ra(t, s, e) { const i = t.createShader(s); return t.shaderSource(i, e), t.compileShader(i), i } function Oa(t) { const s = new Array(t); for (let e = 0; e < s.length; e++)s[e] = !1; return s } function Ua(t, s) { switch (t) { case "float": case "int": case "uint": case "sampler2D": case "sampler2DArray": return 0; case "vec2": return new Float32Array(2 * s); case "vec3": return new Float32Array(3 * s); case "vec4": return new Float32Array(4 * s); case "ivec2": return new Int32Array(2 * s); case "ivec3": return new Int32Array(3 * s); case "ivec4": return new Int32Array(4 * s); case "uvec2": return new Uint32Array(2 * s); case "uvec3": return new Uint32Array(3 * s); case "uvec4": return new Uint32Array(4 * s); case "bool": return !1; case "bvec2": return Oa(2 * s); case "bvec3": return Oa(3 * s); case "bvec4": return Oa(4 * s); case "mat2": return new Float32Array([1, 0, 0, 1]); case "mat3": return new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]); case "mat4": return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]) }return null } let Ia = null; const Ba = { FLOAT: "float", FLOAT_VEC2: "vec2", FLOAT_VEC3: "vec3", FLOAT_VEC4: "vec4", INT: "int", INT_VEC2: "ivec2", INT_VEC3: "ivec3", INT_VEC4: "ivec4", UNSIGNED_INT: "uint", UNSIGNED_INT_VEC2: "uvec2", UNSIGNED_INT_VEC3: "uvec3", UNSIGNED_INT_VEC4: "uvec4", BOOL: "bool", BOOL_VEC2: "bvec2", BOOL_VEC3: "bvec3", BOOL_VEC4: "bvec4", FLOAT_MAT2: "mat2", FLOAT_MAT3: "mat3", FLOAT_MAT4: "mat4", SAMPLER_2D: "sampler2D", INT_SAMPLER_2D: "sampler2D", UNSIGNED_INT_SAMPLER_2D: "sampler2D", SAMPLER_CUBE: "samplerCube", INT_SAMPLER_CUBE: "samplerCube", UNSIGNED_INT_SAMPLER_CUBE: "samplerCube", SAMPLER_2D_ARRAY: "sampler2DArray", INT_SAMPLER_2D_ARRAY: "sampler2DArray", UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray" }, $a = { float: "float32", vec2: "float32x2", vec3: "float32x3", vec4: "float32x4", int: "sint32", ivec2: "sint32x2", ivec3: "sint32x3", ivec4: "sint32x4", uint: "uint32", uvec2: "uint32x2", uvec3: "uint32x3", uvec4: "uint32x4", bool: "uint32", bvec2: "uint32x2", bvec3: "uint32x3", bvec4: "uint32x4" }; function Ga(t, s) { if (!Ia) { const s = Object.keys(Ba); Ia = {}; for (let e = 0; e < s.length; ++e) { const i = s[e]; Ia[t[i]] = Ba[i] } } return Ia[s] } function za(t, s) { const e = Ga(t, s); return $a[e] || "float32" } function Da(t, s) { const e = t.getShaderSource(s).split("\n").map((t, s) => `${s}: ${t}`), i = t.getShaderInfoLog(s).split("\n"), n = {}, r = i.map(t => parseFloat(t.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"))).filter(t => !(!t || n[t] || (n[t] = !0, 0))), o = [""]; r.forEach(t => { e[t - 1] = `%c${e[t - 1]}%c`, o.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px") }); const h = e.join("\n"); o[0] = h } const ja = { textureCount: 0, blockIndex: 0 }; class La { constructor(t) { this.Gh = null, this.aa = Object.create(null), this.la = Object.create(null), this.Be = t, this.Be.renderableGC.addManagedHash(this, "_programDataHash") } contextChange(t) { this.Th = t, this.aa = Object.create(null), this.la = Object.create(null), this.Gh = null } bind(t, s) { if (this.ua(t.glProgram), s) return; ja.textureCount = 0, ja.blockIndex = 0; let e = this.la[t.glProgram.Mi]; e || (e = this.la[t.glProgram.Mi] = this.ca(t, this)), this.Be.buffer.nextBindBase(!!t.glProgram.transformFeedbackVaryings), e(this.Be, t, ja) } updateUniformGroup(t) { this.Be.uniformGroup.updateUniformGroup(t, this.Gh, ja) } bindUniformBlock(t, s, e = 0) { const i = this.Be.buffer, n = this.kh(this.Gh), r = t.ha; r || this.Be.ubo.updateUniformGroup(t); const o = t.buffer, h = i.updateBuffer(o), a = i.freeLocationForBufferBase(h); if (r) { const { offset: s, size: e } = t; 0 === s && e === o.data.byteLength ? i.bindBufferBase(h, a) : i.bindBufferRange(h, a, s) } else i.getLastBindBaseLocation(h) !== a && i.bindBufferBase(h, a); const l = this.Gh.Ci[s].index; n.uniformBlockBindings[e] !== a && (n.uniformBlockBindings[e] = a, this.Be.gl.uniformBlockBinding(n.program, l, a)) } ua(t) { if (this.Gh === t) return; this.Gh = t; const s = this.kh(t); this.Th.useProgram(s.program) } kh(t) { return this.aa[t.Mi] || this.fa(t) } fa(t) { const s = t.Mi; return this.aa[s] = function (t, s) { const e = Ra(t, t.VERTEX_SHADER, s.vertex), i = Ra(t, t.FRAGMENT_SHADER, s.fragment), n = t.createProgram(); t.attachShader(n, e), t.attachShader(n, i); const r = s.transformFeedbackVaryings; r && ("function" != typeof t.transformFeedbackVaryings ? Et() : t.transformFeedbackVaryings(n, r.names, "separate" === r.bufferMode ? t.SEPARATE_ATTRIBS : t.INTERLEAVED_ATTRIBS)), t.linkProgram(n), t.getProgramParameter(n, t.LINK_STATUS) || function (t, s, e, i) { t.getProgramParameter(s, t.LINK_STATUS) || (t.getShaderParameter(e, t.COMPILE_STATUS) || Da(t, e), t.getShaderParameter(i, t.COMPILE_STATUS) || Da(t, i), t.getProgramInfoLog(s)) }(t, n, e, i), s.Ti = function (t, s, e = !1) { const i = {}, n = s.getProgramParameter(t, s.ACTIVE_ATTRIBUTES); for (let o = 0; o < n; o++) { const e = s.getActiveAttrib(t, o); if (e.name.startsWith("gl_")) continue; const n = za(s, e.type); i[e.name] = { location: 0, format: n, stride: ze(n).stride, offset: 0, instance: !1, start: 0 } } const r = Object.keys(i); if (e) { r.sort((t, s) => t > s ? 1 : -1); for (let e = 0; e < r.length; e++)i[r[e]].location = e, s.bindAttribLocation(t, e, r[e]); s.linkProgram(t) } else for (let o = 0; o < r.length; o++)i[r[o]].location = s.getAttribLocation(t, r[o]); return i }(n, t, !/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(s.vertex)), s.Ai = function (t, s) { const e = {}, i = s.getProgramParameter(t, s.ACTIVE_UNIFORMS); for (let n = 0; n < i; n++) { const i = s.getActiveUniform(t, n), r = i.name.replace(/\[.*?\]$/, ""), o = !!i.name.match(/\[.*?\]$/), h = Ga(s, i.type); e[r] = { name: r, index: n, type: h, size: i.size, isArray: o, value: Ua(h, i.size) } } return e }(n, t), s.Ci = function (t, s) { if (!s.ACTIVE_UNIFORM_BLOCKS) return {}; const e = {}, i = s.getProgramParameter(t, s.ACTIVE_UNIFORM_BLOCKS); for (let n = 0; n < i; n++) { const i = s.getActiveUniformBlockName(t, n), r = s.getUniformBlockIndex(t, i), o = s.getActiveUniformBlockParameter(t, n, s.UNIFORM_BLOCK_DATA_SIZE); e[i] = { name: i, index: r, size: o } } return e }(n, t), t.deleteShader(e), t.deleteShader(i); const o = {}; for (const h in s.Ai) { const e = s.Ai[h]; o[h] = { location: t.getUniformLocation(n, h), value: Ua(e.type, e.size) } } return new Ea(n, o) }(this.Th, t), this.aa[s] } destroy() { for (const t of Object.keys(this.aa)) this.aa[t].destroy(), this.aa[t] = null; this.aa = null, this.la = null, this.Gh = null, this.Be = null, this.Th = null } ca(t, s) { return function (t, s) { const e = [], i = ["\n        var g = s.groups;\n        var sS = r.shader;\n        var p = s.glProgram;\n        var ugS = r.uniformGroup;\n        var resources;\n    "]; let n = !1, r = 0; const o = s.kh(t.glProgram); for (const a in t.groups) { const h = t.groups[a]; e.push(`\n            resources = g[${a}].resources;\n        `); for (const l in h.resources) { const u = h.resources[l]; if (u instanceof Ye) if (u.ubo) { const s = t.Ii[a][Number(l)]; e.push(`\n                        sS.bindUniformBlock(\n                            resources[${l}],\n                            '${s}',\n                            ${t.glProgram.Ci[s].index}\n                        );\n                    `) } else e.push(`\n                        ugS.updateUniformGroup(resources[${l}], p, sD);\n                    `); else if (u instanceof Fa) { const s = t.Ii[a][Number(l)]; e.push(`\n                    sS.bindUniformBlock(\n                        resources[${l}],\n                        '${s}',\n                        ${t.glProgram.Ci[s].index}\n                    );\n                `) } else if (u instanceof q) { const h = t.Ii[a][l], u = o.uniformData[h]; u && (n || (n = !0, i.push("\n                        var tS = r.texture;\n                        ")), s.Th.uniform1i(u.location, r), e.push(`\n                        tS.bind(resources[${l}], ${r});\n                    `), r++) } } } const h = [...i, ...e].join("\n"); return new Function("r", "s", "sD", h) }(t, s) } resetState() { this.Gh = null } } La.extension = { type: [r.WebGLSystem], name: "shader" }; const Va = { f32: "if (cv !== v) {\n            cu.value = v;\n            gl.uniform1f(location, v);\n        }", "vec2<f32>": "if (cv[0] !== v[0] || cv[1] !== v[1]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            gl.uniform2f(location, v[0], v[1]);\n        }", "vec3<f32>": "if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            gl.uniform3f(location, v[0], v[1], v[2]);\n        }", "vec4<f32>": "if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            cv[3] = v[3];\n            gl.uniform4f(location, v[0], v[1], v[2], v[3]);\n        }", i32: "if (cv !== v) {\n            cu.value = v;\n            gl.uniform1i(location, v);\n        }", "vec2<i32>": "if (cv[0] !== v[0] || cv[1] !== v[1]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            gl.uniform2i(location, v[0], v[1]);\n        }", "vec3<i32>": "if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            gl.uniform3i(location, v[0], v[1], v[2]);\n        }", "vec4<i32>": "if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            cv[3] = v[3];\n            gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n        }", u32: "if (cv !== v) {\n            cu.value = v;\n            gl.uniform1ui(location, v);\n        }", "vec2<u32>": "if (cv[0] !== v[0] || cv[1] !== v[1]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            gl.uniform2ui(location, v[0], v[1]);\n        }", "vec3<u32>": "if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            gl.uniform3ui(location, v[0], v[1], v[2]);\n        }", "vec4<u32>": "if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            cv[3] = v[3];\n            gl.uniform4ui(location, v[0], v[1], v[2], v[3]);\n        }", bool: "if (cv !== v) {\n            cu.value = v;\n            gl.uniform1i(location, v);\n        }", "vec2<bool>": "if (cv[0] !== v[0] || cv[1] !== v[1]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            gl.uniform2i(location, v[0], v[1]);\n        }", "vec3<bool>": "if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            gl.uniform3i(location, v[0], v[1], v[2]);\n        }", "vec4<bool>": "if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            cv[3] = v[3];\n            gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n        }", "mat2x2<f32>": "gl.uniformMatrix2fv(location, false, v);", "mat3x3<f32>": "gl.uniformMatrix3fv(location, false, v);", "mat4x4<f32>": "gl.uniformMatrix4fv(location, false, v);" }, Na = { f32: "gl.uniform1fv(location, v);", "vec2<f32>": "gl.uniform2fv(location, v);", "vec3<f32>": "gl.uniform3fv(location, v);", "vec4<f32>": "gl.uniform4fv(location, v);", "mat2x2<f32>": "gl.uniformMatrix2fv(location, false, v);", "mat3x3<f32>": "gl.uniformMatrix3fv(location, false, v);", "mat4x4<f32>": "gl.uniformMatrix4fv(location, false, v);", i32: "gl.uniform1iv(location, v);", "vec2<i32>": "gl.uniform2iv(location, v);", "vec3<i32>": "gl.uniform3iv(location, v);", "vec4<i32>": "gl.uniform4iv(location, v);", u32: "gl.uniform1iv(location, v);", "vec2<u32>": "gl.uniform2iv(location, v);", "vec3<u32>": "gl.uniform3iv(location, v);", "vec4<u32>": "gl.uniform4iv(location, v);", bool: "gl.uniform1iv(location, v);", "vec2<bool>": "gl.uniform2iv(location, v);", "vec3<bool>": "gl.uniform3iv(location, v);", "vec4<bool>": "gl.uniform4iv(location, v);" }; class Wa { constructor(t) { this.he = {}, this.da = {}, this.Be = t, this.gl = null, this.he = {} } contextChange(t) { this.gl = t } updateUniformGroup(t, s, e) { const i = this.Be.shader.kh(s); t.isStatic && t.Fi === i.uniformDirtyGroups[t.uid] || (i.uniformDirtyGroups[t.uid] = t.Fi, this.pa(t, s)(i.uniformData, t.uniforms, this.Be, e)) } pa(t, s) { return this.da[t.Ei]?.[s.Mi] || this.ma(t, s) } ma(t, s) { const e = this.da[t.Ei] || (this.da[t.Ei] = {}), i = this.ga(t, s.Ai, "u"); return this.he[i] || (this.he[i] = this.va(t, s.Ai)), e[s.Mi] = this.he[i], e[s.Mi] } va(t, s) { return function (t, s) { const e = ["\n        var v = null;\n        var cv = null;\n        var cu = null;\n        var t = 0;\n        var gl = renderer.gl;\n        var name = null;\n    "]; for (const i in t.uniforms) { if (!s[i]) { t.uniforms[i] instanceof Ye ? t.uniforms[i].ubo ? e.push(`\n                        renderer.shader.bindUniformBlock(uv.${i}, "${i}");\n                    `) : e.push(`\n                        renderer.shader.updateUniformGroup(uv.${i});\n                    `) : t.uniforms[i] instanceof Fa && e.push(`\n                        renderer.shader.bindBufferResource(uv.${i}, "${i}");\n                    `); continue } const n = t.uniformStructures[i]; let r = !1; for (let t = 0; t < ma.length; t++) { const s = ma[t]; if (n.type === s.type && s.test(n)) { e.push(`name = "${i}";`, ma[t].uniform), r = !0; break } } if (!r) { const t = (1 === n.size ? Va : Na)[n.type].replace("location", `ud["${i}"].location`); e.push(`\n            cu = ud["${i}"];\n            cv = cu.value;\n            v = uv["${i}"];\n            ${t};`) } } return new Function("ud", "uv", "renderer", "syncData", e.join("\n")) }(t, s) } ga(t, s, e) { const i = t.uniforms, n = [`${e}-`]; for (const r in i) n.push(r), s[r] && n.push(s[r].type); return n.join("-") } destroy() { this.Be = null, this.he = null } } Wa.extension = { type: [r.WebGLSystem], name: "uniformGroup" }; const Ha = class t { constructor(t) { this.ba = !1, this.gl = null, this.stateId = 0, this.polygonOffset = 0, this.blendMode = "none", this.xa = !1, this.map = [], this.map[0] = this.setBlend, this.map[1] = this.setOffset, this.map[2] = this.setCullFace, this.map[3] = this.setDepthTest, this.map[4] = this.setFrontFace, this.map[5] = this.setDepthMask, this.checks = [], this.defaultState = si.for2d(), t.renderTarget.onRenderTargetChange.add(this) } onRenderTargetChange(t) { this.ba = !t.isRoot, this.ya ? this.setFrontFace(this.wa) : this.Ma = !0 } contextChange(t) { this.gl = t, this.blendModesMap = function (t) { const s = {}; if (s.normal = [t.ONE, t.ONE_MINUS_SRC_ALPHA], s.add = [t.ONE, t.ONE], s.multiply = [t.DST_COLOR, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA], s.screen = [t.ONE, t.ONE_MINUS_SRC_COLOR, t.ONE, t.ONE_MINUS_SRC_ALPHA], s.none = [0, 0], s["normal-npm"] = [t.SRC_ALPHA, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA], s["add-npm"] = [t.SRC_ALPHA, t.ONE, t.ONE, t.ONE], s["screen-npm"] = [t.SRC_ALPHA, t.ONE_MINUS_SRC_COLOR, t.ONE, t.ONE_MINUS_SRC_ALPHA], s.erase = [t.ZERO, t.ONE_MINUS_SRC_ALPHA], t instanceof ks.get().getWebGLRenderingContext()) { const e = t.getExtension("EXT_blend_minmax"); e && (s.min = [t.ONE, t.ONE, t.ONE, t.ONE, e.MIN_EXT, e.MIN_EXT], s.max = [t.ONE, t.ONE, t.ONE, t.ONE, e.MAX_EXT, e.MAX_EXT]) } else s.min = [t.ONE, t.ONE, t.ONE, t.ONE, t.MIN, t.MIN], s.max = [t.ONE, t.ONE, t.ONE, t.ONE, t.MAX, t.MAX]; return s }(t), this.resetState() } set(t) { if (t || (t = this.defaultState), this.stateId !== t.data) { let s = this.stateId ^ t.data, e = 0; for (; s;)1 & s && this.map[e].call(this, !!(t.data & 1 << e)), s >>= 1, e++; this.stateId = t.data } for (let s = 0; s < this.checks.length; s++)this.checks[s](this, t) } forceState(t) { t || (t = this.defaultState); for (let s = 0; s < this.map.length; s++)this.map[s].call(this, !!(t.data & 1 << s)); for (let s = 0; s < this.checks.length; s++)this.checks[s](this, t); this.stateId = t.data } setBlend(s) { this.Ta(t.Aa, s), this.gl[s ? "enable" : "disable"](this.gl.BLEND) } setOffset(s) { this.Ta(t.Ca, s), this.gl[s ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL) } setDepthTest(t) { this.gl[t ? "enable" : "disable"](this.gl.DEPTH_TEST) } setDepthMask(t) { this.gl.depthMask(t) } setCullFace(t) { this.ya = t, this.gl[t ? "enable" : "disable"](this.gl.CULL_FACE), this.ya && this.Ma && this.setFrontFace(this.wa) } setFrontFace(t) { this.wa = t, this.Ma = !1; const s = this.ba ? !t : t; this._a !== s && (this._a = s, this.gl.frontFace(this.gl[s ? "CW" : "CCW"])) } setBlendMode(t) { if (this.blendModesMap[t] || (t = "normal"), t === this.blendMode) return; this.blendMode = t; const s = this.blendModesMap[t], e = this.gl; 2 === s.length ? e.blendFunc(s[0], s[1]) : e.blendFuncSeparate(s[0], s[1], s[2], s[3]), 6 === s.length ? (this.xa = !0, e.blendEquationSeparate(s[4], s[5])) : this.xa && (this.xa = !1, e.blendEquationSeparate(e.FUNC_ADD, e.FUNC_ADD)) } setPolygonOffset(t, s) { this.gl.polygonOffset(t, s) } resetState() { this._a = !1, this.wa = !1, this.ya = !1, this.Ma = !1, this.ba = !1, this.gl.frontFace(this.gl.CCW), this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, !1), this.forceState(this.defaultState), this.xa = !0, this.blendMode = "", this.setBlendMode("normal") } Ta(t, s) { const e = this.checks.indexOf(t); s && -1 === e ? this.checks.push(t) : s || -1 === e || this.checks.splice(e, 1) } static Aa(t, s) { t.setBlendMode(s.blendMode) } static Ca(t, s) { t.setPolygonOffset(1, s.polygonOffset) } destroy() { this.gl = null, this.checks.length = 0 } }; Ha.extension = { type: [r.WebGLSystem], name: "state" }; let qa = Ha; class Xa { constructor(t) { this.target = Zh.TEXTURE_2D, this.texture = t, this.width = -1, this.height = -1, this.type = Qh.UNSIGNED_BYTE, this.internalFormat = Kh.RGBA, this.format = Kh.RGBA, this.samplerType = 0 } } const Ya = { id: "buffer", upload(t, s, e) { s.width === t.width || s.height === t.height ? e.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, t.width, t.height, s.format, s.type, t.resource) : e.texImage2D(s.target, 0, s.internalFormat, t.width, t.height, 0, s.format, s.type, t.resource), s.width = t.width, s.height = t.height } }, Ka = { "bc1-rgba-unorm": !0, "bc1-rgba-unorm-srgb": !0, "bc2-rgba-unorm": !0, "bc2-rgba-unorm-srgb": !0, "bc3-rgba-unorm": !0, "bc3-rgba-unorm-srgb": !0, "bc4-r-unorm": !0, "bc4-r-snorm": !0, "bc5-rg-unorm": !0, "bc5-rg-snorm": !0, "bc6h-rgb-ufloat": !0, "bc6h-rgb-float": !0, "bc7-rgba-unorm": !0, "bc7-rgba-unorm-srgb": !0, "etc2-rgb8unorm": !0, "etc2-rgb8unorm-srgb": !0, "etc2-rgb8a1unorm": !0, "etc2-rgb8a1unorm-srgb": !0, "etc2-rgba8unorm": !0, "etc2-rgba8unorm-srgb": !0, "eac-r11unorm": !0, "eac-r11snorm": !0, "eac-rg11unorm": !0, "eac-rg11snorm": !0, "astc-4x4-unorm": !0, "astc-4x4-unorm-srgb": !0, "astc-5x4-unorm": !0, "astc-5x4-unorm-srgb": !0, "astc-5x5-unorm": !0, "astc-5x5-unorm-srgb": !0, "astc-6x5-unorm": !0, "astc-6x5-unorm-srgb": !0, "astc-6x6-unorm": !0, "astc-6x6-unorm-srgb": !0, "astc-8x5-unorm": !0, "astc-8x5-unorm-srgb": !0, "astc-8x6-unorm": !0, "astc-8x6-unorm-srgb": !0, "astc-8x8-unorm": !0, "astc-8x8-unorm-srgb": !0, "astc-10x5-unorm": !0, "astc-10x5-unorm-srgb": !0, "astc-10x6-unorm": !0, "astc-10x6-unorm-srgb": !0, "astc-10x8-unorm": !0, "astc-10x8-unorm-srgb": !0, "astc-10x10-unorm": !0, "astc-10x10-unorm-srgb": !0, "astc-12x10-unorm": !0, "astc-12x10-unorm-srgb": !0, "astc-12x12-unorm": !0, "astc-12x12-unorm-srgb": !0 }, Za = { id: "compressed", upload(t, s, e) { e.pixelStorei(e.UNPACK_ALIGNMENT, 4); let i = t.pixelWidth, n = t.pixelHeight; const r = !!Ka[t.format]; for (let o = 0; o < t.resource.length; o++) { const h = t.resource[o]; r ? e.compressedTexImage2D(e.TEXTURE_2D, o, s.internalFormat, i, n, 0, h) : e.texImage2D(e.TEXTURE_2D, o, s.internalFormat, i, n, 0, s.format, s.type, h), i = Math.max(i >> 1, 1), n = Math.max(n >> 1, 1) } } }, Qa = { id: "image", upload(t, s, e, i) { const n = s.width, r = s.height, o = t.pixelWidth, h = t.pixelHeight, a = t.resourceWidth, l = t.resourceHeight; a < o || l < h ? (n === o && r === h || e.texImage2D(s.target, 0, s.internalFormat, o, h, 0, s.format, s.type, null), 2 === i ? e.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, a, l, s.format, s.type, t.resource) : e.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, s.format, s.type, t.resource)) : n === o && r === h ? e.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, s.format, s.type, t.resource) : 2 === i ? e.texImage2D(s.target, 0, s.internalFormat, o, h, 0, s.format, s.type, t.resource) : e.texImage2D(s.target, 0, s.internalFormat, s.format, s.type, t.resource), s.width = o, s.height = h } }, Ja = { id: "video", upload(t, s, e, i) { t.isValid ? Qa.upload(t, s, e, i) : e.texImage2D(s.target, 0, s.internalFormat, 1, 1, 0, s.format, s.type, null) } }, tl = { linear: 9729, nearest: 9728 }, sl = { linear: { linear: 9987, nearest: 9985 }, nearest: { linear: 9986, nearest: 9984 } }, el = { "clamp-to-edge": 33071, repeat: 10497, "mirror-repeat": 33648 }, il = { never: 512, less: 513, equal: 514, "less-equal": 515, greater: 516, "not-equal": 517, "greater-equal": 518, always: 519 }; function nl(t, s, e, i, n, r, o, h) { const a = r; if (!h || "repeat" !== t.addressModeU || "repeat" !== t.addressModeV || "repeat" !== t.addressModeW) { const e = el[o ? "clamp-to-edge" : t.addressModeU], i = el[o ? "clamp-to-edge" : t.addressModeV], r = el[o ? "clamp-to-edge" : t.addressModeW]; s[n](a, s.TEXTURE_WRAP_S, e), s[n](a, s.TEXTURE_WRAP_T, i), s.TEXTURE_WRAP_R && s[n](a, s.TEXTURE_WRAP_R, r) } if (h && "linear" === t.magFilter || s[n](a, s.TEXTURE_MAG_FILTER, tl[t.magFilter]), e) { if (!h || "linear" !== t.mipmapFilter) { const e = sl[t.minFilter][t.mipmapFilter]; s[n](a, s.TEXTURE_MIN_FILTER, e) } } else s[n](a, s.TEXTURE_MIN_FILTER, tl[t.minFilter]); if (i && t.maxAnisotropy > 1) { const e = Math.min(t.maxAnisotropy, s.getParameter(i.MAX_TEXTURE_MAX_ANISOTROPY_EXT)); s[n](a, i.TEXTURE_MAX_ANISOTROPY_EXT, e) } t.compare && s[n](a, s.TEXTURE_COMPARE_FUNC, il[t.compare]) } class rl { constructor(t) { this.managedTextures = [], this.Sa = Object.create(null), this.Pa = Object.create(null), this.ka = [], this.Fa = -1, this.Ea = Object.create(null), this.Ra = { image: Qa, buffer: Ya, video: Ja, compressed: Za }, this.Oa = !1, this.Ua = !1, this.Be = t, this.Be.renderableGC.addManagedHash(this, "_glTextures"), this.Be.renderableGC.addManagedHash(this, "_glSamplers") } contextChange(t) { this.Th = t, this.Ia || (this.Ia = function (t, s) { let e = {}, i = t.RGBA; return t instanceof ks.get().getWebGLRenderingContext() ? s.srgb && (e = { "rgba8unorm-srgb": s.srgb.SRGB8_ALPHA8_EXT, "bgra8unorm-srgb": s.srgb.SRGB8_ALPHA8_EXT }) : (e = { "rgba8unorm-srgb": t.SRGB8_ALPHA8, "bgra8unorm-srgb": t.SRGB8_ALPHA8 }, i = t.RGBA8), { r8unorm: t.R8, r8snorm: t.R8_SNORM, r8uint: t.R8UI, r8sint: t.R8I, r16uint: t.R16UI, r16sint: t.R16I, r16float: t.R16F, rg8unorm: t.RG8, rg8snorm: t.RG8_SNORM, rg8uint: t.RG8UI, rg8sint: t.RG8I, r32uint: t.R32UI, r32sint: t.R32I, r32float: t.R32F, rg16uint: t.RG16UI, rg16sint: t.RG16I, rg16float: t.RG16F, rgba8unorm: t.RGBA, ...e, rgba8snorm: t.RGBA8_SNORM, rgba8uint: t.RGBA8UI, rgba8sint: t.RGBA8I, bgra8unorm: i, rgb9e5ufloat: t.RGB9_E5, rgb10a2unorm: t.RGB10_A2, rg11b10ufloat: t.R11F_G11F_B10F, rg32uint: t.RG32UI, rg32sint: t.RG32I, rg32float: t.RG32F, rgba16uint: t.RGBA16UI, rgba16sint: t.RGBA16I, rgba16float: t.RGBA16F, rgba32uint: t.RGBA32UI, rgba32sint: t.RGBA32I, rgba32float: t.RGBA32F, stencil8: t.STENCIL_INDEX8, depth16unorm: t.DEPTH_COMPONENT16, depth24plus: t.DEPTH_COMPONENT24, "depth24plus-stencil8": t.DEPTH24_STENCIL8, depth32float: t.DEPTH_COMPONENT32F, "depth32float-stencil8": t.DEPTH32F_STENCIL8, ...s.s3tc ? { "bc1-rgba-unorm": s.s3tc.COMPRESSED_RGBA_S3TC_DXT1_EXT, "bc2-rgba-unorm": s.s3tc.COMPRESSED_RGBA_S3TC_DXT3_EXT, "bc3-rgba-unorm": s.s3tc.COMPRESSED_RGBA_S3TC_DXT5_EXT } : {}, ...s.s3tc_sRGB ? { "bc1-rgba-unorm-srgb": s.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT, "bc2-rgba-unorm-srgb": s.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT, "bc3-rgba-unorm-srgb": s.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT } : {}, ...s.rgtc ? { "bc4-r-unorm": s.rgtc.COMPRESSED_RED_RGTC1_EXT, "bc4-r-snorm": s.rgtc.COMPRESSED_SIGNED_RED_RGTC1_EXT, "bc5-rg-unorm": s.rgtc.COMPRESSED_RED_GREEN_RGTC2_EXT, "bc5-rg-snorm": s.rgtc.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT } : {}, ...s.bptc ? { "bc6h-rgb-float": s.bptc.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT, "bc6h-rgb-ufloat": s.bptc.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT, "bc7-rgba-unorm": s.bptc.COMPRESSED_RGBA_BPTC_UNORM_EXT, "bc7-rgba-unorm-srgb": s.bptc.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT } : {}, ...s.etc ? { "etc2-rgb8unorm": s.etc.COMPRESSED_RGB8_ETC2, "etc2-rgb8unorm-srgb": s.etc.COMPRESSED_SRGB8_ETC2, "etc2-rgb8a1unorm": s.etc.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2, "etc2-rgb8a1unorm-srgb": s.etc.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2, "etc2-rgba8unorm": s.etc.COMPRESSED_RGBA8_ETC2_EAC, "etc2-rgba8unorm-srgb": s.etc.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC, "eac-r11unorm": s.etc.COMPRESSED_R11_EAC, "eac-rg11unorm": s.etc.COMPRESSED_SIGNED_RG11_EAC } : {}, ...s.astc ? { "astc-4x4-unorm": s.astc.COMPRESSED_RGBA_ASTC_4x4_KHR, "astc-4x4-unorm-srgb": s.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR, "astc-5x4-unorm": s.astc.COMPRESSED_RGBA_ASTC_5x4_KHR, "astc-5x4-unorm-srgb": s.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR, "astc-5x5-unorm": s.astc.COMPRESSED_RGBA_ASTC_5x5_KHR, "astc-5x5-unorm-srgb": s.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR, "astc-6x5-unorm": s.astc.COMPRESSED_RGBA_ASTC_6x5_KHR, "astc-6x5-unorm-srgb": s.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR, "astc-6x6-unorm": s.astc.COMPRESSED_RGBA_ASTC_6x6_KHR, "astc-6x6-unorm-srgb": s.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR, "astc-8x5-unorm": s.astc.COMPRESSED_RGBA_ASTC_8x5_KHR, "astc-8x5-unorm-srgb": s.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR, "astc-8x6-unorm": s.astc.COMPRESSED_RGBA_ASTC_8x6_KHR, "astc-8x6-unorm-srgb": s.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR, "astc-8x8-unorm": s.astc.COMPRESSED_RGBA_ASTC_8x8_KHR, "astc-8x8-unorm-srgb": s.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR, "astc-10x5-unorm": s.astc.COMPRESSED_RGBA_ASTC_10x5_KHR, "astc-10x5-unorm-srgb": s.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR, "astc-10x6-unorm": s.astc.COMPRESSED_RGBA_ASTC_10x6_KHR, "astc-10x6-unorm-srgb": s.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR, "astc-10x8-unorm": s.astc.COMPRESSED_RGBA_ASTC_10x8_KHR, "astc-10x8-unorm-srgb": s.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR, "astc-10x10-unorm": s.astc.COMPRESSED_RGBA_ASTC_10x10_KHR, "astc-10x10-unorm-srgb": s.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR, "astc-12x10-unorm": s.astc.COMPRESSED_RGBA_ASTC_12x10_KHR, "astc-12x10-unorm-srgb": s.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR, "astc-12x12-unorm": s.astc.COMPRESSED_RGBA_ASTC_12x12_KHR, "astc-12x12-unorm-srgb": s.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR } : {} } }(t, this.Be.context.extensions), this.Ba = function (t) { return { r8unorm: t.UNSIGNED_BYTE, r8snorm: t.BYTE, r8uint: t.UNSIGNED_BYTE, r8sint: t.BYTE, r16uint: t.UNSIGNED_SHORT, r16sint: t.SHORT, r16float: t.HALF_FLOAT, rg8unorm: t.UNSIGNED_BYTE, rg8snorm: t.BYTE, rg8uint: t.UNSIGNED_BYTE, rg8sint: t.BYTE, r32uint: t.UNSIGNED_INT, r32sint: t.INT, r32float: t.FLOAT, rg16uint: t.UNSIGNED_SHORT, rg16sint: t.SHORT, rg16float: t.HALF_FLOAT, rgba8unorm: t.UNSIGNED_BYTE, "rgba8unorm-srgb": t.UNSIGNED_BYTE, rgba8snorm: t.BYTE, rgba8uint: t.UNSIGNED_BYTE, rgba8sint: t.BYTE, bgra8unorm: t.UNSIGNED_BYTE, "bgra8unorm-srgb": t.UNSIGNED_BYTE, rgb9e5ufloat: t.UNSIGNED_INT_5_9_9_9_REV, rgb10a2unorm: t.UNSIGNED_INT_2_10_10_10_REV, rg11b10ufloat: t.UNSIGNED_INT_10F_11F_11F_REV, rg32uint: t.UNSIGNED_INT, rg32sint: t.INT, rg32float: t.FLOAT, rgba16uint: t.UNSIGNED_SHORT, rgba16sint: t.SHORT, rgba16float: t.HALF_FLOAT, rgba32uint: t.UNSIGNED_INT, rgba32sint: t.INT, rgba32float: t.FLOAT, stencil8: t.UNSIGNED_BYTE, depth16unorm: t.UNSIGNED_SHORT, depth24plus: t.UNSIGNED_INT, "depth24plus-stencil8": t.UNSIGNED_INT_24_8, depth32float: t.FLOAT, "depth32float-stencil8": t.FLOAT_32_UNSIGNED_INT_24_8_REV } }(t), this.$a = function (t) { return { r8unorm: t.RED, r8snorm: t.RED, r8uint: t.RED, r8sint: t.RED, r16uint: t.RED, r16sint: t.RED, r16float: t.RED, rg8unorm: t.RG, rg8snorm: t.RG, rg8uint: t.RG, rg8sint: t.RG, r32uint: t.RED, r32sint: t.RED, r32float: t.RED, rg16uint: t.RG, rg16sint: t.RG, rg16float: t.RG, rgba8unorm: t.RGBA, "rgba8unorm-srgb": t.RGBA, rgba8snorm: t.RGBA, rgba8uint: t.RGBA, rgba8sint: t.RGBA, bgra8unorm: t.RGBA, "bgra8unorm-srgb": t.RGBA, rgb9e5ufloat: t.RGB, rgb10a2unorm: t.RGBA, rg11b10ufloat: t.RGB, rg32uint: t.RG, rg32sint: t.RG, rg32float: t.RG, rgba16uint: t.RGBA, rgba16sint: t.RGBA, rgba16float: t.RGBA, rgba32uint: t.RGBA, rgba32sint: t.RGBA, rgba32float: t.RGBA, stencil8: t.STENCIL_INDEX8, depth16unorm: t.DEPTH_COMPONENT, depth24plus: t.DEPTH_COMPONENT, "depth24plus-stencil8": t.DEPTH_STENCIL, depth32float: t.DEPTH_COMPONENT, "depth32float-stencil8": t.DEPTH_STENCIL } }(t)), this.Sa = Object.create(null), this.Pa = Object.create(null), this.Ea = Object.create(null), this.Oa = !1; for (let s = 0; s < 16; s++)this.bind(Z.EMPTY, s) } initSource(t) { this.bind(t) } bind(t, s = 0) { const e = t.source; t ? (this.bindSource(e, s), this.Ua && this.Ga(e.style, s)) : (this.bindSource(null, s), this.Ua && this.Ga(null, s)) } bindSource(t, s = 0) { const e = this.Th; if (t.R = this.Be.textureGC.count, this.ka[s] !== t) { this.ka[s] = t, this.za(s), t || (t = Z.EMPTY.source); const i = this.getGlSource(t); e.bindTexture(i.target, i.texture) } } Ga(t, s = 0) { const e = this.Th; if (!t) return this.Ea[s] = null, void e.bindSampler(s, null); const i = this.Da(t); this.Ea[s] !== i && (this.Ea[s] = i, e.bindSampler(s, i)) } unbind(t) { const s = t.source, e = this.ka, i = this.Th; for (let n = 0; n < e.length; n++)if (e[n] === s) { this.za(n); const t = this.getGlSource(s); i.bindTexture(t.target, null), e[n] = null } } za(t) { this.Fa !== t && (this.Fa = t, this.Th.activeTexture(this.Th.TEXTURE0 + t)) } ja(t) { const s = this.Th, e = new Xa(s.createTexture()); if (e.type = this.Ba[t.format], e.internalFormat = this.Ia[t.format], e.format = this.$a[t.format], t.autoGenerateMipmaps && (this.Be.context.supports.nonPowOf2mipmaps || t.isPowerOfTwo)) { const s = Math.max(t.width, t.height); t.mipLevelCount = Math.floor(Math.log2(s)) + 1 } return this.Sa[t.uid] = e, this.managedTextures.includes(t) || (t.on("update", this.onSourceUpdate, this), t.on("resize", this.onSourceUpdate, this), t.on("styleChange", this.onStyleChange, this), t.on("destroy", this.onSourceDestroy, this), t.on("unload", this.onSourceUnload, this), t.on("updateMipmaps", this.onUpdateMipmaps, this), this.managedTextures.push(t)), this.onSourceUpdate(t), this.updateStyle(t, !1), e } onStyleChange(t) { this.updateStyle(t, !1) } updateStyle(t, s) { const e = this.Th, i = this.getGlSource(t); e.bindTexture(e.TEXTURE_2D, i.texture), this.ka[this.Fa] = t, nl(t.style, e, t.mipLevelCount > 1, this.Be.context.extensions.anisotropicFiltering, "texParameteri", e.TEXTURE_2D, !this.Be.context.supports.nonPowOf2wrapping && !t.isPowerOfTwo, s) } onSourceUnload(t) { const s = this.Sa[t.uid]; s && (this.unbind(t), this.Sa[t.uid] = null, this.Th.deleteTexture(s.texture)) } onSourceUpdate(t) { const s = this.Th, e = this.getGlSource(t); s.bindTexture(s.TEXTURE_2D, e.texture), this.ka[this.Fa] = t; const i = "premultiply-alpha-on-upload" === t.alphaMode; this.Oa !== i && (this.Oa = i, s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i)), this.Ra[t.uploadMethodId] ? this.Ra[t.uploadMethodId].upload(t, e, s, this.Be.context.webGLVersion) : s.texImage2D(s.TEXTURE_2D, 0, s.RGBA, t.pixelWidth, t.pixelHeight, 0, s.RGBA, s.UNSIGNED_BYTE, null), t.autoGenerateMipmaps && t.mipLevelCount > 1 && this.onUpdateMipmaps(t, !1) } onUpdateMipmaps(t, s = !0) { s && this.bindSource(t, 0); const e = this.getGlSource(t); this.Th.generateMipmap(e.target) } onSourceDestroy(t) { t.off("destroy", this.onSourceDestroy, this), t.off("update", this.onSourceUpdate, this), t.off("resize", this.onSourceUpdate, this), t.off("unload", this.onSourceUnload, this), t.off("styleChange", this.onStyleChange, this), t.off("updateMipmaps", this.onUpdateMipmaps, this), this.managedTextures.splice(this.managedTextures.indexOf(t), 1), this.onSourceUnload(t) } La(t) { const s = this.Th, e = this.Th.createSampler(); return this.Pa[t.U] = e, nl(t, s, this.ka[this.Fa].mipLevelCount > 1, this.Be.context.extensions.anisotropicFiltering, "samplerParameteri", e, !1, !0), this.Pa[t.U] } Da(t) { return this.Pa[t.U] || this.La(t) } getGlSource(t) { return this.Sa[t.uid] || this.ja(t) } generateCanvas(t) { const { pixels: s, width: e, height: i } = this.getPixels(t), n = ks.get().createCanvas(); n.width = e, n.height = i; const r = n.getContext("2d"); if (r) { const t = r.createImageData(e, i); t.data.set(s), r.putImageData(t, 0, 0) } return n } getPixels(t) { const s = t.source.resolution, e = t.frame, i = Math.max(Math.round(e.width * s), 1), n = Math.max(Math.round(e.height * s), 1), r = new Uint8Array(4 * i * n), o = this.Be, h = o.renderTarget.getRenderTarget(t), a = o.renderTarget.getGpuRenderTarget(h), l = o.gl; return l.bindFramebuffer(l.FRAMEBUFFER, a.resolveTargetFramebuffer), l.readPixels(Math.round(e.x * s), Math.round(e.y * s), i, n, l.RGBA, l.UNSIGNED_BYTE, r), { pixels: new Uint8ClampedArray(r.buffer), width: i, height: n } } destroy() { this.managedTextures.slice().forEach(t => this.onSourceDestroy(t)), this.managedTextures = null, this.Sa = null, this.Pa = null, this.ka = null, this.Ea = null, this.Ia = null, this.Ba = null, this.$a = null, this.Ra = null, this.Be = null } resetState() { this.Fa = -1, this.ka.fill(Z.EMPTY.source), this.Ea = Object.create(null); const t = this.Th; this.Oa = !1, t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.Oa) } } rl.extension = { type: [r.WebGLSystem], name: "texture" }; class ol { contextChange(t) { const s = new Ye({ uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" }, uTransformMatrix: { value: new w, type: "mat3x3<f32>" }, uRound: { value: 0, type: "f32" } }), e = t.limits.maxBatchableTextures, i = cr({ name: "graphics", bits: [dr, yr(e), Bh, Mr] }); this.shader = new Qe({ glProgram: i, resources: { localUniforms: s, batchSamplers: Ar(e) } }) } execute(t, s) { const e = s.context, i = e.customShader || this.shader, n = t.renderer, r = n.graphicsContext, { batcher: o, instructions: h } = r.getContextRenderData(e); i.groups[0] = n.globalUniforms.bindGroup, n.state.set(t.state), n.shader.bind(i), n.geometry.bind(o.geometry, i.glProgram); const a = h.instructions; for (let l = 0; l < h.instructionSize; l++) { const t = a[l]; if (t.size) { for (let s = 0; s < t.textures.count; s++)n.texture.bind(t.textures.textures[s], s); n.geometry.draw(t.topology, t.size, t.start) } } } destroy() { this.shader.destroy(!0), this.shader = null } } ol.extension = { type: [r.WebGLPipesAdaptor], name: "graphics" }; class hl { init() { const t = cr({ name: "mesh", bits: [Bh, Gh, Mr] }); this.Jo = new Qe({ glProgram: t, resources: { uTexture: Z.EMPTY.source, textureUniforms: { uTextureMatrix: { type: "mat3x3<f32>", value: new w } } } }) } execute(t, s) { const e = t.renderer; let i = s.Jo; if (i) { if (!i.glProgram) return void Et(s.shader) } else { i = this.Jo; const t = s.texture, e = t.source; i.resources.uTexture = e, i.resources.uSampler = e.style, i.resources.textureUniforms.uniforms.uTextureMatrix = t.textureMatrix.mapCoord } i.groups[100] = e.globalUniforms.bindGroup, i.groups[101] = t.localUniformsBindGroup, e.encoder.draw({ geometry: s.th, shader: i, state: s.state }) } destroy() { this.Jo.destroy(!0), this.Jo = null } } hl.extension = { type: [r.WebGLPipesAdaptor], name: "mesh" }; class al { constructor(t) { this.Be = t } updateRenderable() { } destroyRenderable() { } validateRenderable() { return !1 } addRenderable(t, s) { this.Be.renderPipes.batch.break(s), s.add(t) } execute(t) { t.isRenderable && t.render(this.Be) } destroy() { this.Be = null } } al.extension = { type: [r.WebGLPipes, r.WebGPUPipes, r.CanvasPipes], name: "customRender" }; class ll { constructor() { this.batcherName = "default", this.topology = "triangle-list", this.attributeSize = 4, this.indexSize = 6, this.packAsQuad = !0, this.roundPixels = 0, this.Un = 0, this.In = null, this.Bn = null } get blendMode() { return this.renderable.groupBlendMode } get color() { return this.renderable.groupColorAlpha } reset() { this.renderable = null, this.texture = null, this.In = null, this.Bn = null, this.bounds = null } destroy() { } } function ul(t, s) { const e = t.instructionSet, i = e.instructions; for (let n = 0; n < e.instructionSize; n++) { const t = i[n]; s[t.renderPipeId].execute(t) } } const cl = new w; class fl { constructor(t) { this.Be = t } addRenderGroup(t, s) { t.isCachedAsTexture ? this.Va(t, s) : this.Na(t, s) } execute(t) { t.isRenderable && (t.isCachedAsTexture ? this.Wa(t) : this.Ha(t)) } destroy() { this.Be = null } Na(t, s) { this.Be.renderPipes.batch.break(s), t.qa && (Ut.return(t.qa), t.qa = null), s.add(t) } Va(t, s) { const e = t.qa ?? (t.qa = Ut.get(ll)); e.renderable = t.root, e.transform = t.root.relativeGroupTransform, e.texture = t.texture, e.bounds = t.Xt, s.add(t), this.Be.renderPipes.blendMode.pushBlendMode(t, t.root.groupBlendMode, s), this.Be.renderPipes.batch.addToBatch(e, s), this.Be.renderPipes.blendMode.popBlendMode(s) } Wa(t) { if (t.textureNeedsUpdate) { t.textureNeedsUpdate = !1; const s = cl.identity().translate(-t.Xt.x, -t.Xt.y); this.Be.renderTarget.push(t.texture, !0, null, t.texture.frame), this.Be.globalUniforms.push({ worldTransformMatrix: s, worldColor: 4294967295, offset: { x: 0, y: 0 } }), ul(t, this.Be.renderPipes), this.Be.renderTarget.finishRenderPass(), this.Be.renderTarget.pop(), this.Be.globalUniforms.pop() } t.qa.In.updateElement(t.qa), t.qa.In.geometry.buffers[0].update() } Ha(t) { this.Be.globalUniforms.push({ worldTransformMatrix: t.inverseParentTextureTransform, worldColor: t.worldColorAlpha }), ul(t, this.Be.renderPipes), this.Be.globalUniforms.pop() } } function dl(t, s) { s || (s = 0); for (let e = s; e < t.length && t[e]; e++)t[e] = null } fl.extension = { type: [r.WebGLPipes, r.WebGPUPipes, r.CanvasPipes], name: "renderGroup" }; const pl = new bs; function ml(t, s = !1) { !function (t) { const s = t.root; let e; if (t.renderGroupParent) { const i = t.renderGroupParent; t.worldTransform.appendFrom(s.relativeGroupTransform, i.worldTransform), t.worldColor = Qt(s.groupColor, i.worldColor), e = s.groupAlpha * i.worldAlpha } else t.worldTransform.copyFrom(s.localTransform), t.worldColor = s.localColor, e = s.localAlpha; e = e < 0 ? 0 : e > 1 ? 1 : e, t.worldAlpha = e, t.worldColorAlpha = t.worldColor + (255 * e << 24) }(t); const e = t.childrenToUpdate, i = t.updateTick++; for (const n in e) { const s = Number(n), r = e[n], o = r.list, h = r.index; for (let e = 0; e < h; e++) { const n = o[e]; n.parentRenderGroup === t && n.relativeRenderGroupDepth === s && gl(n, i, 0) } dl(o, h), r.index = 0 } if (s) for (let n = 0; n < t.renderGroupChildren.length; n++)ml(t.renderGroupChildren[n], s) } function gl(t, s, e) { if (s === t.updateTick) return; t.updateTick = s, t.didChange = !1; const i = t.localTransform; t.updateLocalTransform(); const n = t.parent; if (n && !n.renderGroup ? (e |= t.wt, t.relativeGroupTransform.appendFrom(i, n.relativeGroupTransform), 7 & e && vl(t, n, e)) : (e = t.wt, t.relativeGroupTransform.copyFrom(i), 7 & e && vl(t, pl, e)), !t.renderGroup) { const i = t.children, n = i.length; for (let t = 0; t < n; t++)gl(i[t], s, e); const r = t.parentRenderGroup, o = t; o.renderPipeId && !r.structureDidChange && r.updateRenderable(o) } } function vl(t, s, e) { if (1 & e) { t.groupColor = Qt(t.localColor, s.groupColor); let e = t.localAlpha * s.groupAlpha; e = e < 0 ? 0 : e > 1 ? 1 : e, t.groupAlpha = e, t.groupColorAlpha = t.groupColor + (255 * e << 24) } 2 & e && (t.groupBlendMode = "inherit" === t.localBlendMode ? s.groupBlendMode : t.localBlendMode), 4 & e && (t.globalDisplayStatus = t.localDisplayStatus & s.globalDisplayStatus), t.wt = 0 } const bl = new w; class xl { constructor(t) { this.Be = t } render({ container: t, transform: s }) { const e = t.parent, i = t.renderGroup.renderGroupParent; t.parent = null, t.renderGroup.renderGroupParent = null; const n = this.Be, r = bl; s && (r.copyFrom(t.renderGroup.localTransform), t.renderGroup.localTransform.copyFrom(s)); const o = n.renderPipes; this.Xa(t.renderGroup, null), this.Ya(t.renderGroup), n.globalUniforms.start({ worldTransformMatrix: s ? t.renderGroup.localTransform : t.renderGroup.worldTransform, worldColor: t.renderGroup.worldColorAlpha }), ul(t.renderGroup, o), o.uniformBatch && o.uniformBatch.renderEnd(), s && t.renderGroup.localTransform.copyFrom(r), t.parent = e, t.renderGroup.renderGroupParent = i } destroy() { this.Be = null } Xa(t, s) { if (t.Vt = s, t.isCachedAsTexture) { if (!t.textureNeedsUpdate) return; s = t } for (let e = t.renderGroupChildren.length - 1; e >= 0; e--)this.Xa(t.renderGroupChildren[e], s); if (t.invalidateMatrices(), t.isCachedAsTexture) { if (t.textureNeedsUpdate) { const s = t.root.getLocalBounds(); s.ceil(); const e = t.texture; t.texture && fs.returnTexture(t.texture, !0); const i = this.Be, n = t.textureOptions.resolution || i.view.resolution, r = t.textureOptions.antialias ?? i.view.antialias, o = t.textureOptions.scaleMode ?? "linear", h = fs.getOptimalTexture(s.width, s.height, n, r); h.K.style = new W({ scaleMode: o }), t.texture = h, t.Xt || (t.Xt = new tt), t.Xt.copyFrom(s), e !== t.texture && t.renderGroupParent && (t.renderGroupParent.structureDidChange = !0) } } else t.texture && (fs.returnTexture(t.texture, !0), t.texture = null) } Ya(t) { const s = this.Be, e = s.renderPipes; if (t.runOnRender(s), t.instructionSet.renderPipes = e, t.structureDidChange ? dl(t.childrenRenderablesToUpdate.list, 0) : function (t, s) { const { list: e } = t.childrenRenderablesToUpdate; let i = !1; for (let n = 0; n < t.childrenRenderablesToUpdate.index; n++) { const t = e[n]; if (i = s[t.renderPipeId].validateRenderable(t), i) break } t.structureDidChange = i }(t, e), ml(t), t.structureDidChange ? (t.structureDidChange = !1, this.Ka(t, s)) : this.Za(t), t.childrenRenderablesToUpdate.index = 0, s.renderPipes.batch.upload(t.instructionSet), !t.isCachedAsTexture || t.textureNeedsUpdate) for (let i = 0; i < t.renderGroupChildren.length; i++)this.Ya(t.renderGroupChildren[i]) } Za(t) { const { list: s, index: e } = t.childrenRenderablesToUpdate; for (let i = 0; i < e; i++) { const e = s[i]; e.didViewUpdate && t.updateRenderable(e) } dl(s, e) } Ka(t, s) { const e = t.root, i = t.instructionSet; i.reset(); const n = s.renderPipes ? s : s.batch.renderer, r = n.renderPipes; r.batch.buildStart(i), r.blendMode.buildStart(), r.colorMask.buildStart(), e.sortableChildren && e.sortChildren(), e.collectRenderablesWithEffects(i, n, null), r.batch.buildEnd(i), r.blendMode.buildEnd(i) } } xl.extension = { type: [r.WebGLSystem, r.WebGPUSystem, r.CanvasSystem], name: "renderGroup" }; class yl { constructor(t) { this.Be = t } addRenderable(t, s) { const e = this.Qa(t); t.didViewUpdate && this.Ja(t, e), this.Be.renderPipes.batch.addToBatch(e, s) } updateRenderable(t) { const s = this.Qa(t); t.didViewUpdate && this.Ja(t, s), s.In.updateElement(s) } validateRenderable(t) { const s = this.Qa(t); return !s.In.checkAndUpdateTexture(s, t.Y) } Ja(t, s) { s.bounds = t.visualBounds, s.texture = t.Y } Qa(t) { return t.ps[this.Be.uid] || this.tl(t) } tl(t) { const s = new ll; return s.renderable = t, s.transform = t.groupTransform, s.texture = t.Y, s.bounds = t.visualBounds, s.roundPixels = this.Be.fs | t.fs, t.ps[this.Be.uid] = s, s } destroy() { this.Be = null } } yl.extension = { type: [r.WebGLPipes, r.WebGPUPipes, r.CanvasPipes], name: "sprite" }; const wl = class t { constructor() { this.clearBeforeRender = !0, this.sl = new kt(0), this.color = this.sl, this.alpha = 1 } init(s) { s = { ...t.defaultOptions, ...s }, this.clearBeforeRender = s.clearBeforeRender, this.color = s.background || s.backgroundColor || this.sl, this.alpha = s.backgroundAlpha, this.sl.setAlpha(s.backgroundAlpha) } get color() { return this.sl } set color(t) { kt.shared.setValue(t).alpha < 1 && 1 === this.sl.alpha && Et(), this.sl.setValue(t) } get alpha() { return this.sl.alpha } set alpha(t) { this.sl.setAlpha(t) } get colorRgba() { return this.sl.toArray() } destroy() { } }; wl.extension = { type: [r.WebGLSystem, r.WebGPUSystem, r.CanvasSystem], name: "background", priority: 0 }, wl.defaultOptions = { backgroundAlpha: 1, backgroundColor: 0, clearBeforeRender: !0 }; let Ml = wl; const Tl = {}; a.handle(r.BlendMode, t => { if (!t.name) throw new Error("BlendMode extension must have a name property"); Tl[t.name] = t.ref }, t => { delete Tl[t.name] }); class Al { constructor(t) { this.el = [], this.il = !1, this.nl = Object.create(null), this.Be = t, this.Be.runners.prerender.add(this) } prerender() { this.rl = "normal", this.il = !1 } pushBlendMode(t, s, e) { this.el.push(s), this.setBlendMode(t, s, e) } popBlendMode(t) { this.el.pop(); const s = this.el[this.rl.length - 1] ?? "normal"; this.setBlendMode(null, s, t) } setBlendMode(t, s, e) { const i = t instanceof ds; this.rl !== s ? (this.il && this.ol(e), this.rl = s, t && (this.il = !!Tl[s], this.il && this.hl(t, e))) : this.il && t && !i && this.al?.push(t) } hl(t, s) { this.Be.renderPipes.batch.break(s); const e = this.rl; if (!Tl[e]) return void Et(); const i = this.ll(e), n = t instanceof ds, r = { renderPipeId: "filter", action: "pushFilter", filterEffect: i, renderables: n ? null : [t], container: n ? t.root : null, canBundle: !1 }; this.al = r.renderables, s.add(r) } ll(t) { let s = this.nl[t]; return s || (s = this.nl[t] = new zt, s.filters = [new Tl[t]]), s } ol(t) { this.il = !1, this.al = null, this.Be.renderPipes.batch.break(t), t.add({ renderPipeId: "filter", action: "popFilter", canBundle: !1 }) } buildStart() { this.il = !1 } buildEnd(t) { this.il && this.ol(t) } destroy() { this.Be = null, this.al = null; for (const t in this.nl) this.nl[t].destroy(); this.nl = null } } Al.extension = { type: [r.WebGLPipes, r.WebGPUPipes, r.CanvasPipes], name: "blendMode" }; const Cl = { png: "image/png", jpg: "image/jpeg", webp: "image/webp" }, _l = class t { constructor(t) { this.Be = t } ul(t, s = {}) { return t instanceof bs || t instanceof Z ? { target: t, ...s } : { ...s, ...t } } async image(t) { const s = ks.get().createImage(); return s.src = await this.base64(t), s } async base64(s) { s = this.ul(s, t.defaultImageOptions); const { format: e, quality: i } = s, n = this.canvas(s); if (void 0 !== n.toBlob) return new Promise((t, s) => { n.toBlob(e => { if (!e) return void s(new Error("ICanvas.toBlob failed!")); const i = new FileReader; i.onload = () => t(i.result), i.onerror = s, i.readAsDataURL(e) }, Cl[e], i) }); if (void 0 !== n.toDataURL) return n.toDataURL(Cl[e], i); if (void 0 !== n.convertToBlob) { const t = await n.convertToBlob({ type: Cl[e], quality: i }); return new Promise((s, e) => { const i = new FileReader; i.onload = () => s(i.result), i.onerror = e, i.readAsDataURL(t) }) } throw new Error("Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented") } canvas(t) { const s = (t = this.ul(t)).target, e = this.Be; if (s instanceof Z) return e.texture.generateCanvas(s); const i = e.textureGenerator.generateTexture(t), n = e.texture.generateCanvas(i); return i.destroy(!0), n } pixels(t) { const s = (t = this.ul(t)).target, e = this.Be, i = s instanceof Z ? s : e.textureGenerator.generateTexture(t), n = e.texture.getPixels(i); return s instanceof bs && i.destroy(!0), n } texture(t) { return (t = this.ul(t)).target instanceof Z ? t.target : this.Be.textureGenerator.generateTexture(t) } download(t) { t = this.ul(t); const s = this.canvas(t), e = document.createElement("a"); e.download = t.filename ?? "image.png", e.href = s.toDataURL("image/png"), document.body.appendChild(e), e.click(), document.body.removeChild(e) } log(t) { const s = t.width ?? 200; t = this.ul(t), ["font-size: 1px;", `padding: ${s}px 300px;`, `background: url(${this.canvas(t).toDataURL()}) no-repeat;`, "background-size: contain;"].join(" ") } destroy() { this.Be = null } }; _l.extension = { type: [r.WebGLSystem, r.WebGPUSystem], name: "extract" }, _l.defaultImageOptions = { format: "png", quality: 1 }; let Sl = _l; class Pl extends Z { static create(t) { return new Pl({ source: new q(t) }) } resize(t, s, e) { return this.source.resize(t, s, e), this } } const kl = new O, Fl = new tt, El = [0, 0, 0, 0]; class Rl { constructor(t) { this.Be = t } generateTexture(t) { t instanceof bs && (t = { target: t, frame: void 0, textureSourceOptions: {}, resolution: void 0 }); const s = t.resolution || this.Be.resolution, e = t.antialias || this.Be.view.antialias, i = t.target; let n = t.clearColor; n = n ? Array.isArray(n) && 4 === n.length ? n : kt.shared.setValue(n).toArray() : El; const r = t.frame?.copyTo(kl) || ss(i, Fl).rectangle; r.width = 0 | Math.max(r.width, 1 / s), r.height = 0 | Math.max(r.height, 1 / s); const o = Pl.create({ ...t.textureSourceOptions, width: r.width, height: r.height, resolution: s, antialias: e }), h = w.shared.translate(-r.x, -r.y); return this.Be.render({ container: i, transform: h, target: o, clearColor: n }), o.source.updateMipmaps(), o } destroy() { this.Be = null } } function Ol(t, s, e) { const i = (t >> 24 & 255) / 255; s[e++] = (255 & t) / 255 * i, s[e++] = (t >> 8 & 255) / 255 * i, s[e++] = (t >> 16 & 255) / 255 * i, s[e++] = i } Rl.extension = { type: [r.WebGLSystem, r.WebGPUSystem], name: "textureGenerator" }; class Ul { constructor(t) { this.cl = 0, this.fl = [], this.dl = [], this.pl = [], this.ml = [], this.vl = [], this.Be = t } reset() { this.cl = 0; for (let t = 0; t < this.pl.length; t++)this.dl.push(this.pl[t]); for (let t = 0; t < this.vl.length; t++)this.ml.push(this.vl[t]); this.pl.length = 0, this.vl.length = 0 } start(t) { this.reset(), this.push(t) } bind({ size: t, projectionMatrix: s, worldTransformMatrix: e, worldColor: i, offset: n }) { const r = this.Be.renderTarget.renderTarget, o = this.cl ? this.fl[this.cl - 1] : { worldTransformMatrix: new w, worldColor: 4294967295, offset: new x }, h = { projectionMatrix: s || this.Be.renderTarget.projectionMatrix, resolution: t || r.size, worldTransformMatrix: e || o.worldTransformMatrix, worldColor: i || o.worldColor, offset: n || o.offset, bindGroup: null }, a = this.dl.pop() || this.bl(); this.pl.push(a); const l = a.uniforms; let u; l.uProjectionMatrix = h.projectionMatrix, l.uResolution = h.resolution, l.uWorldTransformMatrix.copyFrom(h.worldTransformMatrix), l.uWorldTransformMatrix.tx -= h.offset.x, l.uWorldTransformMatrix.ty -= h.offset.y, Ol(h.worldColor, l.uWorldColorAlpha, 0), a.update(), this.Be.renderPipes.uniformBatch ? u = this.Be.renderPipes.uniformBatch.getUniformBindGroup(a, !1) : (u = this.ml.pop() || new Ke, this.vl.push(u), u.setResource(a, 0)), h.bindGroup = u, this.xl = h } push(t) { this.bind(t), this.fl[this.cl++] = this.xl } pop() { this.xl = this.fl[--this.cl - 1], this.Be.type === Ze.WEBGL && this.xl.bindGroup.resources[0].update() } get bindGroup() { return this.xl.bindGroup } get globalUniformData() { return this.xl } get uniformGroup() { return this.xl.bindGroup.resources[0] } bl() { return new Ye({ uProjectionMatrix: { value: new w, type: "mat3x3<f32>" }, uWorldTransformMatrix: { value: new w, type: "mat3x3<f32>" }, uWorldColorAlpha: { value: new Float32Array(4), type: "vec4<f32>" }, uResolution: { value: [0, 0], type: "vec2<f32>" } }, { isStatic: !0 }) } destroy() { this.Be = null, this.fl.length = 0, this.dl.length = 0, this.pl.length = 0, this.ml.length = 0, this.vl.length = 0, this.xl = null } } Ul.extension = { type: [r.WebGLSystem, r.WebGPUSystem, r.CanvasSystem], name: "globalUniforms" }; let Il = 1; class Bl { constructor() { this.yl = [], this.wl = 0 } init() { Bs.system.add(this.so, this) } repeat(t, s, e = !0) { const i = Il++; let n = 0; return e && (this.wl += 1e3, n = this.wl), this.yl.push({ func: t, duration: s, start: performance.now(), offset: n, last: performance.now(), repeat: !0, id: i }), i } cancel(t) { for (let s = 0; s < this.yl.length; s++)if (this.yl[s].id === t) return void this.yl.splice(s, 1) } so() { const t = performance.now(); for (let s = 0; s < this.yl.length; s++) { const e = this.yl[s]; if (t - e.offset - e.last >= e.duration) { const s = t - e.start; e.func(s), e.last = t } } } destroy() { Bs.system.remove(this.so, this), this.yl.length = 0 } } Bl.extension = { type: [r.WebGLSystem, r.WebGPUSystem, r.CanvasSystem], name: "scheduler", priority: 0 }; let $l = !1; class Gl { constructor(t) { this.Be = t } init(t) { if (t.hello) { let t = this.Be.name; this.Be.type === Ze.WEBGL && (t += ` ${this.Be.context.webGLVersion}`), function (t) { if (!$l) { if (ks.get().getNavigator().userAgent.toLowerCase().indexOf("chrome") > -1) { const s = [`%c  %c  %c  %c  %c PixiJS %c v${Ni} (${t}) http://www.pixijs.com/\n\n`, "background: #E72264; padding:5px 0;", "background: #6CA2EA; padding:5px 0;", "background: #B5D33D; padding:5px 0;", "background: #FED23F; padding:5px 0;", "color: #FFFFFF; background: #E72264; padding:5px 0;", "color: #E72264; background: #FFFFFF; padding:5px 0;"]; globalThis.console.log(...s) } else globalThis.console && globalThis.console.log(`PixiJS ${Ni} - ${t} - http://www.pixijs.com/`); $l = !0 } }(t) } } } function zl(t) { let s = !1; for (const i in t) if (null == t[i]) { s = !0; break } if (!s) return t; const e = Object.create(null); for (const i in t) { const s = t[i]; s && (e[i] = s) } return e } function Dl(t) { let s = 0; for (let e = 0; e < t.length; e++)null == t[e] ? s++ : t[e - s] = t[e]; return t.length -= s, t } Gl.extension = { type: [r.WebGLSystem, r.WebGPUSystem, r.CanvasSystem], name: "hello", priority: -2 }, Gl.defaultOptions = { hello: !1 }; let jl = 0; const Ll = class t { constructor(t) { this.Ml = [], this.Tl = [], this.Al = [], this.Be = t } init(s) { s = { ...t.defaultOptions, ...s }, this.maxUnusedTime = s.renderableGCMaxUnusedTime, this.Cl = s.renderableGCFrequency, this.enabled = s.renderableGCActive } get enabled() { return !!this._l } set enabled(t) { this.enabled !== t && (t ? (this._l = this.Be.scheduler.repeat(() => this.run(), this.Cl, !1), this.Sl = this.Be.scheduler.repeat(() => { for (const t of this.Tl) t.context[t.hash] = zl(t.context[t.hash]) }, this.Cl), this.Pl = this.Be.scheduler.repeat(() => { for (const t of this.Al) Dl(t.context[t.hash]) }, this.Cl)) : (this.Be.scheduler.cancel(this._l), this.Be.scheduler.cancel(this.Sl), this.Be.scheduler.cancel(this.Pl))) } addManagedHash(t, s) { this.Tl.push({ context: t, hash: s }) } addManagedArray(t, s) { this.Al.push({ context: t, hash: s }) } prerender({ container: t }) { this.kl = performance.now(), t.renderGroup.gcTick = jl++, this.Fl(t.renderGroup, t.renderGroup.gcTick) } addRenderable(t) { this.enabled && (-1 === t.ds && (this.Ml.push(t), t.once("destroyed", this.El, this)), t.ds = this.kl) } run() { const t = this.kl, s = this.Ml, e = this.Be.renderPipes; let i = 0; for (let n = 0; n < s.length; n++) { const r = s[n]; if (null === r) { i++; continue } const o = r.renderGroup ?? r.parentRenderGroup, h = o?.instructionSet?.gcTick ?? -1; if ((o?.gcTick ?? 0) === h && (r.ds = t), t - r.ds > this.maxUnusedTime) { if (!r.destroyed) { const t = e; o && (o.structureDidChange = !0), t[r.renderPipeId].destroyRenderable(r) } r.ds = -1, i++, r.off("destroyed", this.El, this) } else s[n - i] = r } s.length -= i } destroy() { this.enabled = !1, this.Be = null, this.Ml.length = 0, this.Tl.length = 0, this.Al.length = 0 } El(t) { const s = this.Ml.indexOf(t); s >= 0 && (t.off("destroyed", this.El, this), this.Ml[s] = null) } Fl(t, s) { t.instructionSet.gcTick = s; for (const e of t.renderGroupChildren) this.Fl(e, s) } }; Ll.extension = { type: [r.WebGLSystem, r.WebGPUSystem], name: "renderableGC", priority: 0 }, Ll.defaultOptions = { renderableGCActive: !0, renderableGCMaxUnusedTime: 6e4, renderableGCFrequency: 3e4 }; let Vl = Ll; const Nl = class t { constructor(t) { this.Be = t, this.count = 0, this.checkCount = 0 } init(s) { s = { ...t.defaultOptions, ...s }, this.checkCountMax = s.textureGCCheckCountMax, this.maxIdle = s.textureGCAMaxIdle ?? s.textureGCMaxIdle, this.active = s.textureGCActive } postrender() { this.Be.renderingToScreen && (this.count++, this.active && (this.checkCount++, this.checkCount > this.checkCountMax && (this.checkCount = 0, this.run()))) } run() { const t = this.Be.texture.managedTextures; for (let s = 0; s < t.length; s++) { const e = t[s]; e.autoGarbageCollect && e.resource && e.R > -1 && this.count - e.R > this.maxIdle && (e.R = -1, e.unload()) } } destroy() { this.Be = null } }; Nl.extension = { type: [r.WebGLSystem, r.WebGPUSystem], name: "textureGC" }, Nl.defaultOptions = { textureGCActive: !0, textureGCAMaxIdle: null, textureGCMaxIdle: 3600, textureGCCheckCountMax: 600 }; let Wl = Nl; const Hl = class t { get autoDensity() { return this.texture.source.autoDensity } set autoDensity(t) { this.texture.source.autoDensity = t } get resolution() { return this.texture.source.$ } set resolution(t) { this.texture.source.resize(this.texture.source.width, this.texture.source.height, t) } init(s) { (s = { ...t.defaultOptions, ...s }).view && (G(0, "ViewSystem.view has been renamed to ViewSystem.canvas"), s.canvas = s.view), this.screen = new O(0, 0, s.width, s.height), this.canvas = s.canvas || ks.get().createCanvas(), this.antialias = !!s.antialias, this.texture = Ca(this.canvas, s), this.renderTarget = new Sa({ colorTextures: [this.texture], depth: !!s.depth, isRoot: !0 }), this.texture.source.transparent = s.backgroundAlpha < 1, this.resolution = s.resolution } resize(t, s, e) { this.texture.source.resize(t, s, e), this.screen.width = this.texture.frame.width, this.screen.height = this.texture.frame.height } destroy(t = !1) { ("boolean" == typeof t ? t : !!t?.removeView) && this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas), this.texture.destroy() } }; Hl.extension = { type: [r.WebGLSystem, r.WebGPUSystem, r.CanvasSystem], name: "view", priority: 0 }, Hl.defaultOptions = { width: 800, height: 600, autoDensity: !1, antialias: !1 }; const ql = [Ml, Ul, Gl, Hl, xl, Wl, Rl, Sl, Hi, Vl, Bl], Xl = [Al, Oh, yl, fl, jh, Vh, Lh, al], Yl = [...ql, Ma, ra, Xh, aa, Hh, rl, ka, ea, Wa, La, ha, qa, ca, oa], Kl = [...Xl], Zl = [kh, hl, ol], Ql = [], Jl = [], tu = []; a.handleByNamedList(r.WebGLSystem, Ql), a.handleByNamedList(r.WebGLPipes, Jl), a.handleByNamedList(r.WebGLPipesAdaptor, tu), a.add(...Yl, ...Kl, ...Zl); const su = Object.freeze(Object.defineProperty({ __proto__: null, WebGLRenderer: class extends Di { constructor() { super({ name: "webgl", type: Ze.WEBGL, systems: Ql, renderPipes: Jl, renderPipeAdaptors: tu }) } } }, Symbol.toStringTag, { value: "Module" })); class eu { constructor(t) { this.Rl = Object.create(null), this.Be = t, this.Be.renderableGC.addManagedHash(this, "_hash") } contextChange(t) { this.Ol = t } getBindGroup(t, s, e) { return t.Oi(), this.Rl[t.Mi] || this.Ul(t, s, e) } Ul(t, s, e) { const i = this.Ol.device, n = s.layout[e], r = [], o = this.Be; for (const l in n) { const s = t.resources[l] ?? t.resources[n[l]]; let e; if ("uniformGroup" === s.F) { const t = s; o.ubo.updateUniformGroup(t); const i = t.buffer; e = { buffer: o.buffer.getGPUBuffer(i), offset: 0, size: i.descriptor.size } } else if ("buffer" === s.F) { const t = s; e = { buffer: o.buffer.getGPUBuffer(t), offset: 0, size: t.descriptor.size } } else if ("bufferResource" === s.F) { const t = s; e = { buffer: o.buffer.getGPUBuffer(t.buffer), offset: t.offset, size: t.size } } else if ("textureSampler" === s.F) { const t = s; e = o.texture.getGpuSampler(t) } else if ("textureSource" === s.F) { const t = s; e = o.texture.getGpuSource(t).createView({}) } r.push({ binding: n[l], resource: e }) } const h = o.shader.getProgramData(s).bindGroups[e], a = i.createBindGroup({ layout: h, entries: r }); return this.Rl[t.Mi] = a, a } destroy() { for (const t of Object.keys(this.Rl)) this.Rl[t] = null; this.Rl = null, this.Be = null } } eu.extension = { type: [r.WebGPUSystem], name: "bindGroup" }; class iu { constructor(t) { this.bh = Object.create(null), t.renderableGC.addManagedHash(this, "_gpuBuffers") } contextChange(t) { this.Ol = t } getGPUBuffer(t) { return this.bh[t.uid] || this.createGPUBuffer(t) } updateBuffer(t) { const s = this.bh[t.uid] || this.createGPUBuffer(t), e = t.data; return t.X && e && (t.X = 0, this.Ol.device.queue.writeBuffer(s, 0, e.buffer, 0, (t.Vn || e.byteLength) + 3 & -4)), s } destroyAll() { for (const t in this.bh) this.bh[t]?.destroy(); this.bh = {} } createGPUBuffer(t) { this.bh[t.uid] || (t.on("update", this.updateBuffer, this), t.on("change", this.onBufferChange, this), t.on("destroy", this.onBufferDestroy, this)); const s = this.Ol.device.createBuffer(t.descriptor); return t.X = 0, t.data && (Cn(t.data.buffer, s.getMappedRange()), s.unmap()), this.bh[t.uid] = s, s } onBufferChange(t) { this.bh[t.uid].destroy(), t.X = 0, this.bh[t.uid] = this.createGPUBuffer(t) } onBufferDestroy(t) { this.Il(t) } destroy() { this.destroyAll(), this.bh = {} } Il(t) { t.off("update", this.updateBuffer, this), t.off("change", this.onBufferChange, this), t.off("destroy", this.onBufferDestroy, this), this.bh[t.uid] && (this.bh[t.uid].destroy(), this.bh[t.uid] = null) } } iu.extension = { type: [r.WebGPUSystem], name: "buffer" }; class nu { constructor({ minUniformOffsetAlignment: t }) { this.Bl = 256, this.byteIndex = 0, this.Bl = t, this.data = new Float32Array(65535) } clear() { this.byteIndex = 0 } addEmptyGroup(t) { if (t > this.Bl / 4) throw new Error("UniformBufferBatch: array is too large: " + 4 * t); const s = this.byteIndex; let e = s + 4 * t; if (e = Math.ceil(e / this.Bl) * this.Bl, e > 4 * this.data.length) throw new Error("UniformBufferBatch: ubo batch got too big"); return this.byteIndex = e, s } addGroup(t) { const s = this.addEmptyGroup(t.length); for (let e = 0; e < t.length; e++)this.data[s / 4 + e] = t[e]; return s } destroy() { this.data = null } } class ru { constructor(t) { this.$h = 15, this.Be = t } setMask(t) { this.$h !== t && (this.$h = t, this.Be.pipeline.setColorMask(t)) } destroy() { this.Be = null, this.$h = null } } ru.extension = { type: [r.WebGPUSystem], name: "colorMask" }; class ou { constructor(t) { this.Be = t } async init(t) { return this.$l || (this.$l = (t.gpu ? Promise.resolve(t.gpu) : this.Gl(t)).then(t => { this.gpu = t, this.Be.runners.contextChange.emit(this.gpu) })), this.$l } contextChange(t) { this.Be.gpu = t } async Gl(t) { const s = await ks.get().getNavigator().gpu.requestAdapter({ powerPreference: t.powerPreference, forceFallbackAdapter: t.forceFallbackAdapter }), e = ["texture-compression-bc", "texture-compression-astc", "texture-compression-etc2"].filter(t => s.features.has(t)), i = await s.requestDevice({ requiredFeatures: e }); return { adapter: s, device: i } } destroy() { this.gpu = null, this.Be = null } } ou.extension = { type: [r.WebGPUSystem], name: "device" }, ou.defaultOptions = { powerPreference: void 0, forceFallbackAdapter: !1 }; class hu { constructor(t) { this.zl = Object.create(null), this.Dl = Object.create(null), this.Be = t } renderStart() { this.commandFinished = new Promise(t => { this.jl = t }), this.commandEncoder = this.Be.gpu.device.createCommandEncoder() } beginRenderPass(t) { this.endRenderPass(), this.Ll(), this.renderPassEncoder = this.commandEncoder.beginRenderPass(t.descriptor) } endRenderPass() { this.renderPassEncoder && this.renderPassEncoder.end(), this.renderPassEncoder = null } setViewport(t) { this.renderPassEncoder.setViewport(t.x, t.y, t.width, t.height, 0, 1) } setPipelineFromGeometryProgramAndState(t, s, e, i) { const n = this.Be.pipeline.getPipeline(t, s, e, i); this.setPipeline(n) } setPipeline(t) { this.Vl !== t && (this.Vl = t, this.renderPassEncoder.setPipeline(t)) } Nl(t, s) { this.Dl[t] !== s && (this.Dl[t] = s, this.renderPassEncoder.setVertexBuffer(t, this.Be.buffer.updateBuffer(s))) } Wl(t) { if (this.Hl === t) return; this.Hl = t; const s = 2 === t.data.BYTES_PER_ELEMENT ? "uint16" : "uint32"; this.renderPassEncoder.setIndexBuffer(this.Be.buffer.updateBuffer(t), s) } resetBindGroup(t) { this.zl[t] = null } setBindGroup(t, s, e) { if (this.zl[t] === s) return; this.zl[t] = s, s.Ui(this.Be.textureGC.count); const i = this.Be.bindGroup.getBindGroup(s, e, t); this.renderPassEncoder.setBindGroup(t, i) } setGeometry(t, s) { const e = this.Be.pipeline.getBufferNamesToBind(t, s); for (const i in e) this.Nl(parseInt(i, 10), t.attributes[e[i]].buffer); t.indexBuffer && this.Wl(t.indexBuffer) } ql(t, s) { for (const e in t.groups) { const i = t.groups[e]; s || this.Xl(i), this.setBindGroup(e, i, t.gpuProgram) } } Xl(t) { for (const s in t.resources) { const e = t.resources[s]; e.isUniformGroup && this.Be.ubo.updateUniformGroup(e) } } draw(t) { const { geometry: s, shader: e, state: i, topology: n, size: r, start: o, instanceCount: h, skipSync: a } = t; this.setPipelineFromGeometryProgramAndState(s, e.gpuProgram, i, n), this.setGeometry(s, e.gpuProgram), this.ql(e, a), s.indexBuffer ? this.renderPassEncoder.drawIndexed(r || s.indexBuffer.data.length, h ?? s.instanceCount, o || 0) : this.renderPassEncoder.draw(r || s.getSize(), h ?? s.instanceCount, o || 0) } finishRenderPass() { this.renderPassEncoder && (this.renderPassEncoder.end(), this.renderPassEncoder = null) } postrender() { this.finishRenderPass(), this.Ol.device.queue.submit([this.commandEncoder.finish()]), this.jl(), this.commandEncoder = null } restoreRenderPass() { const t = this.Be.renderTarget.adaptor.getDescriptor(this.Be.renderTarget.renderTarget, !1, [0, 0, 0, 1]); this.renderPassEncoder = this.commandEncoder.beginRenderPass(t); const s = this.Vl, e = { ...this.Dl }, i = this.Hl, n = { ...this.zl }; this.Ll(); const r = this.Be.renderTarget.viewport; this.renderPassEncoder.setViewport(r.x, r.y, r.width, r.height, 0, 1), this.setPipeline(s); for (const o in e) this.Nl(o, e[o]); for (const o in n) this.setBindGroup(o, n[o], null); this.Wl(i) } Ll() { for (let t = 0; t < 16; t++)this.zl[t] = null, this.Dl[t] = null; this.Hl = null, this.Vl = null } destroy() { this.Be = null, this.Ol = null, this.zl = null, this.Dl = null, this.Hl = null, this.Vl = null } contextChange(t) { this.Ol = t } } hu.extension = { type: [r.WebGPUSystem], name: "encoder", priority: 1 }; class au { constructor(t) { this.Be = t } contextChange() { this.maxTextures = this.Be.device.gpu.device.limits.maxSampledTexturesPerShaderStage, this.maxBatchableTextures = this.maxTextures } destroy() { } } au.extension = { type: [r.WebGPUSystem], name: "limits" }; class lu { constructor(t) { this.Dh = Object.create(null), this.Be = t, t.renderTarget.onRenderTargetChange.add(this) } onRenderTargetChange(t) { let s = this.Dh[t.uid]; s || (s = this.Dh[t.uid] = { stencilMode: Sn.DISABLED, stencilReference: 0 }), this.Vh = t, this.setStencilMode(s.stencilMode, s.stencilReference) } setStencilMode(t, s) { const e = this.Dh[this.Vh.uid]; e.stencilMode = t, e.stencilReference = s; const i = this.Be; i.pipeline.setStencilMode(t), i.encoder.renderPassEncoder.setStencilReference(s) } destroy() { this.Be.renderTarget.onRenderTargetChange.remove(this), this.Be = null, this.Vh = null, this.Dh = null } } lu.extension = { type: [r.WebGPUSystem], name: "stencil" }; const uu = { i32: { align: 4, size: 4 }, u32: { align: 4, size: 4 }, f32: { align: 4, size: 4 }, f16: { align: 2, size: 2 }, "vec2<i32>": { align: 8, size: 8 }, "vec2<u32>": { align: 8, size: 8 }, "vec2<f32>": { align: 8, size: 8 }, "vec2<f16>": { align: 4, size: 4 }, "vec3<i32>": { align: 16, size: 12 }, "vec3<u32>": { align: 16, size: 12 }, "vec3<f32>": { align: 16, size: 12 }, "vec3<f16>": { align: 8, size: 6 }, "vec4<i32>": { align: 16, size: 16 }, "vec4<u32>": { align: 16, size: 16 }, "vec4<f32>": { align: 16, size: 16 }, "vec4<f16>": { align: 8, size: 8 }, "mat2x2<f32>": { align: 8, size: 16 }, "mat2x2<f16>": { align: 4, size: 8 }, "mat3x2<f32>": { align: 8, size: 24 }, "mat3x2<f16>": { align: 4, size: 12 }, "mat4x2<f32>": { align: 8, size: 32 }, "mat4x2<f16>": { align: 4, size: 16 }, "mat2x3<f32>": { align: 16, size: 32 }, "mat2x3<f16>": { align: 8, size: 16 }, "mat3x3<f32>": { align: 16, size: 48 }, "mat3x3<f16>": { align: 8, size: 24 }, "mat4x3<f32>": { align: 16, size: 64 }, "mat4x3<f16>": { align: 8, size: 32 }, "mat2x4<f32>": { align: 16, size: 32 }, "mat2x4<f16>": { align: 8, size: 16 }, "mat3x4<f32>": { align: 16, size: 48 }, "mat3x4<f16>": { align: 8, size: 24 }, "mat4x4<f32>": { align: 16, size: 64 }, "mat4x4<f16>": { align: 8, size: 32 } }; function cu(t) { const s = t.map(t => ({ data: t, offset: 0, size: 0 })); let e = 0; for (let i = 0; i < s.length; i++) { const t = s[i]; let n = uu[t.data.type].size; const r = uu[t.data.type].align; if (!uu[t.data.type]) throw new Error(`[Pixi.js] WebGPU UniformBuffer: Unknown type ${t.data.type}`); t.data.size > 1 && (n = Math.max(n, r) * t.data.size), e = Math.ceil(e / r) * r, t.size = n, t.offset = e, e += n } return e = 16 * Math.ceil(e / 16), { uboElements: s, size: e } } function fu(t, s) { const { size: e, align: i } = uu[t.data.type], n = (i - e) / 4, r = t.data.type.indexOf("i32") >= 0 ? "dataInt32" : "data"; return `\n         v = uv.${t.data.name};\n         ${0 !== s ? `offset += ${s};` : ""}\n\n         arrayOffset = offset;\n\n         t = 0;\n\n         for(var i=0; i < ${t.data.size * (e / 4)}; i++)\n         {\n             for(var j = 0; j < ${e / 4}; j++)\n             {\n                 ${r}[arrayOffset++] = v[t++];\n             }\n             ${0 !== n ? `arrayOffset += ${n};` : ""}\n         }\n     ` } function du(t) { return ga(t, "uboWgsl", fu, xa) } class pu extends fa { constructor() { super({ createUboElements: cu, generateUboSync: du }) } } pu.extension = { type: [r.WebGPUSystem], name: "ubo" }; const mu = 128; class gu { constructor(t) { this.Yl = Object.create(null), this.Kl = [], this.Zl = [], this.Ql = [], this.Be = t, this.Be.renderableGC.addManagedHash(this, "_bindGroupHash"), this.Jl = new nu({ minUniformOffsetAlignment: mu }); for (let s = 0; s < 2; s++) { let t = Ln.UNIFORM | Ln.COPY_DST; 0 === s && (t |= Ln.COPY_SRC), this.Kl.push(new Vn({ data: this.Jl.data, usage: t })) } } renderEnd() { this.tu(), this.su() } su() { for (const t in this.Yl) this.Yl[t] = null; this.Jl.clear() } getUniformBindGroup(t, s) { if (!s && this.Yl[t.uid]) return this.Yl[t.uid]; this.Be.ubo.ensureUniformGroup(t); const e = t.buffer.data, i = this.Jl.addEmptyGroup(e.length); return this.Be.ubo.syncUniformGroup(t, this.Jl.data, i / 4), this.Yl[t.uid] = this.eu(i / mu), this.Yl[t.uid] } getUboResource(t) { this.Be.ubo.updateUniformGroup(t); const s = t.buffer.data, e = this.Jl.addGroup(s); return this.iu(e / mu) } getArrayBindGroup(t) { const s = this.Jl.addGroup(t); return this.eu(s / mu) } getArrayBufferResource(t) { const s = this.Jl.addGroup(t) / mu; return this.iu(s) } iu(t) { if (!this.Ql[t]) { const s = this.Kl[t % 2]; this.Ql[t] = new Fa({ buffer: s, offset: 256 * (t / 2 | 0), size: mu }) } return this.Ql[t] } eu(t) { if (!this.Zl[t]) { const s = new Ke({ 0: this.iu(t) }); this.Zl[t] = s } return this.Zl[t] } tu() { const t = this.Be.buffer, s = this.Kl[0]; s.update(this.Jl.byteIndex), t.updateBuffer(s); const e = this.Be.gpu.device.createCommandEncoder(); for (let i = 1; i < this.Kl.length; i++) { const n = this.Kl[i]; e.copyBufferToBuffer(t.getGPUBuffer(s), mu, t.getGPUBuffer(n), 0, this.Jl.byteIndex) } this.Be.gpu.device.queue.submit([e.finish()]) } destroy() { for (let t = 0; t < this.Zl.length; t++)this.Zl[t]?.destroy(); this.Zl = null, this.Yl = null; for (let t = 0; t < this.Kl.length; t++)this.Kl[t].destroy(); this.Kl = null; for (let t = 0; t < this.Ql.length; t++)this.Ql[t].destroy(); this.Ql = null, this.Jl.destroy(), this.Yl = null, this.Be = null } } gu.extension = { type: [r.WebGPUPipes], name: "uniformBatch" }; const vu = { "point-list": 0, "line-list": 1, "line-strip": 2, "triangle-list": 3, "triangle-strip": 4 }; class bu { constructor(t) { this.nu = Object.create(null), this.ru = Object.create(null), this.ou = Object.create(null), this.hu = Object.create(null), this.au = Object.create(null), this.lu = 15, this.uu = 1, this.Be = t } contextChange(t) { this.Ol = t, this.setStencilMode(Sn.DISABLED), this.cu() } setMultisampleCount(t) { this.uu !== t && (this.uu = t, this.cu()) } setRenderTarget(t) { this.uu = t.msaaSamples, this.fu = t.descriptor.depthStencilAttachment ? 1 : 0, this.cu() } setColorMask(t) { this.lu !== t && (this.lu = t, this.cu()) } setStencilMode(t) { this.du !== t && (this.du = t, this.pu = ua[t], this.cu()) } setPipeline(t, s, e, i) { const n = this.getPipeline(t, s, e); i.setPipeline(n) } getPipeline(t, s, e, i) { t.Si || (Yh(t, s.attributeData), this.mu(t)), i || (i = t.topology); const n = function (t, s, e, i, n) { return t << 24 | s << 16 | e << 10 | i << 5 | n }(t.Si, s.Si, e.data, e.zi, vu[i]); return this.hu[n] || (this.hu[n] = this.gu(t, s, e, i)), this.hu[n] } gu(t, s, e, i) { const n = this.Ol.device, r = this.vu(t, s), o = this.Be.state.getColorTargets(e); o[0].writeMask = this.du === Sn.RENDERING_MASK_ADD ? 0 : this.lu; const h = this.Be.shader.getProgramData(s).pipeline, a = { vertex: { module: this.bu(s.vertex.source), entryPoint: s.vertex.entryPoint, buffers: r }, fragment: { module: this.bu(s.fragment.source), entryPoint: s.fragment.entryPoint, targets: o }, primitive: { topology: i, cullMode: e.cullMode }, layout: h, multisample: { count: this.uu }, label: "PIXI Pipeline" }; return this.fu && (a.depthStencil = { ...this.pu, format: "depth24plus-stencil8", depthWriteEnabled: e.depthTest, depthCompare: e.depthTest ? "less" : "always" }), n.createRenderPipeline(a) } bu(t) { return this.nu[t] || this.xu(t) } xu(t) { const s = this.Ol.device; return this.nu[t] = s.createShaderModule({ code: t }), this.nu[t] } mu(t) { const s = []; let e = 0; const i = Object.keys(t.attributes).sort(); for (let r = 0; r < i.length; r++) { const n = t.attributes[i[r]]; s[e++] = n.offset, s[e++] = n.format, s[e++] = n.stride, s[e++] = n.instance } const n = s.join("|"); return t.Si = Se(n, "geometry"), t.Si } yu(t) { const s = []; let e = 0; const i = Object.keys(t.attributeData).sort(); for (let r = 0; r < i.length; r++) { const n = t.attributeData[i[r]]; s[e++] = n.location } const n = s.join("|"); return t.Pi = Se(n, "programAttributes"), t.Pi } getBufferNamesToBind(t, s) { const e = t.Si << 16 | s.Pi; if (this.ou[e]) return this.ou[e]; const i = this.vu(t, s), n = Object.create(null), r = s.attributeData; for (let o = 0; o < i.length; o++) { const t = Object.values(i[o].attributes)[0].shaderLocation; for (const s in r) if (r[s].location === t) { n[o] = s; break } } return this.ou[e] = n, n } vu(t, s) { s.Pi || this.yu(s); const e = t.Si << 16 | s.Pi; if (this.ru[e]) return this.ru[e]; const i = []; return t.buffers.forEach(e => { const n = { arrayStride: 0, stepMode: "vertex", attributes: [] }, r = n.attributes; for (const i in s.attributeData) { const o = t.attributes[i]; 1 !== (o.divisor ?? 1) && Et(o.divisor), o.buffer === e && (n.arrayStride = o.stride, n.stepMode = o.instance ? "instance" : "vertex", r.push({ shaderLocation: s.attributeData[i].location, offset: o.offset, format: o.format })) } r.length && i.push(n) }), this.ru[e] = i, i } cu() { const t = (s = this.du, e = this.uu, this.lu << 6 | s << 3 | this.fu << 1 | e); var s, e; this.au[t] || (this.au[t] = Object.create(null)), this.hu = this.au[t] } destroy() { this.Be = null, this.ru = null } } bu.extension = { type: [r.WebGPUSystem], name: "pipeline" }; class xu { constructor() { this.contexts = [], this.msaaTextures = [], this.msaaSamples = 1 } } class yu { init(t, s) { this.Be = t, this.Kh = s } copyToTexture(t, s, e, i, n) { const r = this.Be, o = this.wu(t), h = r.texture.getGpuSource(s.source); return r.encoder.commandEncoder.copyTextureToTexture({ texture: o, origin: e }, { texture: h, origin: n }, i), s } startRenderPass(t, s = !0, e, i) { const n = this.Kh.getGpuRenderTarget(t), r = this.getDescriptor(t, s, e); n.descriptor = r, this.Be.pipeline.setRenderTarget(n), this.Be.encoder.beginRenderPass(n), this.Be.encoder.setViewport(i) } finishRenderPass() { this.Be.encoder.endRenderPass() } wu(t) { const s = this.Kh.getGpuRenderTarget(t); return s.contexts[0] ? s.contexts[0].getCurrentTexture() : this.Be.texture.getGpuSource(t.colorTextures[0].source) } getDescriptor(t, s, e) { "boolean" == typeof s && (s = s ? Ui.ALL : Ui.NONE); const i = this.Kh, n = i.getGpuRenderTarget(t), r = t.colorTextures.map((t, r) => { const o = n.contexts[r]; let h, a; h = o ? o.getCurrentTexture().createView() : this.Be.texture.getGpuSource(t).createView({ mipLevelCount: 1 }), n.msaaTextures[r] && (a = h, h = this.Be.texture.getTextureView(n.msaaTextures[r])); const l = s & Ui.COLOR ? "clear" : "load"; return e ?? (e = i.defaultClearColor), { view: h, resolveTarget: a, clearValue: e, storeOp: "store", loadOp: l } }); let o; if (!t.stencil && !t.depth || t.depthStencilTexture || (t.ensureDepthStencilTexture(), t.depthStencilTexture.source.sampleCount = n.msaa ? 4 : 1), t.depthStencilTexture) { const e = s & Ui.STENCIL ? "clear" : "load", i = s & Ui.DEPTH ? "clear" : "load"; o = { view: this.Be.texture.getGpuSource(t.depthStencilTexture.source).createView(), stencilStoreOp: "store", stencilLoadOp: e, depthClearValue: 1, depthLoadOp: i, depthStoreOp: "store" } } return { colorAttachments: r, depthStencilAttachment: o } } clear(t, s = !0, e, i) { if (!s) return; const { gpu: n, encoder: r } = this.Be, o = n.device; if (null === r.commandEncoder) { const n = o.createCommandEncoder(), r = this.getDescriptor(t, s, e), h = n.beginRenderPass(r); h.setViewport(i.x, i.y, i.width, i.height, 0, 1), h.end(); const a = n.finish(); o.queue.submit([a]) } else this.startRenderPass(t, s, e, i) } initGpuRenderTarget(t) { t.isRoot = !0; const s = new xu; return t.colorTextures.forEach((t, e) => { if (t instanceof Fs) { const n = t.resource.getContext("webgpu"), r = t.transparent ? "premultiplied" : "opaque"; try { n.configure({ device: this.Be.gpu.device, usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC, format: "bgra8unorm", alphaMode: r }) } catch (i) { } s.contexts[e] = n } if (s.msaa = t.source.antialias, t.source.antialias) { const t = new q({ width: 0, height: 0, sampleCount: 4 }); s.msaaTextures[e] = t } }), s.msaa && (s.msaaSamples = 4, t.depthStencilTexture && (t.depthStencilTexture.source.sampleCount = 4)), s } destroyGpuRenderTarget(t) { t.contexts.forEach(t => { t.unconfigure() }), t.msaaTextures.forEach(t => { t.destroy() }), t.msaaTextures.length = 0, t.contexts.length = 0 } ensureDepthStencilTexture(t) { const s = this.Kh.getGpuRenderTarget(t); t.depthStencilTexture && s.msaa && (t.depthStencilTexture.source.sampleCount = 4) } resizeGpuRenderTarget(t) { const s = this.Kh.getGpuRenderTarget(t); s.width = t.width, s.height = t.height, s.msaa && t.colorTextures.forEach((t, e) => { const i = s.msaaTextures[e]; i?.resize(t.source.width, t.source.height, t.source.$) }) } } class wu extends Pa { constructor(t) { super(t), this.adaptor = new yu, this.adaptor.init(t, this) } } wu.extension = { type: [r.WebGPUSystem], name: "renderTarget" }; class Mu { constructor() { this.Mu = Object.create(null) } contextChange(t) { this.Ol = t } getProgramData(t) { return this.Mu[t.Si] || this.Tu(t) } Tu(t) { const s = this.Ol.device, e = t.gpuLayout.map(t => s.createBindGroupLayout({ entries: t })), i = { bindGroupLayouts: e }; return this.Mu[t.Si] = { bindGroups: e, pipeline: s.createPipelineLayout(i) }, this.Mu[t.Si] } destroy() { this.Ol = null, this.Mu = null } } Mu.extension = { type: [r.WebGPUSystem], name: "shader" }; const Tu = { normal: { alpha: { srcFactor: "one", dstFactor: "one-minus-src-alpha", operation: "add" }, color: { srcFactor: "one", dstFactor: "one-minus-src-alpha", operation: "add" } }, add: { alpha: { srcFactor: "src-alpha", dstFactor: "one-minus-src-alpha", operation: "add" }, color: { srcFactor: "one", dstFactor: "one", operation: "add" } }, multiply: { alpha: { srcFactor: "one", dstFactor: "one-minus-src-alpha", operation: "add" }, color: { srcFactor: "dst", dstFactor: "one-minus-src-alpha", operation: "add" } }, screen: { alpha: { srcFactor: "one", dstFactor: "one-minus-src-alpha", operation: "add" }, color: { srcFactor: "one", dstFactor: "one-minus-src", operation: "add" } }, overlay: { alpha: { srcFactor: "one", dstFactor: "one-minus-src-alpha", operation: "add" }, color: { srcFactor: "one", dstFactor: "one-minus-src", operation: "add" } }, none: { alpha: { srcFactor: "one", dstFactor: "one-minus-src-alpha", operation: "add" }, color: { srcFactor: "zero", dstFactor: "zero", operation: "add" } }, "normal-npm": { alpha: { srcFactor: "one", dstFactor: "one-minus-src-alpha", operation: "add" }, color: { srcFactor: "src-alpha", dstFactor: "one-minus-src-alpha", operation: "add" } }, "add-npm": { alpha: { srcFactor: "one", dstFactor: "one", operation: "add" }, color: { srcFactor: "src-alpha", dstFactor: "one", operation: "add" } }, "screen-npm": { alpha: { srcFactor: "one", dstFactor: "one-minus-src-alpha", operation: "add" }, color: { srcFactor: "src-alpha", dstFactor: "one-minus-src", operation: "add" } }, erase: { alpha: { srcFactor: "zero", dstFactor: "one-minus-src-alpha", operation: "add" }, color: { srcFactor: "zero", dstFactor: "one-minus-src", operation: "add" } }, min: { alpha: { srcFactor: "one", dstFactor: "one", operation: "min" }, color: { srcFactor: "one", dstFactor: "one", operation: "min" } }, max: { alpha: { srcFactor: "one", dstFactor: "one", operation: "max" }, color: { srcFactor: "one", dstFactor: "one", operation: "max" } } }; class Au { constructor() { this.defaultState = new si, this.defaultState.blend = !0 } contextChange(t) { this.gpu = t } getColorTargets(t) { return [{ format: "bgra8unorm", writeMask: 0, blend: Tu[t.blendMode] || Tu.normal }] } destroy() { this.gpu = null } } Au.extension = { type: [r.WebGPUSystem], name: "state" }; const Cu = { type: "image", upload(t, s, e) { const i = t.resource, n = (0 | t.pixelWidth) * (0 | t.pixelHeight), r = i.byteLength / n; e.device.queue.writeTexture({ texture: s }, i, { offset: 0, rowsPerImage: t.pixelHeight, bytesPerRow: t.pixelWidth * r }, { width: t.pixelWidth, height: t.pixelHeight, depthOrArrayLayers: 1 }) } }, _u = { "bc1-rgba-unorm": { blockBytes: 8, blockWidth: 4, blockHeight: 4 }, "bc2-rgba-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 }, "bc3-rgba-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 }, "bc7-rgba-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 }, "etc1-rgb-unorm": { blockBytes: 8, blockWidth: 4, blockHeight: 4 }, "etc2-rgba8unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 }, "astc-4x4-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 } }, Su = { blockBytes: 4, blockWidth: 1, blockHeight: 1 }, Pu = { type: "compressed", upload(t, s, e) { let i = t.pixelWidth, n = t.pixelHeight; const r = _u[t.format] || Su; for (let o = 0; o < t.resource.length; o++) { const h = t.resource[o], a = Math.ceil(i / r.blockWidth) * r.blockBytes; e.device.queue.writeTexture({ texture: s, mipLevel: o }, h, { offset: 0, bytesPerRow: a }, { width: Math.ceil(i / r.blockWidth) * r.blockWidth, height: Math.ceil(n / r.blockHeight) * r.blockHeight, depthOrArrayLayers: 1 }), i = Math.max(i >> 1, 1), n = Math.max(n >> 1, 1) } } }, ku = { type: "image", upload(t, s, e) { const i = t.resource; if (!i) return; if (globalThis.HTMLImageElement && i instanceof HTMLImageElement) { const s = ks.get().createCanvas(i.width, i.height); s.getContext("2d").drawImage(i, 0, 0, i.width, i.height), t.resource = s, Et() } const n = Math.min(s.width, t.resourceWidth || t.pixelWidth), r = Math.min(s.height, t.resourceHeight || t.pixelHeight), o = "premultiply-alpha-on-upload" === t.alphaMode; e.device.queue.copyExternalImageToTexture({ source: i }, { texture: s, premultipliedAlpha: o }, { width: n, height: r }) } }, Fu = { type: "video", upload(t, s, e) { ku.upload(t, s, e) } }; class Eu { constructor(t) { this.device = t, this.sampler = t.createSampler({ minFilter: "linear" }), this.pipelines = {} } Au(t) { let s = this.pipelines[t]; return s || (this.mipmapShaderModule || (this.mipmapShaderModule = this.device.createShaderModule({ code: "\n                        var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(\n                        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));\n\n                        struct VertexOutput {\n                        @builtin(position) position : vec4<f32>,\n                        @location(0) texCoord : vec2<f32>,\n                        };\n\n                        @vertex\n                        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {\n                        var output : VertexOutput;\n                        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);\n                        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);\n                        return output;\n                        }\n\n                        @group(0) @binding(0) var imgSampler : sampler;\n                        @group(0) @binding(1) var img : texture_2d<f32>;\n\n                        @fragment\n                        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {\n                        return textureSample(img, imgSampler, texCoord);\n                        }\n                    " })), s = this.device.createRenderPipeline({ layout: "auto", vertex: { module: this.mipmapShaderModule, entryPoint: "vertexMain" }, fragment: { module: this.mipmapShaderModule, entryPoint: "fragmentMain", targets: [{ format: t }] } }), this.pipelines[t] = s), s } generateMipmap(t) { const s = this.Au(t.format); if ("3d" === t.dimension || "1d" === t.dimension) throw new Error("Generating mipmaps for non-2d textures is currently unsupported!"); let e = t; const i = t.depthOrArrayLayers || 1, n = t.usage & GPUTextureUsage.RENDER_ATTACHMENT; if (!n) { const s = { size: { width: Math.ceil(t.width / 2), height: Math.ceil(t.height / 2), depthOrArrayLayers: i }, format: t.format, usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT, mipLevelCount: t.mipLevelCount - 1 }; e = this.device.createTexture(s) } const r = this.device.createCommandEncoder({}), o = s.getBindGroupLayout(0); for (let h = 0; h < i; ++h) { let i = t.createView({ baseMipLevel: 0, mipLevelCount: 1, dimension: "2d", baseArrayLayer: h, arrayLayerCount: 1 }), a = n ? 1 : 0; for (let n = 1; n < t.mipLevelCount; ++n) { const t = e.createView({ baseMipLevel: a++, mipLevelCount: 1, dimension: "2d", baseArrayLayer: h, arrayLayerCount: 1 }), n = r.beginRenderPass({ colorAttachments: [{ view: t, storeOp: "store", loadOp: "clear", clearValue: { r: 0, g: 0, b: 0, a: 0 } }] }), l = this.device.createBindGroup({ layout: o, entries: [{ binding: 0, resource: this.sampler }, { binding: 1, resource: i }] }); n.setPipeline(s), n.setBindGroup(0, l), n.draw(3, 1, 0, 0), n.end(), i = t } } if (!n) { const s = { width: Math.ceil(t.width / 2), height: Math.ceil(t.height / 2), depthOrArrayLayers: i }; for (let i = 1; i < t.mipLevelCount; ++i)r.copyTextureToTexture({ texture: e, mipLevel: i - 1 }, { texture: t, mipLevel: i }, s), s.width = Math.ceil(s.width / 2), s.height = Math.ceil(s.height / 2) } return this.device.queue.submit([r.finish()]), n || e.destroy(), t } } class Ru { constructor(t) { this.managedTextures = [], this.Cu = Object.create(null), this._u = Object.create(null), this.Yl = Object.create(null), this.Su = Object.create(null), this.Ra = { image: ku, buffer: Cu, video: Fu, compressed: Pu }, this.Be = t, t.renderableGC.addManagedHash(this, "_gpuSources"), t.renderableGC.addManagedHash(this, "_gpuSamplers"), t.renderableGC.addManagedHash(this, "_bindGroupHash"), t.renderableGC.addManagedHash(this, "_textureViewHash") } contextChange(t) { this.Ol = t } initSource(t) { return this.Cu[t.uid] ? this.Cu[t.uid] : this.ja(t) } ja(t) { if (t.autoGenerateMipmaps) { const s = Math.max(t.pixelWidth, t.pixelHeight); t.mipLevelCount = Math.floor(Math.log2(s)) + 1 } let s = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST; "compressed" !== t.uploadMethodId && (s |= GPUTextureUsage.RENDER_ATTACHMENT, s |= GPUTextureUsage.COPY_SRC); const e = _u[t.format] || { blockWidth: 1, blockHeight: 1 }, i = Math.ceil(t.pixelWidth / e.blockWidth) * e.blockWidth, n = Math.ceil(t.pixelHeight / e.blockHeight) * e.blockHeight, r = { label: t.label, size: { width: i, height: n }, format: t.format, sampleCount: t.sampleCount, mipLevelCount: t.mipLevelCount, dimension: t.dimension, usage: s }, o = this.Cu[t.uid] = this.Ol.device.createTexture(r); return this.managedTextures.includes(t) || (t.on("update", this.onSourceUpdate, this), t.on("resize", this.onSourceResize, this), t.on("destroy", this.onSourceDestroy, this), t.on("unload", this.onSourceUnload, this), t.on("updateMipmaps", this.onUpdateMipmaps, this), this.managedTextures.push(t)), this.onSourceUpdate(t), o } onSourceUpdate(t) { const s = this.getGpuSource(t); s && (this.Ra[t.uploadMethodId] && this.Ra[t.uploadMethodId].upload(t, s, this.Ol), t.autoGenerateMipmaps && t.mipLevelCount > 1 && this.onUpdateMipmaps(t)) } onSourceUnload(t) { const s = this.Cu[t.uid]; s && (this.Cu[t.uid] = null, s.destroy()) } onUpdateMipmaps(t) { this.Pu || (this.Pu = new Eu(this.Ol.device)); const s = this.getGpuSource(t); this.Pu.generateMipmap(s) } onSourceDestroy(t) { t.off("update", this.onSourceUpdate, this), t.off("unload", this.onSourceUnload, this), t.off("destroy", this.onSourceDestroy, this), t.off("resize", this.onSourceResize, this), t.off("updateMipmaps", this.onUpdateMipmaps, this), this.managedTextures.splice(this.managedTextures.indexOf(t), 1), this.onSourceUnload(t) } onSourceResize(t) { const s = this.Cu[t.uid]; s ? s.width === t.pixelWidth && s.height === t.pixelHeight || (this.Su[t.uid] = null, this.Yl[t.uid] = null, this.onSourceUnload(t), this.initSource(t)) : this.initSource(t) } La(t) { return this._u[t.U] = this.Ol.device.createSampler(t), this._u[t.U] } getGpuSampler(t) { return this._u[t.U] || this.La(t) } getGpuSource(t) { return this.Cu[t.uid] || this.initSource(t) } getTextureBindGroup(t) { return this.Yl[t.uid] ?? this.ku(t) } ku(t) { const s = t.source; return this.Yl[t.uid] = new Ke({ 0: s, 1: s.style, 2: new Ye({ uTextureMatrix: { type: "mat3x3<f32>", value: t.textureMatrix.mapCoord } }) }), this.Yl[t.uid] } getTextureView(t) { const s = t.source; return this.Su[s.uid] ?? this.Fu(s) } Fu(t) { return this.Su[t.uid] = this.getGpuSource(t).createView(), this.Su[t.uid] } generateCanvas(t) { const s = this.Be, e = s.gpu.device.createCommandEncoder(), i = ks.get().createCanvas(); i.width = t.source.pixelWidth, i.height = t.source.pixelHeight; const n = i.getContext("webgpu"); return n.configure({ device: s.gpu.device, usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC, format: ks.get().getNavigator().gpu.getPreferredCanvasFormat(), alphaMode: "premultiplied" }), e.copyTextureToTexture({ texture: s.texture.getGpuSource(t.source), origin: { x: 0, y: 0 } }, { texture: n.getCurrentTexture() }, { width: i.width, height: i.height }), s.gpu.device.queue.submit([e.finish()]), i } getPixels(t) { const s = this.generateCanvas(t), e = Go.getOptimalCanvasAndContext(s.width, s.height), i = e.context; i.drawImage(s, 0, 0); const { width: n, height: r } = s, o = i.getImageData(0, 0, n, r), h = new Uint8ClampedArray(o.data.buffer); return Go.returnCanvasAndContext(e), { pixels: h, width: n, height: r } } destroy() { this.managedTextures.slice().forEach(t => this.onSourceDestroy(t)), this.managedTextures = null; for (const t of Object.keys(this.Yl)) { const s = Number(t), e = this.Yl[s]; e?.destroy(), this.Yl[s] = null } this.Be = null, this.Ol = null, this.Pu = null, this.Cu = null, this.Yl = null, this.Su = null, this._u = null } } Ru.extension = { type: [r.WebGPUSystem], name: "texture" }; class Ou { constructor() { this.Eu = 0 } contextChange(t) { const s = new Ye({ uTransformMatrix: { value: new w, type: "mat3x3<f32>" }, uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" }, uRound: { value: 0, type: "f32" } }); this.Eu = t.limits.maxBatchableTextures; const e = ur({ name: "graphics", bits: [fr, vr(this.Eu), Ih, wr] }); this.shader = new Qe({ gpuProgram: e, resources: { localUniforms: s } }) } execute(t, s) { const e = s.context, i = e.customShader || this.shader, n = t.renderer, r = n.graphicsContext, { batcher: o, instructions: h } = r.getContextRenderData(e), a = n.encoder; a.setGeometry(o.geometry, i.gpuProgram); const l = n.globalUniforms.bindGroup; a.setBindGroup(0, l, i.gpuProgram); const u = n.renderPipes.uniformBatch.getUniformBindGroup(i.resources.localUniforms, !0); a.setBindGroup(2, u, i.gpuProgram); const c = h.instructions; let f = null; for (let d = 0; d < h.instructionSize; d++) { const s = c[d]; if (s.topology !== f && (f = s.topology, a.setPipelineFromGeometryProgramAndState(o.geometry, i.gpuProgram, t.state, s.topology)), i.groups[1] = s.bindGroup, !s.gpuBindGroup) { const t = s.textures; s.bindGroup = Tn(t.textures, t.count, this.Eu), s.gpuBindGroup = n.bindGroup.getBindGroup(s.bindGroup, i.gpuProgram, 1) } a.setBindGroup(1, s.bindGroup, i.gpuProgram), a.renderPassEncoder.drawIndexed(s.size, 1, s.start) } } destroy() { this.shader.destroy(!0), this.shader = null } } Ou.extension = { type: [r.WebGPUPipesAdaptor], name: "graphics" }; class Uu { init() { const t = ur({ name: "mesh", bits: [Uh, $h, wr] }); this.Jo = new Qe({ gpuProgram: t, resources: { uTexture: Z.EMPTY.K, uSampler: Z.EMPTY.K.style, textureUniforms: { uTextureMatrix: { type: "mat3x3<f32>", value: new w } } } }) } execute(t, s) { const e = t.renderer; let i = s.Jo; if (i) { if (!i.gpuProgram) return void Et(s.shader) } else i = this.Jo, i.groups[2] = e.texture.getTextureBindGroup(s.texture); const n = i.gpuProgram; if (n.autoAssignGlobalUniforms && (i.groups[0] = e.globalUniforms.bindGroup), n.autoAssignLocalUniforms) { const s = t.localUniforms; i.groups[1] = e.renderPipes.uniformBatch.getUniformBindGroup(s, !0) } e.encoder.draw({ geometry: s.th, shader: i, state: s.state }) } destroy() { this.Jo.destroy(!0), this.Jo = null } } Uu.extension = { type: [r.WebGPUPipesAdaptor], name: "mesh" }; const Iu = [...ql, pu, hu, ou, au, iu, Ru, wu, Mu, Au, bu, ru, lu, eu], Bu = [...Xl, gu], $u = [Eh, Uu, Ou], Gu = [], zu = [], Du = []; a.handleByNamedList(r.WebGPUSystem, Gu), a.handleByNamedList(r.WebGPUPipes, zu), a.handleByNamedList(r.WebGPUPipesAdaptor, Du), a.add(...Iu, ...Bu, ...$u); const ju = Object.freeze(Object.defineProperty({ __proto__: null, WebGPURenderer: class extends Di { constructor() { super({ name: "webgpu", type: Ze.WEBGPU, systems: Gu, renderPipes: zu, renderPipeAdaptors: Du }) } } }, Symbol.toStringTag, { value: "Module" })); class Lu { constructor() { this.batches = [], this.batched = !1 } destroy() { this.batches.forEach(t => { Ut.return(t) }), this.batches.length = 0 } } class Vu { constructor(t, s) { this.state = si.for2d(), this.renderer = t, this.ih = s, this.renderer.runners.contextChange.add(this) } contextChange() { this.ih.contextChange(this.renderer) } validateRenderable(t) { const s = t.context, e = !!t.ps, i = this.renderer.graphicsContext.updateGpuContext(s); return !(!i.isBatchable && e === i.isBatchable) } addRenderable(t, s) { const e = this.renderer.graphicsContext.updateGpuContext(t.context); t.didViewUpdate && this.Ru(t), e.isBatchable ? this.Ou(t, s) : (this.renderer.renderPipes.batch.break(s), s.add(t)) } updateRenderable(t) { const s = this.Uu(t).batches; for (let e = 0; e < s.length; e++) { const t = s[e]; t.In.updateElement(t) } } execute(t) { if (!t.isRenderable) return; const s = this.renderer, e = t.context; if (!s.graphicsContext.getGpuContext(e).batches.length) return; const i = e.customShader || this.ih.shader; this.state.blendMode = t.groupBlendMode; const n = i.resources.localUniforms.uniforms; n.uTransformMatrix = t.groupTransform, n.uRound = s.fs | t.fs, Ol(t.groupColorAlpha, n.uColor, 0), this.ih.execute(this, t) } Ru(t) { const s = this.Uu(t), e = this.renderer.graphicsContext.updateGpuContext(t.context); s.destroy(), e.isBatchable && this.Iu(t, s) } Ou(t, s) { const e = this.renderer.renderPipes.batch, i = this.Uu(t).batches; for (let n = 0; n < i.length; n++) { const t = i[n]; e.addToBatch(t, s) } } Uu(t) { return t.ps[this.renderer.uid] || this.Bu(t) } Bu(t) { const s = new Lu; return t.ps[this.renderer.uid] = s, s } Iu(t, s) { const e = t.context, i = this.renderer.graphicsContext.getGpuContext(e), n = this.renderer.fs | t.fs; s.batches = i.batches.map(s => { const e = Ut.get(Er); return s.copyTo(e), e.renderable = t, e.roundPixels = n, e }) } destroy() { this.renderer = null, this.ih.destroy(), this.ih = null, this.state = null } } Vu.extension = { type: [r.WebGLPipes, r.WebGPUPipes, r.CanvasPipes], name: "graphics" }; const Nu = class t extends mh { constructor(...t) { super({}); let s = t[0] ?? {}; "number" == typeof s && (G(0, "PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead"), s = { width: s, height: t[1], verticesX: t[2], verticesY: t[3] }), this.build(s) } build(s) { s = { ...t.defaultOptions, ...s }, this.verticesX = this.verticesX ?? s.verticesX, this.verticesY = this.verticesY ?? s.verticesY, this.width = this.width ?? s.width, this.height = this.height ?? s.height; const e = this.verticesX * this.verticesY, i = [], n = [], r = [], o = this.verticesX - 1, h = this.verticesY - 1, a = this.width / o, l = this.height / h; for (let t = 0; t < e; t++) { const s = t % this.verticesX, e = t / this.verticesX | 0; i.push(s * a, e * l), n.push(s / o, e / h) } const u = o * h; for (let t = 0; t < u; t++) { const s = t % o, e = t / o | 0, i = e * this.verticesX + s, n = e * this.verticesX + s + 1, h = (e + 1) * this.verticesX + s, a = (e + 1) * this.verticesX + s + 1; r.push(i, n, h, n, a, h) } this.buffers[0].data = new Float32Array(i), this.buffers[1].data = new Float32Array(n), this.indexBuffer.data = new Uint32Array(r), this.buffers[0].update(), this.buffers[1].update(), this.indexBuffer.update() } }; Nu.defaultOptions = { width: 100, height: 100, verticesX: 10, verticesY: 10 }; let Wu = Nu; class Hu { constructor() { this.batcherName = "default", this.packAsQuad = !1, this.indexOffset = 0, this.attributeOffset = 0, this.roundPixels = 0, this.In = null, this.Bn = null, this.$u = -1, this.Gu = -1 } get blendMode() { return this.renderable.groupBlendMode } get topology() { return this.zu || this.geometry.topology } set topology(t) { this.zu = t } reset() { this.renderable = null, this.texture = null, this.In = null, this.Bn = null, this.geometry = null, this.Gu = -1, this.$u = -1 } setTexture(t) { this.texture !== t && (this.texture = t, this.$u = -1) } get uvs() { const t = this.geometry.getBuffer("aUV"), s = t.data; let e = s; const i = this.texture.textureMatrix; return i.isSimple || (e = this.Du, this.$u === i.X && this.Gu === t.X || ((!e || e.length < s.length) && (e = this.Du = new Float32Array(s.length)), this.$u = i.X, this.Gu = t.X, i.multiplyUvs(s, e))), e } get positions() { return this.geometry.positions } get indices() { return this.geometry.indices } get color() { return this.renderable.groupColorAlpha } get groupTransform() { return this.renderable.groupTransform } get attributeSize() { return this.geometry.positions.length / 2 } get indexSize() { return this.geometry.indices.length } } class qu { destroy() { } } class Xu { constructor(t, s) { this.localUniforms = new Ye({ uTransformMatrix: { value: new w, type: "mat3x3<f32>" }, uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" }, uRound: { value: 0, type: "f32" } }), this.localUniformsBindGroup = new Ke({ 0: this.localUniforms }), this.renderer = t, this.ih = s, this.ih.init() } validateRenderable(t) { const s = this.ju(t), e = s.batched, i = t.batched; if (s.batched = i, e !== i) return !0; if (i) { const e = t.th; if (e.indices.length !== s.indexSize || e.positions.length !== s.vertexSize) return s.indexSize = e.indices.length, s.vertexSize = e.positions.length, !0; const i = this.Lu(t); return i.texture.uid !== t.Y.uid && (i.$u = -1), !i.In.checkAndUpdateTexture(i, t.Y) } return !1 } addRenderable(t, s) { const e = this.renderer.renderPipes.batch, i = this.ju(t); if (t.didViewUpdate && (i.indexSize = t.th.indices?.length, i.vertexSize = t.th.positions?.length), i.batched) { const i = this.Lu(t); i.setTexture(t.Y), i.geometry = t.th, e.addToBatch(i, s) } else e.break(s), s.add(t) } updateRenderable(t) { if (t.batched) { const s = this.Lu(t); s.setTexture(t.Y), s.geometry = t.th, s.In.updateElement(s) } } execute(t) { if (!t.isRenderable) return; t.state.blendMode = Pn(t.groupBlendMode, t.texture.K); const s = this.localUniforms; s.uniforms.uTransformMatrix = t.groupTransform, s.uniforms.uRound = this.renderer.fs | t.fs, s.update(), Ol(t.groupColorAlpha, s.uniforms.uColor, 0), this.ih.execute(this, t) } ju(t) { var s, e; return (s = t.ps)[e = this.renderer.uid] || (s[e] = new qu), t.ps[this.renderer.uid].meshData || this.Vu(t) } Vu(t) { return t.ps[this.renderer.uid].meshData = { batched: t.batched, indexSize: 0, vertexSize: 0 }, t.ps[this.renderer.uid].meshData } Lu(t) { var s, e; return (s = t.ps)[e = this.renderer.uid] || (s[e] = new qu), t.ps[this.renderer.uid].batchableMesh || this.Nu(t) } Nu(t) { const s = new Hu; return s.renderable = t, s.setTexture(t.Y), s.transform = t.groupTransform, s.roundPixels = this.renderer.fs | t.fs, t.ps[this.renderer.uid].batchableMesh = s, s } destroy() { this.localUniforms = null, this.localUniformsBindGroup = null, this.ih.destroy(), this.ih = null, this.renderer = null } } Xu.extension = { type: [r.WebGLPipes, r.WebGPUPipes, r.CanvasPipes], name: "mesh" }; class Yu { execute(t, s) { const e = t.state, i = t.renderer, n = s.shader || t.defaultShader; n.resources.uTexture = s.texture.K, n.resources.uniforms = t.localUniforms; const r = i.gl, o = t.getBuffers(s); i.shader.bind(n), i.state.set(e), i.geometry.bind(o.geometry, n.glProgram); const h = 2 === o.geometry.indexBuffer.data.BYTES_PER_ELEMENT ? r.UNSIGNED_SHORT : r.UNSIGNED_INT; r.drawElements(r.TRIANGLES, 6 * s.particleChildren.length, h, 0) } } class Ku { execute(t, s) { const e = t.renderer, i = s.shader || t.defaultShader; i.groups[0] = e.renderPipes.uniformBatch.getUniformBindGroup(t.localUniforms, !0), i.groups[1] = e.texture.getTextureBindGroup(s.texture); const n = t.state, r = t.getBuffers(s); e.encoder.draw({ geometry: r.geometry, shader: s.shader || t.defaultShader, state: n, size: 6 * s.particleChildren.length }) } } function Zu(t, s = null) { const e = 6 * t; if (e > 65535 ? s || (s = new Uint32Array(e)) : s || (s = new Uint16Array(e)), s.length !== e) throw new Error(`Out buffer length is incorrect, got ${s.length} and expected ${e}`); for (let i = 0, n = 0; i < e; i += 6, n += 4)s[i + 0] = n + 0, s[i + 1] = n + 1, s[i + 2] = n + 2, s[i + 3] = n + 0, s[i + 4] = n + 2, s[i + 5] = n + 3; return s } function Qu(t, s) { const e = []; e.push("\n\n        var index = 0;\n\n        for (let i = 0; i < ps.length; ++i)\n        {\n            const p = ps[i];\n\n            "); let i = 0; for (const r in t) { const n = t[r]; s === n.dynamic && (e.push(`offset = index + ${i}`), e.push(n.code), i += ze(n.format).stride / 4) } e.push("\n            index += stride * 4;\n        }\n    "), e.unshift(`\n        var stride = ${i};\n    `); const n = e.join("\n"); return new Function("ps", "f32v", "u32v", n) } class Ju { constructor(t) { this.sa = 0, this.Wu = {}; const s = this.sa = t.size ?? 1e3, e = t.properties; let i = 0, n = 0; for (const l in e) { const t = e[l], s = ze(t.format); t.dynamic ? n += s.stride : i += s.stride } this.Hu = n / 4, this.qu = i / 4, this.staticAttributeBuffer = new An(4 * s * i), this.dynamicAttributeBuffer = new An(4 * s * n), this.indexBuffer = Zu(s); const r = new Wn; let o = 0, h = 0; this.Xu = new Vn({ data: new Float32Array(1), label: "static-particle-buffer", shrinkToFit: !1, usage: Ln.VERTEX | Ln.COPY_DST }), this.Yu = new Vn({ data: new Float32Array(1), label: "dynamic-particle-buffer", shrinkToFit: !1, usage: Ln.VERTEX | Ln.COPY_DST }); for (const l in e) { const t = e[l], s = ze(t.format); t.dynamic ? (r.addAttribute(t.attributeName, { buffer: this.Yu, stride: 4 * this.Hu, offset: 4 * o, format: t.format }), o += s.size) : (r.addAttribute(t.attributeName, { buffer: this.Xu, stride: 4 * this.qu, offset: 4 * h, format: t.format }), h += s.size) } r.addIndex(this.indexBuffer); const a = this.getParticleUpdate(e); this.Ku = a.dynamicUpdate, this.Zu = a.staticUpdate, this.geometry = r } getParticleUpdate(t) { const s = function (t) { const s = []; for (const e in t) { const i = t[e]; s.push(e, i.code, i.dynamic ? "d" : "s") } return s.join("_") }(t); return this.Wu[s] || (this.Wu[s] = this.generateParticleUpdate(t)), this.Wu[s] } generateParticleUpdate(t) { return function (t) { return { dynamicUpdate: Qu(t, !0), staticUpdate: Qu(t, !1) } }(t) } update(t, s) { t.length > this.sa && (s = !0, this.sa = Math.max(t.length, 1.5 * this.sa | 0), this.staticAttributeBuffer = new An(this.sa * this.qu * 4 * 4), this.dynamicAttributeBuffer = new An(this.sa * this.Hu * 4 * 4), this.indexBuffer = Zu(this.sa), this.geometry.indexBuffer.setDataWithSize(this.indexBuffer, this.indexBuffer.byteLength, !0)); const e = this.dynamicAttributeBuffer; if (this.Ku(t, e.float32View, e.uint32View), this.Yu.setDataWithSize(this.dynamicAttributeBuffer.float32View, t.length * this.Hu * 4, !0), s) { const s = this.staticAttributeBuffer; this.Zu(t, s.float32View, s.uint32View), this.Xu.setDataWithSize(s.float32View, t.length * this.qu * 4, !0) } } destroy() { this.Xu.destroy(), this.Yu.destroy(), this.geometry.destroy() } } var tc = "\nstruct ParticleUniforms {\n  uTranslationMatrix:mat3x3<f32>,\n  uColor:vec4<f32>,\n  uRound:f32,\n  uResolution:vec2<f32>,\n};\n\nfn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32>\n{\n  return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n}\n\n@group(0) @binding(0) var<uniform> uniforms: ParticleUniforms;\n\n@group(1) @binding(0) var uTexture: texture_2d<f32>;\n@group(1) @binding(1) var uSampler : sampler;\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>,\n    @location(1) color : vec4<f32>,\n  };\n@vertex\nfn mainVertex(\n  @location(0) aVertex: vec2<f32>,\n  @location(1) aPosition: vec2<f32>,\n  @location(2) aUV: vec2<f32>,\n  @location(3) aColor: vec4<f32>,\n  @location(4) aRotation: f32,\n) -> VSOutput {\n  \n   let v = vec2(\n       aVertex.x * cos(aRotation) - aVertex.y * sin(aRotation),\n       aVertex.x * sin(aRotation) + aVertex.y * cos(aRotation)\n   ) + aPosition;\n\n   var position = vec4((uniforms.uTranslationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n   if(uniforms.uRound == 1.0) {\n       position = vec4(roundPixels(position.xy, uniforms.uResolution), position.zw);\n   }\n\n    let vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uniforms.uColor;\n\n  return VSOutput(\n   position,\n   aUV,\n   vColor,\n  );\n}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @location(1) color: vec4<f32>,\n  @builtin(position) position: vec4<f32>,\n) -> @location(0) vec4<f32> {\n\n    var sample = textureSample(uTexture, uSampler, uv) * color;\n   \n    return sample;\n}"; class sc extends Qe { constructor() { super({ glProgram: $e.from({ vertex: "attribute vec2 aVertex;\nattribute vec2 aUV;\nattribute vec4 aColor;\n\nattribute vec2 aPosition;\nattribute float aRotation;\n\nuniform mat3 uTranslationMatrix;\nuniform float uRound;\nuniform vec2 uResolution;\nuniform vec4 uColor;\n\nvarying vec2 vUV;\nvarying vec4 vColor;\n\nvec2 roundPixels(vec2 position, vec2 targetSize)\n{       \n    return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n}\n\nvoid main(void){\n    float cosRotation = cos(aRotation);\n    float sinRotation = sin(aRotation);\n    float x = aVertex.x * cosRotation - aVertex.y * sinRotation;\n    float y = aVertex.x * sinRotation + aVertex.y * cosRotation;\n\n    vec2 v = vec2(x, y);\n    v = v + aPosition;\n\n    gl_Position = vec4((uTranslationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n    if(uRound == 1.0)\n    {\n        gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n    }\n\n    vUV = aUV;\n    vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uColor;\n}\n", fragment: "varying vec2 vUV;\nvarying vec4 vColor;\n\nuniform sampler2D uTexture;\n\nvoid main(void){\n    vec4 color = texture2D(uTexture, vUV) * vColor;\n    gl_FragColor = color;\n}" }), gpuProgram: Ne.from({ fragment: { source: tc, entryPoint: "mainFragment" }, vertex: { source: tc, entryPoint: "mainVertex" } }), resources: { uTexture: Z.WHITE.source, uSampler: new W({}), uniforms: { uTranslationMatrix: { value: new w, type: "mat3x3<f32>" }, uColor: { value: new kt(16777215), type: "vec4<f32>" }, uRound: { value: 1, type: "f32" }, uResolution: { value: [0, 0], type: "vec2<f32>" } } } }) } } class ec { constructor(t, s) { this.state = si.for2d(), this.localUniforms = new Ye({ uTranslationMatrix: { value: new w, type: "mat3x3<f32>" }, uColor: { value: new Float32Array(4), type: "vec4<f32>" }, uRound: { value: 1, type: "f32" }, uResolution: { value: [0, 0], type: "vec2<f32>" } }), this.renderer = t, this.adaptor = s, this.defaultShader = new sc, this.state = si.for2d() } validateRenderable(t) { return !1 } addRenderable(t, s) { this.renderer.renderPipes.batch.break(s), s.add(t) } getBuffers(t) { return t.ps[this.renderer.uid] || this.Qu(t) } Qu(t) { return t.ps[this.renderer.uid] = new Ju({ size: t.particleChildren.length, properties: t.Ju }), t.ps[this.renderer.uid] } updateRenderable(t) { } execute(t) { const s = t.particleChildren; if (0 === s.length) return; const e = this.renderer, i = this.getBuffers(t); t.texture || (t.texture = s[0].texture); const n = this.state; i.update(s, t.tc), t.tc = !1, n.blendMode = Pn(t.blendMode, t.texture.K); const r = this.localUniforms.uniforms, o = r.uTranslationMatrix; t.worldTransform.copyTo(o), o.prepend(e.globalUniforms.globalUniformData.projectionMatrix), r.uResolution = e.globalUniforms.globalUniformData.resolution, r.uRound = e.fs | t.fs, Ol(t.groupColorAlpha, r.uColor, 0), this.adaptor.execute(this, t) } destroy() { this.renderer = null, this.defaultShader && (this.defaultShader.destroy(), this.defaultShader = null) } } class ic extends ec { constructor(t) { super(t, new Yu) } } ic.extension = { type: [r.WebGLPipes], name: "particle" }; class nc extends ec { constructor(t) { super(t, new Ku) } } nc.extension = { type: [r.WebGPUPipes], name: "particle" }; const rc = class t extends Wu { constructor(s = {}) { super({ width: (s = { ...t.defaultOptions, ...s }).width, height: s.height, verticesX: 4, verticesY: 4 }), this.update(s) } update(t) { this.width = t.width ?? this.width, this.height = t.height ?? this.height, this.sc = t.originalWidth ?? this.sc, this.ec = t.originalHeight ?? this.ec, this.nc = t.leftWidth ?? this.nc, this.rc = t.rightWidth ?? this.rc, this.oc = t.topHeight ?? this.oc, this.hc = t.bottomHeight ?? this.hc, this.ac = t.anchor?.x, this.lc = t.anchor?.y, this.updateUvs(), this.updatePositions() } updatePositions() { const t = this.positions, { width: s, height: e, nc: i, rc: n, oc: r, hc: o, ac: h, lc: a } = this, l = i + n, u = s > l ? 1 : s / l, c = r + o, f = e > c ? 1 : e / c, d = Math.min(u, f), p = h * s, m = a * e; t[0] = t[8] = t[16] = t[24] = -p, t[2] = t[10] = t[18] = t[26] = i * d - p, t[4] = t[12] = t[20] = t[28] = s - n * d - p, t[6] = t[14] = t[22] = t[30] = s - p, t[1] = t[3] = t[5] = t[7] = -m, t[9] = t[11] = t[13] = t[15] = r * d - m, t[17] = t[19] = t[21] = t[23] = e - o * d - m, t[25] = t[27] = t[29] = t[31] = e - m, this.getBuffer("aPosition").update() } updateUvs() { const t = this.uvs; t[0] = t[8] = t[16] = t[24] = 0, t[1] = t[3] = t[5] = t[7] = 0, t[6] = t[14] = t[22] = t[30] = 1, t[25] = t[27] = t[29] = t[31] = 1; const s = 1 / this.sc, e = 1 / this.ec; t[2] = t[10] = t[18] = t[26] = s * this.nc, t[9] = t[11] = t[13] = t[15] = e * this.oc, t[4] = t[12] = t[20] = t[28] = 1 - s * this.rc, t[17] = t[19] = t[21] = t[23] = 1 - e * this.hc, this.getBuffer("aUV").update() } }; rc.defaultOptions = { width: 100, height: 100, leftWidth: 10, topHeight: 10, rightWidth: 10, bottomHeight: 10, originalWidth: 100, originalHeight: 100 }; let oc = rc; class hc extends Hu { constructor() { super(), this.geometry = new oc } destroy() { this.geometry.destroy() } } class ac { constructor(t) { this.Be = t } addRenderable(t, s) { const e = this.Qa(t); t.didViewUpdate && this.Ja(t, e), this.Be.renderPipes.batch.addToBatch(e, s) } updateRenderable(t) { const s = this.Qa(t); t.didViewUpdate && this.Ja(t, s), s.In.updateElement(s) } validateRenderable(t) { const s = this.Qa(t); return !s.In.checkAndUpdateTexture(s, t.Y) } Ja(t, s) { s.geometry.update(t), s.setTexture(t.Y) } Qa(t) { return t.ps[this.Be.uid] || this.tl(t) } tl(t) { const s = t.ps[this.Be.uid] = new hc, e = s; return e.renderable = t, e.transform = t.groupTransform, e.texture = t.Y, e.roundPixels = this.Be.fs | t.fs, t.didViewUpdate || this.Ja(t, e), s } destroy() { this.Be = null } } ac.extension = { type: [r.WebGLPipes, r.WebGPUPipes, r.CanvasPipes], name: "nineSliceSprite" }; const lc = { name: "tiling-bit", vertex: { header: "\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        ", main: "\n            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;\n\n            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;\n        " }, fragment: { header: "\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        ", main: "\n\n            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);\n            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;\n            var unclamped = coord;\n            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);\n\n            var bias = 0.;\n\n            if(unclamped.x == coord.x && unclamped.y == coord.y)\n            {\n                bias = -32.;\n            }\n\n            outColor = textureSampleBias(uTexture, uSampler, coord, bias);\n        " } }, uc = { name: "tiling-bit", vertex: { header: "\n            uniform mat3 uTextureTransform;\n            uniform vec4 uSizeAnchor;\n\n        ", main: "\n            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;\n\n            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;\n        " }, fragment: { header: "\n            uniform sampler2D uTexture;\n            uniform mat3 uMapCoord;\n            uniform vec4 uClampFrame;\n            uniform vec2 uClampOffset;\n        ", main: "\n\n        vec2 coord = vUV + ceil(uClampOffset - vUV);\n        coord = (uMapCoord * vec3(coord, 1.0)).xy;\n        vec2 unclamped = coord;\n        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0\n\n        " } }; let cc, fc; class dc extends Qe { constructor() { cc ?? (cc = ur({ name: "tiling-sprite-shader", bits: [Uh, lc, wr] })), fc ?? (fc = cr({ name: "tiling-sprite-shader", bits: [Bh, uc, Mr] })); const t = new Ye({ uMapCoord: { value: new w, type: "mat3x3<f32>" }, uClampFrame: { value: new Float32Array([0, 0, 1, 1]), type: "vec4<f32>" }, uClampOffset: { value: new Float32Array([0, 0]), type: "vec2<f32>" }, uTextureTransform: { value: new w, type: "mat3x3<f32>" }, uSizeAnchor: { value: new Float32Array([100, 100, .5, .5]), type: "vec4<f32>" } }); super({ glProgram: fc, gpuProgram: cc, resources: { localUniforms: new Ye({ uTransformMatrix: { value: new w, type: "mat3x3<f32>" }, uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" }, uRound: { value: 0, type: "f32" } }), tilingUniforms: t, uTexture: Z.EMPTY.source, uSampler: Z.EMPTY.source.style } }) } updateUniforms(t, s, e, i, n, r) { const o = this.resources.tilingUniforms, h = r.width, a = r.height, l = r.textureMatrix, u = o.uniforms.uTextureTransform; u.set(e.a * h / t, e.b * h / s, e.c * a / t, e.d * a / s, e.tx / t, e.ty / s), u.invert(), o.uniforms.uMapCoord = l.mapCoord, o.uniforms.uClampFrame = l.uClampFrame, o.uniforms.uClampOffset = l.uClampOffset, o.uniforms.uTextureTransform = u, o.uniforms.uSizeAnchor[0] = t, o.uniforms.uSizeAnchor[1] = s, o.uniforms.uSizeAnchor[2] = i, o.uniforms.uSizeAnchor[3] = n, r && (this.resources.uTexture = r.source, this.resources.uSampler = r.source.style) } } const pc = new class extends mh { constructor() { super({ positions: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]), uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]), indices: new Uint32Array([0, 1, 2, 0, 2, 3]) }) } }; class mc { constructor() { this.canBatch = !0, this.geometry = new mh({ indices: pc.indices.slice(), positions: pc.positions.slice(), uvs: pc.uvs.slice() }) } destroy() { this.geometry.destroy(), this.shader?.destroy() } } class gc { constructor(t) { this.ji = si.default2d, this.Be = t } validateRenderable(t) { const s = this.uc(t), e = s.canBatch; this.cc(t); const i = s.canBatch; if (i && i === e) { const { batchableMesh: e } = s; return !e.In.checkAndUpdateTexture(e, t.texture) } return e !== i } addRenderable(t, s) { const e = this.Be.renderPipes.batch; this.cc(t); const i = this.uc(t), { geometry: n, canBatch: r } = i; if (r) { i.batchableMesh || (i.batchableMesh = new Hu); const r = i.batchableMesh; t.didViewUpdate && (this.fc(t), r.geometry = n, r.renderable = t, r.transform = t.groupTransform, r.setTexture(t.Y)), r.roundPixels = this.Be.fs | t.fs, e.addToBatch(r, s) } else e.break(s), i.shader || (i.shader = new dc), this.updateRenderable(t), s.add(t) } execute(t) { const { shader: s } = this.uc(t); s.groups[0] = this.Be.globalUniforms.bindGroup; const e = s.resources.localUniforms.uniforms; e.uTransformMatrix = t.groupTransform, e.uRound = this.Be.fs | t.fs, Ol(t.groupColorAlpha, e.uColor, 0), this.ji.blendMode = Pn(t.groupBlendMode, t.texture.K), this.Be.encoder.draw({ geometry: pc, shader: s, state: this.ji }) } updateRenderable(t) { const s = this.uc(t), { canBatch: e } = s; if (e) { const { batchableMesh: e } = s; t.didViewUpdate && this.fc(t), e.In.updateElement(e) } else if (t.didViewUpdate) { const { shader: e } = s; e.updateUniforms(t.width, t.height, t.dc.matrix, t.anchor.x, t.anchor.y, t.texture) } } uc(t) { return t.ps[this.Be.uid] || this.mc(t) } mc(t) { const s = new mc; return s.renderable = t, t.ps[this.Be.uid] = s, s } fc(t) { const s = this.uc(t), { geometry: e } = s, i = t.texture.source.style; "repeat" !== i.addressMode && (i.addressMode = "repeat", i.update()), function (t, s) { const e = t.texture, i = e.frame.width, n = e.frame.height; let r = 0, o = 0; t.applyAnchorToTexture && (r = t.anchor.x, o = t.anchor.y), s[0] = s[6] = -r, s[2] = s[4] = 1 - r, s[1] = s[3] = -o, s[5] = s[7] = 1 - o; const h = w.shared; h.copyFrom(t.dc.matrix), h.tx /= t.width, h.ty /= t.height, h.invert(), h.scale(t.width / i, t.height / n), function (t, s, e, i) { let n = 0; const r = t.length / 2, o = i.a, h = i.b, a = i.c, l = i.d, u = i.tx, c = i.ty; for (e *= 2; n < r;) { const s = t[e], i = t[e + 1]; t[e] = o * s + a * i + u, t[e + 1] = h * s + l * i + c, e += 2, n++ } }(s, 0, 0, h) }(t, e.uvs), function (t, s) { const e = t.anchor.x, i = t.anchor.y; s[0] = -e * t.width, s[1] = -i * t.height, s[2] = (1 - e) * t.width, s[3] = -i * t.height, s[4] = (1 - e) * t.width, s[5] = (1 - i) * t.height, s[6] = -e * t.width, s[7] = (1 - i) * t.height }(t, e.positions) } destroy() { this.Be = null } cc(t) { const s = this.uc(t), e = t.texture; let i = !0; return this.Be.type === Ze.WEBGL && (i = this.Be.context.supports.nonPowOf2wrapping), s.canBatch = e.textureMatrix.isSimple && (i || e.source.isPowerOfTwo), s.canBatch } } gc.extension = { type: [r.WebGLPipes, r.WebGPUPipes, r.CanvasPipes], name: "tilingSprite" }; const vc = { name: "local-uniform-msdf-bit", vertex: { header: "\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32,\n                uRound:f32,\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        ", main: "\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        ", end: "\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        " }, fragment: { header: "\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n         ", main: "\n            outColor = vec4<f32>(calculateMSDFAlpha(outColor, localUniforms.uColor, localUniforms.uDistance));\n        " } }, bc = { name: "local-uniform-msdf-bit", vertex: { header: "\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        ", main: "\n            vColor *= uColor;\n            modelMatrix *= uTransformMatrix;\n        ", end: "\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        " }, fragment: { header: "\n            uniform float uDistance;\n         ", main: "\n            outColor = vec4(calculateMSDFAlpha(outColor, vColor, uDistance));\n        " } }, xc = { name: "msdf-bit", fragment: { header: "\n            fn calculateMSDFAlpha(msdfColor:vec4<f32>, shapeColor:vec4<f32>, distance:f32) -> f32 {\n\n                // MSDF\n                var median = msdfColor.r + msdfColor.g + msdfColor.b -\n                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n\n                // SDF\n                median = min(median, msdfColor.a);\n\n                var screenPxDistance = distance * (median - 0.5);\n                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                // Gamma correction for coverage-like alpha\n                var luma: f32 = dot(shapeColor.rgb, vec3<f32>(0.299, 0.587, 0.114));\n                var gamma: f32 = mix(1.0, 1.0 / 2.2, luma);\n                var coverage: f32 = pow(shapeColor.a * alpha, gamma);\n\n                return coverage;\n\n            }\n        " } }, yc = { name: "msdf-bit", fragment: { header: "\n            float calculateMSDFAlpha(vec4 msdfColor, vec4 shapeColor, float distance) {\n\n                // MSDF\n                float median = msdfColor.r + msdfColor.g + msdfColor.b -\n                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n\n                // SDF\n                median = min(median, msdfColor.a);\n\n                float screenPxDistance = distance * (median - 0.5);\n                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n\n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                // Gamma correction for coverage-like alpha\n                float luma = dot(shapeColor.rgb, vec3(0.299, 0.587, 0.114));\n                float gamma = mix(1.0, 1.0 / 2.2, luma);\n                float coverage = pow(shapeColor.a * alpha, gamma);\n\n                return coverage;\n            }\n        " } }; let wc, Mc; class Tc extends Qe { constructor(t) { const s = new Ye({ uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" }, uTransformMatrix: { value: new w, type: "mat3x3<f32>" }, uDistance: { value: 4, type: "f32" }, uRound: { value: 0, type: "f32" } }); wc ?? (wc = ur({ name: "sdf-shader", bits: [fr, vr(t), vc, xc, wr] })), Mc ?? (Mc = cr({ name: "sdf-shader", bits: [dr, yr(t), bc, yc, Mr] })), super({ glProgram: Mc, gpuProgram: wc, resources: { localUniforms: s, batchSamplers: Ar(t) } }) } } class Ac extends dh { destroy() { this.context.customShader && this.context.customShader.destroy(), super.destroy() } } class Cc { constructor(t) { this.Be = t } validateRenderable(t) { const s = this.gc(t); return this.Be.renderPipes.graphics.validateRenderable(s) } addRenderable(t, s) { const e = this.gc(t); _c(t, e), t.Ho && (t.Ho = !1, this.vc(t, e)), this.Be.renderPipes.graphics.addRenderable(e, s), e.context.customShader && this.bc(t) } updateRenderable(t) { const s = this.gc(t); _c(t, s), this.Be.renderPipes.graphics.updateRenderable(s), s.context.customShader && this.bc(t) } vc(t, s) { const { context: e } = s, i = Wo.getFont(t.text, t.L); e.clear(), "none" !== i.distanceField.type && (e.customShader || (e.customShader = new Tc(this.Be.limits.maxBatchableTextures))); const n = rn.graphemeSegmenter(t.text), r = t.L; let o = i.baseLineOffset; const h = Vo(n, r, i, !0), a = r.padding, l = h.scale; let u = h.width, c = h.height + h.offsetY; r.ln && (u += r.ln.width / l, c += r.ln.width / l), e.translate(-t.xs.M * u - a, -t.xs.T * c - a).scale(l, l); const f = i.applyFillAsTint ? r.kr.color : 16777215; let d = i.fontMetrics.fontSize, p = i.lineHeight; r.lineHeight && (d = r.fontSize / l, p = r.lineHeight / l); let m = (p - d) / 2; m - i.baseLineOffset < 0 && (m = 0); for (let g = 0; g < h.lines.length; g++) { const t = h.lines[g]; for (let s = 0; s < t.charPositions.length; s++) { const n = t.chars[s], r = i.chars[n]; if (r?.texture) { const i = r.texture; e.texture(i, f || "black", Math.round(t.charPositions[s] + r.xOffset), Math.round(o + r.yOffset + m), i.orig.width, i.orig.height) } } o += p } } gc(t) { return t.ps[this.Be.uid] || this.initGpuText(t) } initGpuText(t) { const s = new Ac; return t.ps[this.Be.uid] = s, this.vc(t, s), s } bc(t) { const s = this.gc(t).context, e = t.L.fontFamily, i = Ds.get(`${e}-bitmap`), { a: n, b: r, c: o, d: h } = t.groupTransform, a = Math.sqrt(n * n + r * r), l = Math.sqrt(o * o + h * h), u = (Math.abs(a) + Math.abs(l)) / 2, c = i.baseRenderedFontSize / t.L.fontSize, f = u * i.distanceField.range * (1 / c); s.customShader.resources.localUniforms.uniforms.uDistance = f } destroy() { this.Be = null } } function _c(t, s) { s.groupTransform = t.groupTransform, s.groupColorAlpha = t.groupColorAlpha, s.groupColor = t.groupColor, s.groupBlendMode = t.groupBlendMode, s.globalDisplayStatus = t.globalDisplayStatus, s.groupTransform = t.groupTransform, s.localDisplayStatus = t.localDisplayStatus, s.groupAlpha = t.groupAlpha, s.fs = t.fs } Cc.extension = { type: [r.WebGLPipes, r.WebGPUPipes, r.CanvasPipes], name: "bitmapText" }; class Sc extends ll { constructor(t) { super(), this.generatingTexture = !1, this.currentKey = "--", this.Be = t, t.runners.resolutionChange.add(this) } resolutionChange() { const t = this.renderable; t.Wo && t.onViewUpdate() } destroy() { const { htmlText: t } = this.Be; null === t.getReferenceCount(this.currentKey) ? t.returnTexturePromise(this.texturePromise) : t.decreaseReferenceCount(this.currentKey), this.Be.runners.resolutionChange.remove(this), this.texturePromise = null, this.Be = null } } function Pc(t, s) { const { texture: e, bounds: i } = t, n = s.L.Er(); Q(i, s.xs, e); const r = s.xs.M * n * 2, o = s.xs.T * n * 2; i.minX -= n - r, i.minY -= n - o, i.maxX -= n - r, i.maxY -= n - o } class kc { constructor(t) { this.Be = t } validateRenderable(t) { const s = this.xc(t), e = t.styleKey; return s.currentKey !== e } addRenderable(t, s) { const e = this.xc(t); if (t.Ho) { const s = t.Wo ? this.Be.resolution : t.resolution; e.currentKey === t.styleKey && t.resolution === s || this.yc(t).catch(t => { }), t.Ho = !1, Pc(e, t) } this.Be.renderPipes.batch.addToBatch(e, s) } updateRenderable(t) { const s = this.xc(t); s.In.updateElement(s) } async yc(t) { t.Ho = !1; const s = this.xc(t); if (s.generatingTexture) return; const e = s.texturePromise; s.texturePromise = null, s.generatingTexture = !0, t.$ = t.Wo ? this.Be.resolution : t.resolution; let i = this.Be.htmlText.getTexturePromise(t); e && (i = i.finally(() => { this.Be.htmlText.decreaseReferenceCount(s.currentKey), this.Be.htmlText.returnTexturePromise(e) })), s.texturePromise = i, s.currentKey = t.styleKey, s.texture = await i; const n = t.renderGroup || t.parentRenderGroup; n && (n.structureDidChange = !0), s.generatingTexture = !1, Pc(s, t) } xc(t) { return t.ps[this.Be.uid] || this.initGpuText(t) } initGpuText(t) { const s = new Sc(this.Be); return s.renderable = t, s.transform = t.groupTransform, s.texture = Z.EMPTY, s.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 }, s.roundPixels = this.Be.fs | t.fs, t.$ = t.Wo ? this.Be.resolution : t.resolution, t.ps[this.Be.uid] = s, s } destroy() { this.Be = null } } kc.extension = { type: [r.WebGLPipes, r.WebGPUPipes, r.CanvasPipes], name: "htmlText" }; const Fc = new tt; function Ec(t, s, e, i) { const n = Fc; n.minX = 0, n.minY = 0, n.maxX = t.width / i | 0, n.maxY = t.height / i | 0; const r = fs.getOptimalTexture(n.width, n.height, i, !1); return r.source.uploadMethodId = "image", r.source.resource = t, r.source.alphaMode = "premultiply-alpha-on-upload", r.frame.width = s / i, r.frame.height = e / i, r.source.emit("update", r.source), r.updateUvs(), r } const Rc = new Map; class Oc { constructor(t) { this.wc = {}, this.Be = t, this.Mc = t.type === Ze.WEBGPU } getTexture(t) { return this.getTexturePromise(t) } getManagedTexture(t) { const s = t.styleKey; if (this.wc[s]) return this.Tc(s), this.wc[s].promise; const e = this.Ac(t).then(t => (this.wc[s].texture = t, t)); return this.wc[s] = { texture: null, promise: e, usageCount: 1 }, e } getReferenceCount(t) { return this.wc[t]?.usageCount ?? null } Tc(t) { this.wc[t].usageCount++ } decreaseReferenceCount(t) { const s = this.wc[t]; s && (s.usageCount--, 0 === s.usageCount && (s.texture ? this.Cc(s.texture) : s.promise.then(t => { s.texture = t, this.Cc(s.texture) }).catch(() => { Et() }), this.wc[t] = null)) } getTexturePromise(t) { return this.Ac(t) } async Ac(t) { const { text: s, style: e, resolution: i, textureStyle: n } = t, r = Ut.get(Sh), o = function (t, s) { const e = s.fontFamily, i = [], n = {}, r = t.match(/font-family:([^;"\s]+)/g); function o(t) { n[t] || (i.push(t), n[t] = !0) } if (Array.isArray(e)) for (let h = 0; h < e.length; h++)o(e[h]); else o(e); r && r.forEach(t => { o(t.split(":")[1].trim()) }); for (const h in s.tagStyles) o(s.tagStyles[h].fontFamily); return i }(s, e), h = await async function (t) { const s = t.filter(t => Ds.has(`${t}-and-url`)).map(t => { if (!Rc.has(t)) { const { entries: s } = Ds.get(`${t}-and-url`), e = []; s.forEach(s => { const i = s.url, n = s.faces.map(t => ({ weight: t.weight, style: t.style })); e.push(...n.map(s => async function (t, s) { const e = await async function (t) { const s = await ks.get().fetch(t), e = await s.blob(), i = new FileReader; return await new Promise((t, s) => { i.onloadend = () => t(i.result), i.onerror = s, i.readAsDataURL(e) }) }(s); return `@font-face {\n        font-family: "${t.fontFamily}";\n        font-weight: ${t.fontWeight};\n        font-style: ${t.fontStyle};\n        src: url('${e}');\n    }` }({ fontWeight: s.weight, fontStyle: s.style, fontFamily: t }, i))) }), Rc.set(t, Promise.all(e).then(t => t.join("\n"))) } return Rc.get(t) }); return (await Promise.all(s)).join("\n") }(o), a = function (t, s, e, i) { i || (i = Ph || (Ph = new Sh)); const { domElement: n, styleElement: r, svgRoot: o } = i; n.innerHTML = `<style>${s.cssStyle};</style><div style='padding:0'>${t}</div>`, n.setAttribute("style", "transform-origin: top left; display: inline-block"), e && (r.textContent = e), document.body.appendChild(o); const h = n.getBoundingClientRect(); o.remove(); const a = 2 * s.padding; return { width: h.width - a, height: h.height - a } }(s, e, h, r), l = Math.ceil(Math.ceil(Math.max(1, a.width) + 2 * e.padding) * i), u = Math.ceil(Math.ceil(Math.max(1, a.height) + 2 * e.padding) * i), c = r.image; c.width = 2 + (0 | l), c.height = 2 + (0 | u); const f = function (t, s, e, i, n) { const { domElement: r, styleElement: o, svgRoot: h } = n; r.innerHTML = `<style>${s.cssStyle}</style><div style='padding:0;'>${t}</div>`, r.setAttribute("style", `transform: scale(${e});transform-origin: top left; display: inline-block`), o.textContent = i; const { width: a, height: l } = n.image; return h.setAttribute("width", a.toString()), h.setAttribute("height", l.toString()), (new XMLSerializer).serializeToString(h) }(s, e, i, h, r); await function (t, s, e) { return new Promise(async i => { e && await new Promise(t => setTimeout(t, 100)), t.onload = () => { i() }, t.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(s)}`, t.crossOrigin = "anonymous" }) }(c, f, function () { const { userAgent: t } = ks.get().getNavigator(); return /^((?!chrome|android).)*safari/i.test(t) }() && o.length > 0); const d = c; let p; this.Mc && (p = function (t, s) { const e = Go.getOptimalCanvasAndContext(t.width, t.height, s), { context: i } = e; return i.clearRect(0, 0, t.width, t.height), i.drawImage(t, 0, 0), e }(c, i)); const m = Ec(p ? p.canvas : d, c.width - 2, c.height - 2, i); return n && (m.source.style = n), this.Mc && (this.Be.texture.initSource(m.source), Go.returnCanvasAndContext(p)), Ut.return(r), m } returnTexturePromise(t) { t.then(t => { this.Cc(t) }).catch(() => { Et() }) } Cc(t) { fs.returnTexture(t, !0), t.source.resource = null, t.source.uploadMethodId = "unknown" } destroy() { this.Be = null; for (const t in this.wc) this.wc[t] && this.returnTexturePromise(this.wc[t].promise); this.wc = null } } Oc.extension = { type: [r.WebGLSystem, r.WebGPUSystem, r.CanvasSystem], name: "htmlText" }; class Uc extends ll { constructor(t) { super(), this.Be = t, t.runners.resolutionChange.add(this) } resolutionChange() { const t = this.renderable; t.Wo && t.onViewUpdate() } destroy() { const { canvasText: t } = this.Be; t.getReferenceCount(this.currentKey) > 0 ? t.decreaseReferenceCount(this.currentKey) : this.texture && t.returnTexture(this.texture), this.Be.runners.resolutionChange.remove(this), this.Be = null } } class Ic { constructor(t) { this.Be = t } validateRenderable(t) { const s = this.xc(t), e = t.styleKey; return s.currentKey !== e || t.Ho } addRenderable(t, s) { const e = this.xc(t); if (t.Ho) { const s = t.Wo ? this.Be.resolution : t.resolution; e.currentKey === t.styleKey && t.resolution === s || this.yc(t), t.Ho = !1, Pc(e, t) } this.Be.renderPipes.batch.addToBatch(e, s) } updateRenderable(t) { const s = this.xc(t); s.In.updateElement(s) } yc(t) { const s = this.xc(t); s.texture && this.Be.canvasText.decreaseReferenceCount(s.currentKey), t.$ = t.Wo ? this.Be.resolution : t.resolution, s.texture = this.Be.canvasText.getManagedTexture(t), s.currentKey = t.styleKey } xc(t) { return t.ps[this.Be.uid] || this.initGpuText(t) } initGpuText(t) { const s = new Uc(this.Be); return s.currentKey = "--", s.renderable = t, s.transform = t.groupTransform, s.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 }, s.roundPixels = this.Be.fs | t.fs, t.ps[this.Be.uid] = s, s } destroy() { this.Be = null } } Ic.extension = { type: [r.WebGLPipes, r.WebGPUPipes, r.CanvasPipes], name: "text" }; class Bc { constructor(t) { this.wc = {}, this.Be = t } getTexture(t, s, e, i) { "string" == typeof t && (G(0, "CanvasTextSystem.getTexture: Use object TextOptions instead of separate arguments"), t = { text: t, style: e, resolution: s }), t.style instanceof $o || (t.style = new $o(t.style)), t.textureStyle instanceof W || (t.textureStyle = new W(t.textureStyle)), "string" != typeof t.text && (t.text = t.text.toString()); const { text: n, style: r, textureStyle: o } = t, h = t.resolution ?? this.Be.resolution, { frame: a, canvasAndContext: l } = Th.getCanvasAndContext({ text: n, style: r, resolution: h }), u = Ec(l.canvas, a.width, a.height, h); if (o && (u.source.style = o), r.trim && (a.pad(r.padding), u.frame.copyFrom(a), u.frame.scale(1 / h), u.updateUvs()), r.filters) { const t = this._c(u, r.filters); return this.returnTexture(u), Th.returnCanvasAndContext(l), t } return this.Be.texture.initSource(u.K), Th.returnCanvasAndContext(l), u } returnTexture(t) { const s = t.source; s.resource = null, s.uploadMethodId = "unknown", s.alphaMode = "no-premultiply-alpha", fs.returnTexture(t, !0) } renderTextToCanvas() { G(0, "CanvasTextSystem.renderTextToCanvas: no longer supported, use CanvasTextSystem.getTexture instead") } getManagedTexture(t) { t.$ = t.Wo ? this.Be.resolution : t.resolution; const s = t.styleKey; if (this.wc[s]) return this.Tc(s), this.wc[s].texture; const e = this.getTexture({ text: t.text, style: t.style, resolution: t.$, textureStyle: t.textureStyle }); return this.wc[s] = { texture: e, usageCount: 1 }, e } decreaseReferenceCount(t) { const s = this.wc[t]; s.usageCount--, 0 === s.usageCount && (this.returnTexture(s.texture), this.wc[t] = null) } getReferenceCount(t) { return this.wc[t]?.usageCount ?? 0 } Tc(t) { this.wc[t].usageCount++ } _c(t, s) { const e = this.Be.renderTarget.renderTarget, i = this.Be.filter.generateFilteredTexture({ texture: t, filters: s }); return this.Be.renderTarget.bind(e, !1), i } destroy() { this.Be = null; for (const t in this.wc) this.wc[t] && this.returnTexture(this.wc[t].texture); this.wc = null } } Bc.extension = { type: [r.WebGLSystem, r.WebGPUSystem, r.CanvasSystem], name: "canvasText" }, a.add(l, u); var $c = Object.defineProperty, Gc = (t, s, e) => (((t, s, e) => { s in t ? $c(t, s, { enumerable: !0, configurable: !0, writable: !0, value: e }) : t[s] = e })(t, "symbol" != typeof s ? s + "" : s, e), e); const zc = class t extends ii { constructor(s) { const e = (s = { ...t.DEFAULT_OPTIONS, ...s }).distance ?? 10, i = s.quality ?? .1; super({ gpuProgram: Ne.from({ vertex: { source: "struct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>\n  };\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \n}\n\nfn getSize() -> vec2<f32>\n{\n  return gfu.uGlobalFrame.zw;\n}\n  \n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition)\n  );\n}", entryPoint: "mainVertex" }, fragment: { source: "struct GlowUniforms {\n  uDistance: f32,\n  uStrength: vec2<f32>,\n  uColor: vec3<f32>,\n  uAlpha: f32,\n  uQuality: f32,\n  uKnockout: f32,\n};\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> glowUniforms : GlowUniforms;\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n  let quality = glowUniforms.uQuality;\n  let distance = glowUniforms.uDistance;\n\n  let dist: f32 = glowUniforms.uDistance;\n  let angleStepSize: f32 = min(1. / quality / distance, PI * 2.0);\n  let angleStepNum: f32 = ceil(PI * 2.0 / angleStepSize);\n\n  let px: vec2<f32> = vec2<f32>(1.0 / gfu.uInputSize.xy);\n\n  var totalAlpha: f32 = 0.0;\n\n  var direction: vec2<f32>;\n  var displaced: vec2<f32>;\n  var curColor: vec4<f32>;\n\n  for (var angle = 0.0; angle < PI * 2.0; angle += angleStepSize) {\n    direction = vec2<f32>(cos(angle), sin(angle)) * px;\n    for (var curDistance = 0.0; curDistance < dist; curDistance+=1) {\n      displaced = vec2<f32>(clamp(uv + direction * (curDistance + 1.0), gfu.uInputClamp.xy, gfu.uInputClamp.zw));\n      curColor = textureSample(uTexture, uSampler, displaced);\n      totalAlpha += (dist - curDistance) * curColor.a;\n    }\n  }\n    \n  curColor = textureSample(uTexture, uSampler, uv);\n\n  let glowColorRGB = glowUniforms.uColor;\n  let glowAlpha = glowUniforms.uAlpha;\n  let glowColor = vec4<f32>(glowColorRGB, glowAlpha);\n  let knockout: bool = glowUniforms.uKnockout > 0.5;\n  let innerStrength = glowUniforms.uStrength[0];\n  let outerStrength = glowUniforms.uStrength[1];\n\n  let alphaRatio: f32 = (totalAlpha / (angleStepNum * dist * (dist + 1.0) / 2.0));\n  let innerGlowAlpha: f32 = (1.0 - alphaRatio) * innerStrength * curColor.a * glowAlpha;\n  let innerGlowStrength: f32 = min(1.0, innerGlowAlpha);\n  \n  let innerColor: vec4<f32> = mix(curColor, glowColor, innerGlowStrength);\n  let outerGlowAlpha: f32 = alphaRatio * outerStrength * (1. - curColor.a) * glowAlpha;\n  let outerGlowStrength: f32 = min(1.0 - innerColor.a, outerGlowAlpha);\n  let outerGlowColor: vec4<f32> = outerGlowStrength * glowColor.rgba;\n  \n  if (knockout) {\n    let resultAlpha: f32 = outerGlowAlpha + innerGlowAlpha;\n    return vec4<f32>(glowColor.rgb * resultAlpha, resultAlpha);\n  }\n  else {\n    return innerColor + outerGlowColor;\n  }\n}\n\nconst PI: f32 = 3.14159265358979323846264;", entryPoint: "mainFragment" } }), glProgram: $e.from({ vertex: "in vec2 aPosition;\nout vec2 vTextureCoord;\n\nuniform vec4 uInputSize;\nuniform vec4 uOutputFrame;\nuniform vec4 uOutputTexture;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\n    \n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n", fragment: "precision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform vec2 uStrength;\nuniform vec3 uColor;\nuniform float uKnockout;\nuniform float uAlpha;\n\nuniform vec4 uInputSize;\nuniform vec4 uInputClamp;\n\nconst float PI = 3.14159265358979323846264;\n\n// Hard-assignment of DIST and ANGLE_STEP_SIZE instead of using uDistance and uQuality to allow them to be use on GLSL loop conditions\nconst float DIST = __DIST__;\nconst float ANGLE_STEP_SIZE = min(__ANGLE_STEP_SIZE__, PI * 2.);\nconst float ANGLE_STEP_NUM = ceil(PI * 2. / ANGLE_STEP_SIZE);\nconst float MAX_TOTAL_ALPHA = ANGLE_STEP_NUM * DIST * (DIST + 1.) / 2.;\n\nvoid main(void) {\n    vec2 px = vec2(1.) / uInputSize.xy;\n\n    float totalAlpha = 0.;\n\n    vec2 direction;\n    vec2 displaced;\n    vec4 curColor;\n\n    for (float angle = 0.; angle < PI * 2.; angle += ANGLE_STEP_SIZE) {\n      direction = vec2(cos(angle), sin(angle)) * px;\n\n      for (float curDistance = 0.; curDistance < DIST; curDistance++) {\n          displaced = clamp(vTextureCoord + direction * (curDistance + 1.), uInputClamp.xy, uInputClamp.zw);\n          curColor = texture(uTexture, displaced);\n          totalAlpha += (DIST - curDistance) * curColor.a;\n      }\n    }\n    \n    curColor = texture(uTexture, vTextureCoord);\n\n    vec4 glowColor = vec4(uColor, uAlpha);\n    bool knockout = uKnockout > .5;\n    float innerStrength = uStrength[0];\n    float outerStrength = uStrength[1];\n\n    float alphaRatio = totalAlpha / MAX_TOTAL_ALPHA;\n    float innerGlowAlpha = (1. - alphaRatio) * innerStrength * curColor.a * uAlpha;\n    float innerGlowStrength = min(1., innerGlowAlpha);\n    \n    vec4 innerColor = mix(curColor, glowColor, innerGlowStrength);\n    float outerGlowAlpha = alphaRatio * outerStrength * (1. - curColor.a) * uAlpha;\n    float outerGlowStrength = min(1. - innerColor.a, outerGlowAlpha);\n    vec4 outerGlowColor = outerGlowStrength * glowColor.rgba;\n\n    if (knockout) {\n      float resultAlpha = outerGlowAlpha + innerGlowAlpha;\n      finalColor = vec4(glowColor.rgb * resultAlpha, resultAlpha);\n    }\n    else {\n      finalColor = innerColor + outerGlowColor;\n    }\n}\n".replace(/__ANGLE_STEP_SIZE__/gi, `${(1 / i / e).toFixed(7)}`).replace(/__DIST__/gi, `${e.toFixed(0)}.0`), name: "glow-filter" }), resources: { glowUniforms: { uDistance: { value: e, type: "f32" }, uStrength: { value: [s.innerStrength, s.outerStrength], type: "vec2<f32>" }, uColor: { value: new Float32Array(3), type: "vec3<f32>" }, uAlpha: { value: s.alpha, type: "f32" }, uQuality: { value: i, type: "f32" }, uKnockout: { value: s?.knockout ? 1 : 0, type: "f32" } } }, padding: e }), Gc(this, "uniforms"), Gc(this, "_color"), this.uniforms = this.resources.glowUniforms.uniforms, this.Sc = new kt, this.color = s.color ?? 16777215 } get distance() { return this.uniforms.uDistance } set distance(t) { this.uniforms.uDistance = this.padding = t } get innerStrength() { return this.uniforms.uStrength[0] } set innerStrength(t) { this.uniforms.uStrength[0] = t } get outerStrength() { return this.uniforms.uStrength[1] } set outerStrength(t) { this.uniforms.uStrength[1] = t } get color() { return this.Sc.value } set color(t) { this.Sc.setValue(t); const [s, e, i] = this.Sc.toArray(); this.uniforms.uColor[0] = s, this.uniforms.uColor[1] = e, this.uniforms.uColor[2] = i } get alpha() { return this.uniforms.uAlpha } set alpha(t) { this.uniforms.uAlpha = t } get quality() { return this.uniforms.uQuality } set quality(t) { this.uniforms.uQuality = t } get knockout() { return 1 === this.uniforms.uKnockout } set knockout(t) { this.uniforms.uKnockout = t ? 1 : 0 } }; Gc(zc, "DEFAULT_OPTIONS", { distance: 10, outerStrength: 4, innerStrength: 0, color: 16777215, alpha: 1, quality: .1, knockout: !1 }); let Dc = zc, jc = { minFallSpeed: .02, maxFallSpeed: .1, minShuffleSpeed: .1, maxShuffleSpeed: 1, headShuffleSpeed: 10, newHeadChance: .005, symbolSize: 22, minChain: 30, maxChain: 80, bgColor: "#000000", mainColor: "#00DB00", firstColor: "#ffffff", shadowColor: "#299258", whiteShadowColor: "#ffffff", glowColor: "#b6ffb6ff", phrase: ["Wake up, Neo...", "The Matrix has you...", "Follow the white rabbit.", "Knock, knock, Neo."], characters: "      " }; const Lc = { background: jc.bgColor, resizeTo: window, resolution: window.devicePixelRatio || 1, autoDensity: !0, antialias: !1 }, Vc = { distance: 4, outerStrength: 1, color: jc.glowColor, quality: .5 }; function Nc(t, s) { return Math.random() * (s - t) + t } class Wc { constructor(t, e, i, n, r) { s(this, "x"), s(this, "screenHeight"), s(this, "particles", []), s(this, "heads", []), s(this, "textures"), s(this, "headTextures"), s(this, "container"), s(this, "totalRows", 0), s(this, "screenRows", 0), s(this, "restartDelay", 0), s(this, "columnCompleted", !1), s(this, "maxLength", 0), s(this, "alphaStep", 0), s(this, "particleShuffleTimers", new Map), s(this, "minParticleShuffleTime", 60 * jc.minShuffleSpeed), s(this, "maxParticleShuffleTime", 60 * jc.maxShuffleSpeed); const o = e * (Nc(jc.minChain, jc.maxChain) / 100); this.x = t, this.screenHeight = e, this.container = i, this.textures = n, this.headTextures = r, this.screenRows = Math.floor(e / jc.symbolSize), this.maxLength = Math.floor(o / jc.symbolSize), this.alphaStep = 1 / this.maxLength, this.totalRows = this.screenRows + this.maxLength, this.particles = new Array(this.totalRows).fill(null), this.restartDelay = Nc(0, 100) } getRandomTexture() { return this.textures[Math.floor(Math.random() * this.textures.length)] } getRandomHeadTexture() { return this.headTextures[Math.floor(Math.random() * this.headTextures.length)] } canCreateNewHead() { if (0 === this.heads.length) return !0; const t = this.heads.reduce((t, s) => !t || s.index < t.index ? s : t, null); if (!t) return !0; const s = Math.max(0, t.index - t.maxLength), e = Math.abs(0 - s); return e >= 1 && e <= 10 } createHead() { if (this.heads.length >= 2) return; if (!this.canCreateNewHead()) return; const t = this.getRandomHeadTexture(), s = new ys(t); s.x = this.x, s.y = -1 * jc.symbolSize, s.alpha = 1, s.tint = jc.firstColor, s.label = "head", this.container.addChild(s); const e = { sprite: s, index: 0, length: 1, moveCounter: 0, shuffleCounter: 0, moveDelay: 60 * Nc(jc.minFallSpeed, jc.maxFallSpeed), maxLength: Math.floor(this.screenHeight * Nc(jc.minChain, jc.maxChain) / 100 / jc.symbolSize), alphaStep: 0, particles: new Array(this.totalRows).fill(null) }; e.alphaStep = 1 / e.maxLength, e.particles[0] = s, this.heads.push(e) } moveHead(t) { if (!t.sprite) return; const s = t.index + 1, e = this.heads.filter(s => s !== t); for (const r of e) { const e = Math.abs(s - r.index), i = Math.max(0, r.index - r.maxLength), n = Math.abs(s - i); if (e < 5 || n < 2) return void (t.moveDelay = Math.min(1.5 * t.moveDelay, 18)) } const i = t.index, n = t.sprite; if (i > 0) { const s = this.getRandomHeadTexture(), e = new ys(s), r = t.length - 1; e.x = this.x, e.y = n.y, e.tint = jc.mainColor, e.alpha = Math.max(0, 1 - t.alphaStep * r), this.particleShuffleTimers.set(e, Nc(this.minParticleShuffleTime, this.maxParticleShuffleTime)), this.container.addChild(e), t.particles[i] = e } if (n.y += jc.symbolSize, t.index = s, n.tint = jc.firstColor, t.length >= t.maxLength) { const e = s - t.maxLength; e >= 0 && t.particles[e] && t.particles[e] !== t.sprite && (this.container.removeChild(t.particles[e]), t.particles[e] = null) } else t.length++; if (t.particles[s] && this.container.removeChild(t.particles[s]), t.particles[s] = n, s >= this.totalRows - 1) { this.container.removeChild(n); for (let s = 0; s < t.particles.length; s++)t.particles[s] && this.container.removeChild(t.particles[s]); this.heads = this.heads.filter(s => s !== t) } } update(t) { if (this.restartDelay > 0) this.restartDelay -= t.deltaTime; else { Math.random() < jc.newHeadChance && this.createHead(); for (let s = this.heads.length - 1; s >= 0; s--) { const e = this.heads[s]; e.shuffleCounter += t.deltaTime, e.shuffleCounter > jc.headShuffleSpeed && (e.shuffleCounter = 0, e.sprite.texture = this.getRandomHeadTexture(), e.sprite.tint = jc.firstColor), e.moveCounter += t.deltaTime, e.moveCounter > e.moveDelay && (e.moveCounter = 0, this.moveHead(e), e.moveDelay = 60 * Nc(jc.minFallSpeed, jc.maxFallSpeed)); for (let s = 0; s < e.particles.length; s++) { const i = e.particles[s]; if (i && i !== e.sprite) { const n = e.index - s; if (n > 0 && (i.alpha = Math.max(.1, 1 - e.alphaStep * n)), this.particleShuffleTimers.has(i)) { let s = this.particleShuffleTimers.get(i) - t.deltaTime; s <= 0 && (i.texture = this.getRandomTexture(), i.tint = jc.mainColor, s = Nc(this.minParticleShuffleTime, this.maxParticleShuffleTime)), this.particleShuffleTimers.set(i, s) } } } } this.cleanupShuffleTimers(), 0 !== this.heads.length || this.columnCompleted || (this.columnCompleted = !0, this.restartDelay = Nc(30, 180)) } } cleanupShuffleTimers() { const t = []; this.particleShuffleTimers.forEach((s, e) => { let i = !1; for (const t of this.heads) if (t.particles.includes(e)) { i = !0; break } i || t.push(e) }), t.forEach(t => { this.particleShuffleTimers.delete(t) }) } } class Hc { constructor(t) { s(this, "app"), s(this, "particleContainer"), s(this, "columns", []), s(this, "textures", []), s(this, "headTextures", []), s(this, "update", t => { this.columns.forEach(s => s.update(t)) }), this.app = t, this.particleContainer = new bs, t.stage.addChild(this.particleContainer), this.generateTextures(), this.createColumns(), t.ticker.add(t => { this.update(t) }) } generateTextures() { const t = jc.characters; for (let s = 0; s < t.length; s++) { const e = new Ah({ text: t[s], style: { fontFamily: "monospace", fontSize: jc.symbolSize, fill: jc.mainColor, dropShadow: { color: jc.whiteShadowColor, blur: 10, distance: 8, angle: Math.PI / 2 } } }); this.textures.push(this.app.renderer.generateTexture(e)) } for (let s = 0; s < t.length; s++) { const e = new Ah({ text: t[s], style: { fontFamily: "monospace", fontSize: jc.symbolSize, fill: jc.firstColor, dropShadow: { color: jc.whiteShadowColor, blur: 10, distance: 8, angle: Math.PI / 2 } } }); this.headTextures.push(this.app.renderer.generateTexture(e)) } } createColumns() { const t = this.app.renderer.width, s = Math.floor(t / jc.symbolSize); for (let e = 0; e < s; e++) { const t = new Wc(e * jc.symbolSize, this.app.renderer.height, this.particleContainer, this.textures, this.headTextures); this.columns.push(t) } } reset() { this.particleContainer.removeChildren(), this.columns = [], this.createColumns() } } (async () => { const t = new Xi; await t.init(Lc), await async function () { return new Promise(t => { const s = jc.phrase[Math.floor(Math.random() * jc.phrase.length)], e = document.createElement("div"); e.id = "welcome-screen", e.style.cssText = "\n            position: fixed;\n            top: 50px;\n            left: 50px;\n            background: #000000;\n            z-index: 9999;\n            font-family: monospace;\n            font-size: 32px;\n            color: #00DB00;\n            text-shadow: 0 0 10px #00DB00;\n        "; const i = document.createElement("span"); e.appendChild(i), document.body.appendChild(e); let n = 0; const r = () => { if (n < s.length) i.textContent += s.charAt(n), n++, setTimeout(r, 100); else { const s = document.createElement("span"); s.textContent = "_", s.style.animation = "blink 1s infinite", i.appendChild(s); const n = document.createElement("style"); n.textContent = "\n                    @keyframes blink {\n                        0%, 49% { opacity: 1; }\n                        50%, 100% { opacity: 0; }\n                    }\n                ", document.head.appendChild(n); const r = () => { e.style.transition = "opacity 1s", e.style.opacity = "0", setTimeout(() => { e.remove(), t() }, 1e3) }; e.addEventListener("click", r), setTimeout(r, 3e3) } }; setTimeout(r, 500) }) }(), document.getElementById("matrix-rain").appendChild(t.canvas), t.stage.filters = [new Dc(Vc)]; const s = new Hc(t); let e = !1; const i = document.getElementById("settings-panel"), n = document.getElementById("apply-settings"); i.querySelectorAll('input[type="range"]').forEach(t => { const s = t, e = document.getElementById(`${s.id}-val`); s.addEventListener("input", () => { e.textContent = s.value }) }); const r = () => { i.classList.remove("open"), e = !1 }; n.addEventListener("click", () => { var t; t = { minFallSpeed: parseFloat(document.getElementById("minFallSpeed").value), maxFallSpeed: parseFloat(document.getElementById("maxFallSpeed").value), headShuffleSpeed: parseInt(document.getElementById("headShuffleSpeed").value), newHeadChance: parseFloat(document.getElementById("newHeadChance").value), symbolSize: parseInt(document.getElementById("symbolSize").value), minChain: parseInt(document.getElementById("minChain").value), maxChain: parseInt(document.getElementById("maxChain").value) }, jc = { ...jc, ...t }, s.reset(), r() }), window.addEventListener("keyup", t => { "r" !== t.key && "R" !== t.key || s.reset(), "Escape" !== t.key && "Esc" !== t.key && "s" !== t.key && "S" !== t.key || (e ? r() : (i.classList.add("open"), e = !0)) }), window.addEventListener("resize", () => { s.reset() }) })(), a.add(Ae), a.mixin(bs, { accessible: !1, accessibleTitle: null, accessibleHint: null, tabIndex: 0, accessibleType: "button", accessibleText: null, accessiblePointerEvents: "auto", accessibleChildren: !0, fi: !1, ci: null, Xe: -1 }), a.add(Yi), a.add(Ki), a.add(eh), a.mixin(bs, ih), a.add(Ho), a.add(Vu), a.add(Jr), a.add(Xu), a.add(ic), a.add(nc), a.add(Bc), a.add(Ic), a.add(Cc), a.add(Oc), a.add(kc), a.add(gc), a.add(ac), a.add(uh), a.add(oh); const qc = Object.freeze(Object.defineProperty({ __proto__: null }, Symbol.toStringTag, { value: "Module" })), Xc = Object.freeze(Object.defineProperty({ __proto__: null }, Symbol.toStringTag, { value: "Module" }));
